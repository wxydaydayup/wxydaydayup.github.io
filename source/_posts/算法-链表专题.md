---
rauthor: WangXinYi
img: /images/homePage/链表.webp
summary: 算法-链表专题
categories:
  - 算法
  - C++
  - 链表
tags:
  - 算法
  - C++
  - 链表
typora-root-url: ..
date: 2021-10-20 12:06:57
---

## C++的链表节点定义

+ [148. 排序链表 - 力扣（Leetcode）](https://leetcode.cn/problems/sort-list/?favorite=2cktkvj)

C/C++的定义链表节点方式，如下所示：

```cpp
struct ListNode {
    int val;  								 // 节点上存储的元素
    ListNode *next;  						 // 指向下一个节点的指针
    ListNode(int x) : val(x), next(NULL) {}  // 节点的构造函数
};
```

C++默认生成一个构造函数，但是这个构造函数不会初始化任何成员变量

通过自定义构造函数初始化节点：

```cpp
ListNode* head = new ListNode(5);
```

使用默认构造函数初始化节点：

```cpp
ListNode* head = new ListNode();
head->val = 5;
```

所以如果不定义构造函数使用默认构造函数的话，在初始化的时候就不能直接给变量赋值！

## 单个链表问题

### 设计链表

#### 相关链接

+ [707. 设计链表](https://leetcode.cn/problems/design-linked-list/)

#### 相关题目

设计链表的实现。您可以选择使用单链表或双链表。单链表中的节点应该具有两个属性：`val` 和 `next`。`val` 是当前节点的值，`next` 是指向下一个节点的指针/引用。如果要使用双向链表，则还需要一个属性 `prev` 以指示链表中的上一个节点。**假设链表中的所有节点都是 从 0 的。**

在链表类中实现这些功能：

+ get(index)：获取链表中第 `index` 个节点的值。如果索引无效，则返回`-1`。
+ addAtHead(val)：在链表的第一个元素之前添加一个值为 `val` 的节点。插入后，新节点将成为链表的第一个节点。
+ addAtTail(val)：将值为 `val` 的节点追加到链表的最后一个元素。
+ addAtIndex(index,val)：在链表中的第 `index` 个节点之前添加值为 `val` 的节点。如果 `index` 等于链表的长度，则该节点将附加到链表的末尾。如果 `index` 大于链表长度，则不会插入节点。如果`index`小于0，则在头部插入节点。
+ deleteAtIndex(index)：如果索引 `index` 有效，则删除链表中的第 `index` 个节点。

**示例：**

```
MyLinkedList linkedList = new MyLinkedList();
linkedList.addAtHead(1);
linkedList.addAtTail(3);
linkedList.addAtIndex(1,2);   //链表变为1-> 2-> 3
linkedList.get(1);            //返回2
linkedList.deleteAtIndex(1);  //现在链表是1-> 3
linkedList.get(1);            //返回3
```

#### 解题思路

```cpp
class MyLinkedList {
public:
    // 定义链表节点结构体
    struct LinkedNode {
        int val;
        LinkedNode* next;
        LinkedNode(int val):val(val), next(nullptr){}
    };

    // 初始化链表
    MyLinkedList() {
        _dummyHead = new LinkedNode(0); // 这里定义的头结点 是一个虚拟头结点，而不是真正的链表头结点
        _size = 0;
    }

    // 获取到第index个节点数值，如果index是非法数值直接返回-1， 注意index是从0开始的，第0个节点就是头结点
    int get(int index) {
        if (index > (_size - 1) || index < 0) {
            return -1;
        }
        LinkedNode* cur = _dummyHead->next;
        while(index--){ // 如果--index 就会陷入死循环
            cur = cur->next;
        }
        return cur->val;
    }

    // 在链表最前面插入一个节点，插入完成后，新插入的节点为链表的新的头结点
    void addAtHead(int val) {
        LinkedNode* newNode = new LinkedNode(val);
        newNode->next = _dummyHead->next;
        _dummyHead->next = newNode;
        _size++;
    }

    // 在链表最后面添加一个节点
    void addAtTail(int val) {
        LinkedNode* newNode = new LinkedNode(val);
        LinkedNode* cur = _dummyHead;
        while(cur->next != nullptr){
            cur = cur->next;
        }
        cur->next = newNode;
        _size++;
    }

    // 在第index个节点之前插入一个新节点，例如index为0，那么新插入的节点为链表的新头节点。
    // 如果index 等于链表的长度，则说明是新插入的节点为链表的尾结点
    // 如果index大于链表的长度，则返回空
    // 如果index小于0，则置为0，作为链表的新头节点。
    void addAtIndex(int index, int val) {
        if (index > _size) return;
	    if (index < 0) index = 0;
        LinkedNode* newNode = new LinkedNode(val);
        LinkedNode* cur = _dummyHead;
        while(index--) {
            cur = cur->next;
        }
        newNode->next = cur->next;
        cur->next = newNode;
        _size++;
    }

    // 删除第index个节点，如果index 大于等于链表的长度，直接return，注意index是从0开始的
    void deleteAtIndex(int index) {
        if (index >= _size || index < 0) {
            return;
        }
        LinkedNode* cur = _dummyHead;
        while(index--) {
            cur = cur ->next;
        }
        LinkedNode* tmp = cur->next;
        cur->next = cur->next->next;
        delete tmp;
        _size--;
    }

    // 打印链表
    void printLinkedList() {
        LinkedNode* cur = _dummyHead;
        while (cur->next != nullptr) {
            cout << cur->next->val << " ";
            cur = cur->next;
        }
        cout << endl;
    }
private:
    int _size;
    LinkedNode* _dummyHead;
};
```

### 反转链表

#### 相关链接

+ [206. 反转链表 ](https://leetcode.cn/problems/reverse-linked-list/)
+ [剑指 Offer II 反转链表 ](https://leetcode.cn/problems/UHnkqh/?favorite=e8X3pBZi)

#### 相关题目

给你单链表的头节点 `head` ，请你反转链表，并返回反转后的链表。

**示例 1：**

<img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg" alt="示例1" style="zoom:50%;box-shadow:rgba(0,0,0,0) 0 0px 0px 0px;" />

```
输入：head = [1,2,3,4,5]
输出：[5,4,3,2,1]
```

#### 解题思路

首先定义一个cur指针，指向头结点，再定义一个pre指针，初始化为null。

然后就要开始反转了，首先要把 cur->next 节点用tmp指针保存一下，也就是保存一下这个节点。为什么要保存一下这个节点呢，因为接下来要改变 cur->next 的指向了，将cur->next 指向pre ，此时已经反转了第一个节点了。

接下来就是继续移动pre和cur指针。

最后，cur 指针已经指向了null，循环结束，链表也反转完毕了。 此时我们return pre指针就可以了，pre指针就指向了新的头结点。

<img src="/images/%E7%AE%97%E6%B3%95-%E9%93%BE%E8%A1%A8%E4%B8%93%E9%A2%98/E8EC98F7B78A51A486D13CD1BA319199.jpg" alt="E8EC98F7B78A51A486D13CD1BA319199" style="zoom: 25%;" />

```cpp
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode* cur = head;
        ListNode* pre = NULL;
        while(cur){
            auto tmp = cur->next;
            cur->next = pre;
            pre = cur;
            cur = tmp;
        }
        return pre;
    }
};
```

递归版本实现

```cpp
class Solution {
public:    
    ListNode* ReverseList(ListNode* pHead) {
		return reverse(NULL, pHead);
    }
	ListNode* reverse(ListNode* pre, ListNode* cur) {
		if(!cur) return pre;
		ListNode* tmp = cur->next;
		cur->next = pre;
		return reverse(cur, tmp);
	}
};
```

换一种思路

<img src="/images/%E7%AE%97%E6%B3%95-%E9%93%BE%E8%A1%A8%E4%B8%93%E9%A2%98/9807F6A5F8976BE8D9FFD7E353AE1208.jpg" alt="第二种思路" style="zoom: 25%;" />

```cpp
class Solution {
public:   
	ListNode* ReverseList(ListNode* pHead) {
		if(!pHead) return NULL;
		ListNode* pre = new ListNode(-1);
		pre->next = pHead;
		ListNode* cur = pHead;
		while(cur->next) {
			auto tmp = cur->next;
			cur->next = cur->next->next;
			tmp->next = pre->next;
			pre->next = tmp;
		}
		return pre->next;
    }
};
```

### 链表中的节点每k个一组翻转

#### 相关链接

+ [链表中的节点每k个一组翻转_牛客题霸](https://www.nowcoder.com/practice/b49c3dc907814e9bbfa8437c251b028e?tpId=295&tqId=722&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26tab%3D%E7%AE%97%E6%B3%95%E7%AF%87%26topicId%3D295%26fromPut%3Dpc_kol_aaaxiu)

#### 相关题目

将给出的链表中的节点每 k 个一组翻转，返回翻转后的链表
如果链表中的节点数不是 k 的倍数，将最后剩下的节点保持原样
你不能更改节点中的值，只能更改节点本身。

#### 解题思路

```cpp
class Solution {
public:
    ListNode* reverseKGroup(ListNode* head, int k) {
        ListNode* tail = head;
        for(int i = 0 ;i < k; i++) {
            if(!tail) return head;
            tail = tail->next;
        }
        ListNode* pre = NULL, *cur = head;
        while(cur != tail) {
            ListNode* tmp = cur->next;
            cur->next = pre;
            pre = cur;
            cur = tmp;
        }
        // head 指的就是反转后的末尾
        head->next = reverseKGroup(tail, k);
        return pre;
    }
};
```

###  链表内指定区间反转

#### 相关链接

+ [链表内指定区间反转_牛客题霸](https://www.nowcoder.com/practice/b58434e200a648c589ca2063f1faf58c?tpId=295&tqId=654&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26tab%3D%E7%AE%97%E6%B3%95%E7%AF%87%26topicId%3D295%26fromPut%3Dpc_kol_aaaxiu)

#### 相关题目

将一个节点数为 size 链表 m 位置到 n 位置之间的区间反转，要求时间复杂度*O*(*n*)，空间复杂度 *O*(1)。

<img src="/images/%E7%AE%97%E6%B3%95-%E9%93%BE%E8%A1%A8%E4%B8%93%E9%A2%98/image-20230416101231865.png" alt="image-20230416101231865" style="zoom:67%;" />

#### 解题思路

**示例1**

```
输入：{1,2,3,4,5},2,4
返回值：{1,4,3,2,5}
```

和之前同样的思路，只不过是记忆了修改之前的位置

<img src="/images/%E7%AE%97%E6%B3%95-%E9%93%BE%E8%A1%A8%E4%B8%93%E9%A2%98/E8EC98F7B78A51A486D13CD1BA319199.jpg" alt="E8EC98F7B78A51A486D13CD1BA319199" style="zoom: 150%;" />

```cpp
class Solution {
public:    
    ListNode* reverseBetween(ListNode* head, int m, int n) {
        ListNode* dummy = new ListNode(-1);
        dummy->next = head;
        auto pre = dummy, cur = head;
        for(int i = 1; i < m; i++) {
            pre = pre->next;
            cur = cur->next;
        }
        ListNode* beforePre = pre;//1.
        ListNode* beforeCur = cur;//2.
        for(int i = m; i <= n; i++) {
            auto tmp = cur->next;
            cur->next = pre;
            pre = cur;
            cur = tmp;
        }
        beforePre->next = pre;//3.
        beforeCur->next = cur;//4.
        return dummy->next;
    }
};
```

换了一种思路

<img src="/images/%E7%AE%97%E6%B3%95-%E9%93%BE%E8%A1%A8%E4%B8%93%E9%A2%98/9807F6A5F8976BE8D9FFD7E353AE1208.jpg" alt="第二种思路" style="zoom: 33%;" />

```cpp
class Solution {
public:
    ListNode* reverseBetween(ListNode* head, int m, int n) {
        ListNode* dummy = new ListNode(-1);
        dummy->next = head;
        auto pre = dummy, cur = head;
        for(int i = 1; i < m; i++) {
            pre = pre->next;
            cur = cur->next;
        }
        for(int i = m; i < n; i++) {
            auto tmp = cur->next;
            cur->next = cur->next->next;
            tmp->next = pre->next;
            pre->next = tmp;
        }
        return dummy->next;
    }
};
```

### 重排链表

#### 相关链接

+ [剑指 Offer II  重排链表](https://leetcode.cn/problems/LGjMqU/description/)

#### 相关题目

给定一个单链表 `L` 的头节点 `head` ，单链表 `L` 表示为：

` L0 → L1 → … → Ln-1 → Ln `
请将其重新排列后变为：

```
L0 → Ln → L1 → Ln-1 → L2 → Ln-2 → …
```

不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。

**示例 1:**

<img src="/images/%E7%AE%97%E6%B3%95-%E9%93%BE%E8%A1%A8%E4%B8%93%E9%A2%98/image-20221211112644034.png" alt="示例1" style="zoom:80%;box-shadow:rgba(0,0,0,0) 0 0px 0px 0px;" />

```
输入: head = [1,2,3,4]
输出: [1,4,2,3]
```

#### 解题思路

```cpp
class Solution {
public:
    void reorderList(ListNode* head) {
        if(!head && !head->next) return;
        auto mid = halfList(head);
        auto l1 = head;
        auto l2 = mid->next;
        mid->next = NULL;
        l2 = reverseList(l2);
        while(l1 && l2) {
            auto t1 = l1->next;
            auto t2 = l2->next;
            l1->next = l2;
            l1 = t1;
            l2->next = l1;
            l2 = t2;  
        }
    }
    ListNode* halfList(ListNode* head){
        auto fast = head, slow = head;
        while(fast->next && fast->next->next){
            fast = fast->next->next;
            slow = slow->next;
        } 
        return slow;
    }
    ListNode* reverseList(ListNode* head){
        auto cur = head;
        ListNode* res = NULL;
        while(cur){
            auto tmp = cur->next;
            cur->next = res;
            res = cur;
            cur = tmp;
        } 
        return res;
    }
};
```

### 链表的奇偶重排

#### 相关链接

+ [链表的奇偶重排_牛客题霸](https://www.nowcoder.com/practice/02bf49ea45cd486daa031614f9bd6fc3?tpId=295&tqId=1073463&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26tab%3D%E7%AE%97%E6%B3%95%E7%AF%87%26topicId%3D295%26fromPut%3Dpc_kol_aaaxiu)

#### 相关题目

给定一个单链表，请设定一个函数，将链表的奇数位节点和偶数位节点分别放在一起，重排后输出。

注意是节点的编号而非节点的数值。


#### 解题思路

```cpp
class Solution {
public:   
	ListNode* oddEvenList(ListNode* head) {
        if(!head) return nullptr;
        ListNode* evenHead = head->next;
        ListNode* old = head, *even = evenHead;
        while(even && even->next) {
            old->next = even->next;
            old = old->next;
            even->next = old->next;
            even = even->next;
        }
        old->next = evenHead;
        return head;
    }
};
```


### 回文链表

#### 相关链接

+ [剑指 Offer II  回文链表 ](https://leetcode.cn/problems/aMhZSa/description/)
+ [234. 回文链表](https://leetcode.cn/problems/palindrome-linked-list/?favorite=2cktkvj)

#### 相关题目

给定一个链表的 **头节点** `head` **，**请判断其是否为回文链表。

如果一个链表是回文，那么链表节点序列从前往后看和从后往前看是相同的。

**示例 1：**

<img src="/images/%E7%AE%97%E6%B3%95-%E9%93%BE%E8%A1%A8%E4%B8%93%E9%A2%98/image-20221211112820854.png" alt="示例1" style="zoom:100%;box-shadow:rgba(0,0,0,0) 0 0px 0px 0px;"  />

```
输入: head = [1,2,3,3,2,1]
输出: true
```

#### 解题思路

```cpp
class Solution {
public:    
	bool isPalindrome(ListNode* head) {
        if(head == NULL) return true;
        auto half = halfList(head);
        auto rev = reverseList(half->next);
        auto p = rev;
        while(p) {
            if(p->val != head->val) return false;
            p = p->next;
            head = head->next;
        }
        half->next = reverseList(rev);
        return true;
    }
    ListNode* halfList(ListNode* head){
        auto slow = head;
        auto fast = head;
        while(fast->next != NULL && fast->next->next != NULL)
        {
            slow = slow->next;
            fast = fast->next->next;
        }
        return slow;
    }
    ListNode* reverseList(ListNode* head){
        ListNode* prev = NULL;
        auto cur = head;
        while(cur){
            auto tmp = cur->next;
            cur->next = prev;
            prev = cur;
            cur = tmp;
        }
        return prev;
    }
};
```

### 删除链表元素

#### 相关链接

+ [203. 移除链表元素](https://leetcode.cn/problems/remove-linked-list-elements/description/)

#### 相关题目
给你一个链表的头节点 `head` 和一个整数 `val` ，请你删除链表中所有满足 `Node.val == val` 的节点，并返回 **新的头节点** 。

**示例 1：**

<img src="https://assets.leetcode.com/uploads/2021/03/06/removelinked-list.jpg" alt="示例1" style="zoom:50%;box-shadow:rgba(0,0,0,0) 0 0px 0px 0px;" />

```
输入：head = [1,2,6,3,4,5,6], val = 6
输出：[1,2,3,4,5]
```

#### 解题思路

**设置一个虚拟头结点**，这样原链表的所有节点就都可以按照统一的方式进行移除了。

```cpp
class Solution {
public:
    ListNode* removeElements(ListNode* head, int val) {
        ListNode* dummyHead = new ListNode(0);
        dummyHead->next = head;
        ListNode* cur = dummyHead;
        while(cur->next){
            if(cur->next->val == val) cur->next = cur->next->next;
            else cur = cur->next;
        } 
        head = dummyHead->next;//防止删除的是原来的头节点
        delete dummyHead;
        return head;
    }
};
```

### 删除链表倒数第 N 个结点

#### 相关链接

+ [19. 删除链表的倒数第 N 个结点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/)
+ [剑指 Offer II 删除链表的倒数第 N 个结点 ](https://leetcode.cn/problems/SLwz0R/?favorite=e8X3pBZi)

衍生题：[链表中倒数最后k个结点_牛客题霸_](https://www.nowcoder.com/practice/886370fe658f41b498d40fb34ae76ff9?tpId=295&tqId=1377477&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26tab%3D%E7%AE%97%E6%B3%95%E7%AF%87%26topicId%3D295%26fromPut%3Dpc_kol_aaaxiu)

#### 相关题目

给你一个链表，删除链表的倒数第 `n` 个结点，并且返回链表的头结点。

**示例 1：**

<img src="https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg" alt="示例1" style="zoom:50%;box-shadow:rgba(0,0,0,0) 0 0px 0px 0px;" />

```
输入：head = [1,2,3,4,5], n = 2
输出：[1,2,3,5]
```

#### 解题思路

双指针的经典应用，如果要删除倒数第n个节点，让fast移动n步，然后让fast和slow同时移动，直到fast指向链表末尾。删掉slow所指向的节点就可以了。

1. 定义fast指针和slow指针，初始值为虚拟头结点，如图：

<img src="https://code-thinking.cdn.bcebos.com/pics/19.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9.png"  style="zoom: 33%;box-shadow:rgba(0,0,0,0) 0 0px 0px 0px;" />

2. fast首先走n + 1步 ，为什么是n+1呢，因为只有这样同时移动的时候slow才能指向删除节点的上一个节点（方便做删除操作），如图： <img src="https://code-thinking.cdn.bcebos.com/pics/19.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B91.png"  style="zoom:33%;box-shadow:rgba(0,0,0,0) 0 0px 0px 0px;" />

3. fast和slow同时移动，直到fast指向末尾，如题： <img src="https://code-thinking.cdn.bcebos.com/pics/19.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B92.png" style="zoom:33%;box-shadow:rgba(0,0,0,0) 0 0px 0px 0px;" />

4. 删除slow指向的下一个节点，如图： <img src="https://code-thinking.cdn.bcebos.com/pics/19.%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B93.png"  style="zoom:33%;box-shadow:rgba(0,0,0,0) 0 0px 0px 0px;" />

完整代码如下：

```cpp
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        ListNode* dummyHead = new ListNode(0);
        dummyHead->next = head;
        auto fast = dummyHead, slow = dummyHead;
        while(n-- && fast != NULL) fast = fast->next;
        if(n > 0) return NULL; //尤其需要注意这一点
        // fast需要再提前走一步，因为需要让slow指向删除节点的上一个节点
        fast = fast->next;
        while(fast){
            fast = fast->next;
            slow = slow->next;
        }
        slow->next = slow->next->next;
        return dummyHead->next;
    }
};
```

返回链表中倒数最后k个结点

```cpp
ListNode* FindKthToTail(ListNode* pHead, int k) {
    if(!pHead) return nullptr;
    auto fast = pHead, slow = pHead;
    while(fast && k--) fast = fast->next;
    if(k > 0) return nullptr;//尤其需要注意这一点
    while(fast) {
        fast = fast->next;
        slow = slow->next;
    }
    return slow;
}
```

### 删除有序链表中重复的元素-I

#### 相关链接

+ [删除有序链表中重复的元素-I_牛客题霸](https://www.nowcoder.com/practice/c087914fae584da886a0091e877f2c79?tpId=295&tqId=664&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26tab%3D%E7%AE%97%E6%B3%95%E7%AF%87%26topicId%3D295%26fromPut%3Dpc_kol_aaaxiu)

#### 相关题目

删除给出链表中的重复元素（链表中元素从小到大有序），使链表中的所有元素都只出现一次

例如 1-1-2-3 只保留 1-2-3

#### 解题思路

```cpp
class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {
        if(!head) return nullptr;
        auto cur = head;
        while (cur->next) {
            if(cur->val == cur->next->val) cur->next = cur->next->next;
            else cur = cur->next; // 注意else
        }
        return head;
    }
};
```

### 删除有序链表中重复的元素-II

#### 相关链接

+ [删除有序链表中重复的元素-II_牛客题霸](https://www.nowcoder.com/practice/71cef9f8b5564579bf7ed93fbe0b2024?tpId=295&tqId=663&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26tab%3D%E7%AE%97%E6%B3%95%E7%AF%87%26topicId%3D295%26fromPut%3Dpc_kol_aaaxiu)

#### 相关题目

给出一个升序排序的链表，删除链表中的所有重复出现的元素，只保留原链表中只出现一次的元素。

例如 1-1-2-3 只保留 2-3

#### 解题思路

```cpp
class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {
        ListNode* dummy = new ListNode(1001);
        dummy->next = head;
        ListNode* cur = dummy;
        while(cur->next && cur->next->next) {
            if(cur->next->val == cur->next->next->val) {
                int tmp = cur->next->val;
                while(cur->next && cur->next->val == tmp) {
                    cur->next = cur->next->next;
                }
            }
            else cur = cur->next;
        }
        return dummy->next;
    }
};
```

### 两两交换链表中的节点

#### 相关链接

+ [24. 两两交换链表中的节点 ](https://leetcode.cn/problems/swap-nodes-in-pairs/)

#### 相关题目

给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。

**示例 1：**

<img src="https://assets.leetcode.com/uploads/2020/10/03/swap_ex1.jpg" alt="示例1" style="zoom:50%;box-shadow:rgba(0,0,0,0) 0 0px 0px 0px;" />

```
输入：head = [1,2,3,4]
输出：[2,1,4,3]
```

#### 解题思路

交换相邻两个元素了，**此时一定要画图，不画图，操作多个指针很容易乱，而且要操作的先后顺序**

初始时，cur指向虚拟头结点，然后进行如下三步：

<img src="https://code-thinking.cdn.bcebos.com/pics/24.%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B91.png" alt="两两交换链表中的节点1" style="zoom: 33%;box-shadow:rgba(0,0,0,0) 0 0px 0px 0px;" />

操作之后，链表如下：

<img src="https://code-thinking.cdn.bcebos.com/pics/24.%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B92.png" alt="两两交换链表中的节点2" style="zoom:33%;box-shadow:rgba(0,0,0,0) 0 0px 0px 0px;" />

看这个可能就更直观一些了：

<img src="https://code-thinking.cdn.bcebos.com/pics/24.%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B93.png" alt="两两交换链表中的节点3" style="zoom:33%;box-shadow:rgba(0,0,0,0) 0 0px 0px 0px;" />

对应的C++代码实现如下： （注释中详细和如上图中的三步做对应）

```cpp
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        ListNode* dummyHead = new ListNode(0); // 设置一个虚拟头结点
        dummyHead->next = head; 			   // 将虚拟头结点指向head，这样方面后面做删除操作
        ListNode* cur = dummyHead;
        while(cur->next != NULL && cur->next->next != NULL) {
            ListNode* tmp = cur->next; 		   // 记录临时节点
            ListNode* tmp1 = cur->next->next->next; // 记录临时节点

            cur->next = cur->next->next;       // 步骤一
            cur->next->next = tmp;             // 步骤二
            cur->next->next->next = tmp1;      // 步骤三

            cur = cur->next->next;             // cur移动两位，准备下一轮交换
        }
        return dummyHead->next;
    }
};
```

## 排序链表问题

### 对链表进行排序-插入排序

#### 相关链接

+ [147. 对链表进行插入排序](https://leetcode.cn/problems/insertion-sort-list/)

#### 相关题目

给定单个链表的头 `head` ，使用 **插入排序** 对链表进行排序，并返回 *排序后链表的头* 。

**插入排序** 算法的步骤:

1. 插入排序是迭代的，每次只移动一个元素，直到所有元素可以形成一个有序的输出列表。
2. 每次迭代中，插入排序只从输入数据中移除一个待排序的元素，找到它在序列中适当的位置，并将其插入。
3. 重复直到所有输入数据插入完为止。

下面是插入排序算法的一个图形示例。部分排序的列表(黑色)最初只包含列表中的第一个元素。每次迭代时，从输入数据中删除一个元素(红色)，并就地插入已排序的列表中。

对链表进行插入排序。

**示例 1：**

<img src="https://assets.leetcode.com/uploads/2021/03/04/sort1linked-list.jpg" alt="img" style="zoom:50%;" />

```
输入: head = [4,2,1,3]
输出: [1,2,3,4]
```

#### 解题思路

```cpp
class Solution {
public:
    ListNode* insertionSortList(ListNode* head) {
        if(!head) return NULL;
        ListNode* dummy = new ListNode(0);
        dummy->next =  head;
        ListNode* tail = head;
        ListNode* cur = tail->next;
        while(cur) {
            if(tail->val <= cur->val) tail = tail->next;
            else {
                ListNode* pre = dummy;
                while(pre->next->val <= cur->val) pre = pre->next;
                tail->next = cur->next;
                cur->next = pre->next;
                pre->next = cur;
            }
            cur = tail->next;
        }
        return dummy->next;
    }
};
```

### 合并两个有序链表

#### 相关链接

+ [21. 合并两个有序链表](https://leetcode.cn/problems/merge-two-sorted-lists/)

#### 相关题目

将两个升序链表合并为一个新的 **升序** 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 

**示例 1：**

<img src="https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg" alt="img" style="zoom:33%;" />

```
输入：l1 = [1,2,4], l2 = [1,3,4]
输出：[1,1,2,3,4,4]
```

#### 解题思路

```cpp
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
        if(!list1 || !list2) return list1 ? list1 : list2;
        ListNode* dummy = new ListNode(0);
        ListNode* tail = dummy;
        ListNode* a = list1,* b = list2;//可以不声明
        while(a && b) {
            if(a->val < b->val) {
                tail->next = a;
                a = a->next;
            } else {
                tail->next = b;
                b = b->next;
            }
            tail = tail->next;
        }
        tail->next = a ? a : b;
        return dummy->next;
    }
};
```

### 合并 K 个升序链表

#### 相关链接

+ [23. 合并 K 个升序链表](https://leetcode.cn/problems/merge-k-sorted-lists/description/?favorite=2cktkvj)

#### 相关题目

给你一个链表数组，每个链表都已经按升序排列。

请你将所有链表合并到一个升序链表中，返回合并后的链表。

**示例 1：**

```
输入：lists = [[1,4,5],[1,3,4],[2,6]]
输出：[1,1,2,3,4,4,5,6]
解释：链表数组如下：
[
  1->4->5,
  1->3->4,
  2->6
]
将它们合并到一个有序链表中得到。
1->1->2->3->4->4->5->6
```

#### 解题思路

**三种方法**

1、扔到vector，排序后再建链表

2、合并两个有序链表+分治合并优化

```cpp
class Solution {
public:
    ListNode* mergeTwoLists(ListNode *a, ListNode *b) {
        if (!a || !b) return a ? a : b;
        ListNode *dummy = new ListNode(), *tail = head;
        while (a && b) {
            if (a->val < b->val) {
                tail->next = a; a = a->next;
            } else {
                tail->next = b; b = b->next;
            }
            tail = tail->next;
        }
        tail->next = (a ? a : b);
        return dummy->next;
    }

    ListNode* merge(vector <ListNode*> &lists, int l, int r) {
        if (l == r) return lists[l];
        if (l > r) return nullptr;
        int mid = (l + r) >> 1;
        return mergeTwoLists(merge(lists, l, mid), merge(lists, mid + 1, r));
    }

    ListNode* mergeKLists(vector<ListNode*>& lists) {
        return merge(lists, 0, lists.size() - 1);
    }
};
```

**复杂度分析**

+ 时间复杂度：考虑递归「向上回升」的过程——第一轮合并k/2组链表，每一组的时间代码是O(2n) ；第二轮合并k/4 组链表，每一组的时间代价是O(4n)，所以总的时间代价是 <img src="/images/%E7%AE%97%E6%B3%95-%E9%93%BE%E8%A1%A8%E4%B8%93%E9%A2%98/image-20230410190224274.png" alt="image-20230410190224274" style="zoom:90%;" />，渐进时间复杂度为O(kn * logk)

3、使用优先队列合并

这个方法和前两种方法的思路有所不同，我们需要维护当前每个链表没有被合并的元素的最前面一个，k个链表就最多有 k个满足这样条件的元素，每次在这些元素里面选取 val属性最小的元素合并到答案中。在选取最小元素的时候，我们可以用优先队列来优化这个过程。

```cpp
class Solution {
public:
    struct comp {
        bool operator()(ListNode* a, ListNode* b) {
            return a->val > b->val;
        }
    };

    priority_queue<ListNode*, vector<ListNode*>, comp> q;

    ListNode* mergeKLists(vector<ListNode*>& lists) {
        for (auto node: lists) {
            if (node) q.push(node);
        }
        ListNode* head = new ListNode();
        ListNode* tail = head;
        while (!q.empty()) {
            ListNode* node = q.top();
            q.pop();
            tail->next = node; 
            tail = tail->next;
            if (node->next) q.push(node->next);
        }
        return head->next;
    }
};
```

复杂度分析

+ 时间复杂度：考虑优先队列中的元素不超过 k 个，那么插入和删除的时间代价为 O(log⁡k)，这里最多有 kn个点，对于每个点都被插入删除各一次，故总的时间代价即渐进时间复杂度为 O(kn×log⁡k)。
+ 空间复杂度：这里用了优先队列，优先队列中的元素不超过 k 个，故渐进空间复杂度为 O(k)。

### 对链表进行排序-归并排序

#### 相关链接

+ [单链表的排序_牛客题霸](https://www.nowcoder.com/practice/f23604257af94d939848729b1a5cda08?tpId=295&tqId=1008897&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26tab%3D%E7%AE%97%E6%B3%95%E7%AF%87%26topicId%3D295%26fromPut%3Dpc_kol_aaaxiu)

+ [148. 排序链表](https://leetcode.cn/problems/sort-list/description/?favorite=2cktkvj)

#### 相关题目

给你链表的头结点 `head` ，请将其按 **升序** 排列并返回 **排序后的链表** 。

**示例 1：**

<img src="https://assets.leetcode.com/uploads/2020/09/14/sort_list_1.jpg" alt="img" style="zoom:67%;" />

```
输入：head = [4,2,1,3]
输出：[1,2,3,4]
```

#### 解题思路

牛客的写法，简约方便

+ step 1：首先判断链表为空或者只有一个元素，直接就是有序的。
+ step 2：准备三个指针，快指针right每次走两步，慢指针mid每次走一步，前序指针left每次跟在mid前一个位置。三个指针遍历链表，当快指针到达链表尾部的时候，慢指针mid刚好走了链表的一半，正好是中间位置。
+ step 3：从left位置将链表断开，刚好分成两个子问题开始递归

对应例子的来说，2相当于left位置，1相当于mid位置，最后的空节点是right的位置

```cpp
class Solution {
public:
    ListNode* sortInList(ListNode* head) {
        if(!head || !head->next) return head;
        ListNode* left = head,* mid = head->next,* right = head->next->next;
        while(right && right->next) {
            left = left->next;
            mid = mid->next;
            right = right->next->next;
        }
        left->next = NULL;
        return merge(sortInList(head), sortInList(mid));
    }
    ListNode* merge(ListNode* p1, ListNode* p2) {
        if(!p1 || !p2) return p1 ? p1 : p2;
        ListNode* dummy = new ListNode(0);
        ListNode* cur = dummy;
        while(p1 && p2) {
            if(p1->val < p2->val) {
                cur->next = p1;
                p1 = p1->next;
            } else {
                cur->next = p2;
                p2 = p2->next;
            }
            cur = cur->next;
        }
        cur->next = p1 ? p1 : p2;
        return dummy->next;
    }
};
```

力扣题解-比较麻烦

```cpp
class Solution {
public:
    ListNode* sortList(ListNode* head) {
        if(!head) return NULL;
        auto tmp = head;
        int length = 0;
        while(tmp) {
            length++;
            tmp = tmp->next;
        }
        ListNode* dummy = new ListNode(0, head);
        for(int subLength = 1; subLength < length; subLength <<= 1) {
            auto pre = dummy, cur = dummy->next;
            while(cur) {
                auto head1 = cur;
                for(int i = 1; i < subLength && cur->next; i++) cur = cur->next;

                auto head2 = cur->next;
                cur->next = NULL;
                cur = head2;
                for(int i = 1; i < subLength && cur && cur->next; i++) cur = cur->next;

                ListNode* next = NULL;
                if(cur) {
                    next = cur->next;
                    cur->next =  NULL;
                }
                
                ListNode* merged = merge(head1, head2);
                pre->next = merged;
                while(pre->next) pre = pre->next;
                cur = next;
            }   
        }
        return dummy->next;
    }
    ListNode* merge(ListNode* list1, ListNode* list2) {
        if((!list1) && (!list2)) return list1 ? list1 : list2;
        ListNode* head = new ListNode();
        ListNode* tail = head;
        ListNode* a = list1,* b = list2;
        
        while(a && b) {
            if(a->val < b->val) {
                tail->next = a;
                a = a->next;
            } else {
                tail->next = b;
                b = b->next;
            }
            tail = tail->next;
        }
        tail->next = a ? a : b;
        return head->next;
    }
};
```

## 多个链表问题

### 链表的首个重合节点

#### 相关链接

+ [160. 相交链表 ](https://leetcode.cn/problems/intersection-of-two-linked-lists/description/)
+ [面试题 链表相交 ](https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/)
+ [剑指 Offer II  两个链表的第一个重合节点](https://leetcode.cn/problems/3u1WK4/description/)

#### 相关题目

给定两个单链表的头节点 `headA` 和 `headB` ，请找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 `null` 。

图示两个链表在节点 `c1` 开始相交**：**



<img src="/images/%E7%AE%97%E6%B3%95-%E9%93%BE%E8%A1%A8%E4%B8%93%E9%A2%98/image-20221211113011498.png" alt="示例1" style="zoom: 33%; box-shadow: rgba(0, 0, 0, 0) 0px 0px 0px 0px;" />

题目数据 **保证** 整个链式结构中不存在环。

**注意**，函数返回结果后，链表必须 **保持其原始结构** 。

**示例 1：**

<img src="/images/%E7%AE%97%E6%B3%95-%E9%93%BE%E8%A1%A8%E4%B8%93%E9%A2%98/image-20221211113102248.png" alt="示例1" style="zoom: 33%; box-shadow: rgba(0, 0, 0, 0) 0px 0px 0px 0px;" />

```
输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3
输出：Intersected at '8'
解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。
从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。
在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。
```

#### 解题思路

经典环的入口类问题，从A出发再走B的路程，和从B出发再走A的路程是距离是一样。可以根据这个特性求出链表重合的节点。

```cpp
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        if(!headA || !headB) return NULL;
        auto p1 = headA, p2 = headB;
        while(p1 != p2){
            p1 = !p1 ? headB : p1->next; // 一定要注意，这里传入的是headB，不是p2
            p2 = !p2 ? headA : p2->next;
        }
        return p1;
    }
};
```

### 链表的两数相加

#### 相关链接

+ [剑指 Offer II 链表中的两数相加](https://leetcode.cn/problems/lMSNwu/description/)

#### 相关题目

给定两个 **非空链表** `l1`和 `l2` 来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。

可以假设除了数字 0 之外，这两个数字都不会以零开头。

**示例1：**

<img src="/images/%E7%AE%97%E6%B3%95-%E9%93%BE%E8%A1%A8%E4%B8%93%E9%A2%98/image-20221211113202918.png" alt="示例1" style="zoom:40%;box-shadow: rgba(0, 0, 0, 0) 0px 0px 0px 0px;" />



```
输入：l1 = [7,2,4,3], l2 = [5,6,4]
输出：[7,8,0,7]
```

#### 解题思路

```cpp
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        stack<int> s1, s2;
        while(l1){
            s1.push(l1->val);
            l1 = l1->next;
        }
        while(l2){
            s2.push(l2->val);
            l2 = l2->next;
        }
        ListNode* ans = nullptr;
        int carry = 0;
        while(!s1.empty() || !s2.empty() || carry){
            int t1 = s1.empty() ? 0 : s1.top();
            int t2 = s2.empty() ? 0 : s2.top();
            if(!s1.empty()) s1.pop();
            if(!s2.empty()) s2.pop();
            
            int sum = carry + t1 + t2;
            carry = sum / 10;
            sum = sum % 10;
            
            auto sumNode = new ListNode(sum); 
            sumNode->next = ans;
            ans = sumNode;
        }    
        return ans;
    }
};
```

## 链表环问题

### 链表中环的入口节点

#### 相关链接

+ [142. 环形链表 II ](https://leetcode.cn/problems/linked-list-cycle-ii/description/)

+ [剑指 Offer II  链表中环的入口节点](https://leetcode.cn/problems/c32eOV/description/)

#### 相关题目

给定一个链表，返回链表开始入环的第一个节点。 从链表的头节点开始沿着 `next` 指针进入环的第一个节点为环的入口节点。如果链表无环，则返回 `null`。

为了表示给定链表中的环，我们使用整数 `pos` 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 `pos` 是 `-1`，则在该链表中没有环。**注意，`pos` 仅仅是用于标识环的情况，并不会作为参数传递到函数中。**

**说明：**不允许修改给定的链表。

**示例 1：**

<img src="/images/%E7%AE%97%E6%B3%95-%E9%93%BE%E8%A1%A8%E4%B8%93%E9%A2%98/image-20221211113248425.png" alt="示例1" style="zoom:50%;box-shadow:rgba(0,0,0,0) 0 0px 0px 0px;" />

```
输入：head = [3,2,0,-4], pos = 1
输出：返回索引为 1 的链表节点
解释：链表中有一个环，其尾部连接到第二个节点。
```

#### 解题思路

```cpp
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        auto fast = head, slow = head;
        while(fast->next && fast->next->next){
            fast = fast->next->next;
            slow = slow->next;
            if(fast == slow) {
                auto p = head;
                while(p != slow){
                    p = p->next;
                    slow = slow->next;     
                }
                return slow;
            }
        }
        return NULL;
    }
};
```

**证明如下：**

<img src="/images/%E7%AE%97%E6%B3%95-%E9%93%BE%E8%A1%A8%E4%B8%93%E9%A2%98/image-20221211113330346.png" alt="证明图" style="zoom: 80%;box-shadow:rgba(0,0,0,0) 0 1px 5px 0px;" />



> 设链表中 **环外** 部分的长度为 a。slow 指针进入环后，又走了 b 的距离与fast 相遇。
>
> 所以慢指针走过的距离为`a + b`
>
> 此时，fast 指针已经走完了环的 n 圈，因此它走过的总距离为 `a + n(b+c) + b `
>
> fast 指针走过的路程又等于慢指针的2倍，所以  `a + n(b+c) + b  `=`2 * (a + b)`
>
> 可化简为 ` a = c + (n−1)(b+c)`,根据公式结合图像可以看出 `快慢指针相遇的位置` = `从相遇点到入环点的距离加上 n-1 圈的环长`