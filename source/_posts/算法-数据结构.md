---
rauthor: WangXinYi
img: /images/homePage/数据结构.webp
summary: 基本数据结构
categories:
  - 算法
  - C++
  - 数据结构
tags:
  - 算法
  - C++
  - 数据结构
top: false
typora-root-url: ..
date: 2021-10-20 12:06:57
---

# 基本数据结构

## 字符串

### 反转字符串II

#### 相关链接

+ [344. 反转字符串](https://leetcode.cn/problems/reverse-string/description/)
+ [541. 反转字符串 II ](https://leetcode.cn/problems/reverse-string-ii/)

#### 相关题目

给定一个字符串 `s` 和一个整数 `k`，从字符串开头算起，每计数至 `2k` 个字符，就反转这 `2k` 字符中的前 `k` 个字符。

+ 如果剩余字符少于 `k` 个，则将剩余字符全部反转。
+ 如果剩余字符小于 `2k` 但大于或等于 `k` 个，则反转前 `k` 个字符，其余字符保持原样。

**示例 1：**

```
输入：s = "abcdefg", k = 2
输出："bacdfeg"
```

#### 解题思路

[344. 反转字符串](https://leetcode.cn/problems/reverse-string/description/)

```cpp
class Solution {
public:
    void reverseString(vector<char>& s) {
        for(int i = 0, j = s.size() - 1; i < j; i++, j--) {
            swap(s[i], s[j]);
        }
    }
};
```

swap可以有两种实现。

一种就是常见的交换数值：

```cpp
int tmp = s[i];
s[i] = s[j];
s[j] = tmp;
```

一种就是通过位运算：

```cpp
s[i] ^= s[j];
s[j] ^= s[i];
s[i] ^= s[j];
```

[541. 反转字符串 II ](https://leetcode.cn/problems/reverse-string-ii/)

+ 剩余字符大于等于 `2k` 

+ 剩余字符小于 `2k` 但大于或等于 `k` 个
+ 剩余字符少于 `k` 个

前两种情况可以合并

```cpp
class Solution {
public:
    string reverseStr(string s, int k) {
        for(int i = 0; i < s.size(); i += 2 * k){
            if(i + k < s.size() ) {
                reverse(s.begin() + i, s.begin() + i + k);             
            } else {
                reverse(s.begin() + i, s.end());      
            }
        }
        return s;
    }
};
```

### 替换空格

#### 相关链接

+ [剑指 Offer 05. 替换空格 ](https://leetcode.cn/problems/ti-huan-kong-ge-lcof/description/)

#### 相关题目

请实现一个函数，把字符串 `s` 中的每个空格替换成"%20"。

**示例 1：**

```
输入：s = "We are happy."
输出："We%20are%20happy."
```

#### 解题思路

不用额外的辅助空间，首先扩充数组到每个空格替换成"%20"之后的大小。

然后从后向前替换空格，也就是双指针法，i指向新长度的末尾，j指向旧长度的末尾。

从前向后填充就是O(n^2)的算法了，因为每次添加元素都要将添加元素之后的所有元素向后移动。

**其实很多数组填充类的问题，都可以先预先给数组扩容带填充后的大小，然后在从后向前进行操作。**

这么做有两个好处：

1. 不用申请新数组。
2. 从后向前填充元素，避免了从前向后填充元素时，每次添加元素都要将添加元素之后的所有元素向后移动的问题。

```cpp
class Solution {
public:
    string replaceSpace(string s) {
        int cnt = 0;
        int oldSize = s.size();
        for(int i = 0; i < s.size(); i++) 
            if(s[i] == ' ') cnt++;
        s.resize(s.size() + cnt * 2);
        int newSize = s.size();
        for(int i = newSize - 1, j = oldSize - 1; j >= 0;i--,j--) {
            if(s[j] != ' ') s[i] = s[j];
            else {
                s[i] = '0';
                s[i - 1] = '2';
                s[i - 2] = '%';
                i -= 2;
            }
        }
        return s;
    }
};
```

### 反转字符串中的单词

#### 相关链接

+ [151. 反转字符串中的单词 ](https://leetcode.cn/problems/reverse-words-in-a-string/description/)

#### 相关题目

给你一个字符串 `s` ，请你反转字符串中 **单词** 的顺序。

**单词** 是由非空格字符组成的字符串。`s` 中使用至少一个空格将字符串中的 **单词** 分隔开。

返回 **单词** 顺序颠倒且 **单词** 之间用单个空格连接的结果字符串。

**注意：**输入字符串 `s`中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。

**示例 1：**

```
输入：s = "  hello world  "
输出："world hello"
解释：反转后的字符串中不能存在前导空格和尾随空格。
```

#### 解题思路

**不使用辅助空间，空间复杂度要求为O(1)。**

+ 移除多余空格
+ 将整个字符串反转
+ 将每个单词反转

举个例子，源字符串为："the sky is blue "

+ 移除多余空格 : "the sky is blue"
+ 字符串反转："eulb si yks eht"
+ 单词反转："blue is sky the"

移除多余空格 erase是O(n),erase操作上面还套了一个for循环，移除冗余空格的代码时间复杂度为O(n^2)。

使用之前快慢指针-移除元素的模板 [27. 移除元素](https://leetcode.cn/problems/remove-element/)

接下来就是将整个字符串反转，遇到空格或是末尾将每个单词反转

完整代码如下：

```cpp
class Solution {
public:
    string reverseWords(string s) {
        //快慢指针-移除元素的模板
        int slowIndex = 0;
        for(int fastIndex = 0; fastIndex < s.size(); fastIndex++) {
            if(s[fastIndex] != ' ') {
                if(slowIndex != 0) s[slowIndex++] = ' ';
                while(fastIndex < s.size() && s[fastIndex] != ' ')
                    s[slowIndex++] = s[fastIndex++];
            }
        }
        s.resize(slowIndex);
        reverse(s.begin(), s.end());
        int start = 0;
        for(int i = 0; i <= s.size(); i++){
            if(s[i] == ' ' || i == s.size()){
                reverse(s.begin() + start, s.begin() + i);
                start = i + 1;
            }
        }
        return s;
    }
};
```

### 左旋转字符串

#### 相关链接

+ [剑指 Offer 58 - II. 左旋转字符串](https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/)

#### 相关题目

字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串"abcdefg"和数字2，该函数将返回左旋转两位得到的结果"cdefgab"。

**示例 1：**

```
输入: s = "abcdefg", k = 2
输出: "cdefgab"
```

#### 解题思路

**不能申请额外空间，只能在本串上操作**。

可以通过局部反转+整体反转 达到左旋转的目的。

具体步骤为：

1. 反转区间为前n的子串
2. 反转区间为n到末尾的子串
3. 反转整个字符串

完整代码如下：

```cpp
class Solution {
public:
    string reverseLeftWords(string s, int n) {
        reverse(s.begin(), s.begin() + n);
        reverse(s.begin() + n, s.end());
        reverse(s.begin(), s.end());
        return s;
    }
};
```

需要注意的是：不同编程语言底层的字符串实现原理（可变/不可变），使用substr 和 反转 时间复杂度是一样的 ，都是O(n)，但是使用substr申请了额外空间，所以空间复杂度是O(n)，而反转方法的空间复杂度是O(1)。

```java
class Solution {
public:
    string reverseLeftWords(string s, int n) {
        return s.substr(n) + s.substr(0, n);
    }
};
```

### 找出字符串首个匹配项的下标

#### 相关链接

+ [28. 找出字符串中第一个匹配项的下标 ](https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/)

#### 相关题目

给你两个字符串 `haystack` 和 `needle` ，请你在 `haystack` 字符串中找出 `needle` 字符串的第一个匹配项的下标（下标从 0 开始）。如果 `needle` 不是 `haystack` 的一部分，则返回 `-1` 。

**示例 1：**

```
输入：haystack = "sadbutsad", needle = "sad"
输出：0
解释："sad" 在下标 0 和 6 处匹配。
第一个匹配项的下标是 0 ，所以返回 0 。
```

#### 解题思路

忘记了 KMP 先看这两个视频

> [代码随想录   帮你把KMP算法学个通透！（理论篇）_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1PD4y1o7nd/?vd_source=178669e0797f36fb015c5fc3cb9c7a4f)
>
> [代码随想录   帮你把KMP算法学个通透！（求next数组代码篇）_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1M5411j7Xx/)

KMP 的next数组有多种实现，其实是对应的遇到冲突解决方法不一致

+ next数组 是前缀表原封不动 ，要找遇到冲突的前 1 位
+ **next数组 是前缀表的整体减 1，要找遇到冲突的前 1 位，并 + 1，这种情况最常见！！！**
+ next数组 是前缀表后移 1 位，开头赋值为 -1，要找遇到冲突那位对应的下标

**伪代码实现**

i 表示后缀末尾，j 表示前缀末尾，并且表示 i 之前的子串的最长相等前后缀长度，按以下四部走：

（1）初始化

（2）前后缀不相同

（3）前后缀相同

（4）更新next数组

前缀表统一减 1 来构建next数组，（优先记忆这个）代码如下：

```cpp
void getNext(int* next, const string& s){
    int j = -1;
    next[0] = j;
    for(int i = 1; i < s.size(); i++) { // 注意i从1开始
        while (j >= 0 && s[i] != s[j + 1]) { // 前后缀不相同了
            j = next[j]; // 向前回退
        }
        if (s[i] == s[j + 1]) { // 找到相同的前后缀
            j++;
        }
        next[i] = j; // 将j（前缀的长度）赋给next[i]
    }
}
```

前缀表统一减 1 来构建next数组，完整代码如下：

```cpp
class Solution {
public:
    void getNext(int* next, const string& s) {
        int j = -1;
        next[0] = j;
        for(int i = 1; i < s.size(); i++) { // 注意i从1开始
            while (j >= 0 && s[i] != s[j + 1]) { // 前后缀不相同了
                j = next[j]; // 向前回退
            }
            if (s[i] == s[j + 1]) { // 找到相同的前后缀
                j++;
            }
            next[i] = j; // 将j（前缀的长度）赋给next[i]
        }
    }
    int strStr(string haystack, string needle) {
        if (needle.size() == 0) {
            return 0;
        }
        int next[needle.size()];
        getNext(next, needle);
        int j = -1; // // 因为next数组里记录的起始位置为-1
        for (int i = 0; i < haystack.size(); i++) { // 注意i就从0开始
            while(j >= 0 && haystack[i] != needle[j + 1]) { // 不匹配
                j = next[j]; // j 寻找之前匹配的位置
            }
            if (haystack[i] == needle[j + 1]) { // 匹配，j和i同时向后移动
                j++; // i的增加在for循环里
            }
            if (j == (needle.size() - 1) ) { // 文本串s里出现了模式串t
                return (i - needle.size() + 1);
            }
        }
        return -1;
    }
};
```

前缀表不减 1 来构建next数组，代码如下：

```cpp
void getNext(int* next, const string& s) {
    int j = 0;
    next[0] = 0;
    for(int i = 1; i < s.size(); i++) {
        while (j > 0 && s[i] != s[j]) { // j要保证大于0，因为下面有取j-1作为数组下标的操作
            j = next[j - 1]; // 注意这里，是要找前一位的对应的回退位置了
        }
        if (s[i] == s[j]) {
            j++;
        }
        next[i] = j;
    }
}
```

前缀表不减 1 来构建next数组，完整代码如下：

```cpp
class Solution {
public:
    void getNext(int* next, const string& s) {
        int j = 0;
        next[0] = 0;
        for(int i = 1; i < s.size(); i++) {
            while (j > 0 && s[i] != s[j]) {
                j = next[j - 1];
            }
            if (s[i] == s[j]) {
                j++;
            }
            next[i] = j;
        }
    }
    int strStr(string haystack, string needle) {
        if (needle.size() == 0) {
            return 0;
        }
        int next[needle.size()];
        getNext(next, needle);
        int j = 0;
        for (int i = 0; i < haystack.size(); i++) {
            while(j > 0 && haystack[i] != needle[j]) {
                j = next[j - 1];
            }
            if (haystack[i] == needle[j]) {
                j++;
            }
            if (j == needle.size() ) {
                return (i - needle.size() + 1);
            }
        }
        return -1;
    }
};
```

Y总的模板

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=10010,M=100010;
int n,m;
char p[N],s[N];
int next[N];
int main() 
{	
	cin>>m>>p+1>>n>>s+1;
	// s[]是长文本，n是s的长度，p[]是模式串，m是p的长度
	//求模式串的Next数组：
	for (int i = 2, j = 0; i <= m; i ++ ) {
	    while (j && p[i] != p[j + 1]) j = next[j];
	    if (p[i] == p[j + 1]) j ++ ;
	    next[i] = j;
	}
	
	// kmp匹配
	for (int i = 1, j = 0; i <= n; i ++ ) {
	    while (j && s[i] != p[j + 1]) j = next[j];
	    if (s[i] == p[j + 1]) j ++ ;
	    if (j == m) {// 匹配成功后的逻辑
			cout<< i - m <<" ";
	        j = next[j];
	    }
	}
	return 0;
}
```

**总结 自己最后的写法**

```cpp
class Solution {
public:
    //KMP算法
    int strStr(string s, string p) {
        if(p.size() == 0) return 0;
        int next[p.size()];
        int j = -1;
        next[0] = -1;
        for(int i = 1; i < p.size(); i++){
            while(j >= 0 && p[i] != p[j + 1]) j = next[j];
            if(p[i] == p[j + 1]) j++;
            next[i] = j; 
        }
        j = -1;
        for(int i = 0; i < s.size(); i++){
            while(j >= 0 && s[i] != p[j + 1]) j = next[j];
            if(s[i] == p[j + 1]) j++;
            if(j == (p.size() - 1)) return (i - p.size() + 1);
        }        
        return -1;
    }
};
```

### 重复的子字符串

#### 相关链接

+ [459. 重复的子字符串](https://leetcode.cn/problems/repeated-substring-pattern/)

#### 相关题目

给你两个字符串 `haystack` 和 `needle` ，请你在 `haystack` 字符串中找出 `needle` 字符串的第一个匹配项的下标（下标从 0 开始）。如果 `needle` 不是 `haystack` 的一部分，则返回 `-1` 。

**示例 1：**

```
输入：haystack = "sadbutsad", needle = "sad"
输出：0
解释："sad" 在下标 0 和 6 处匹配。
第一个匹配项的下标是 0 ，所以返回 0 。
```

#### 解题思路

**写法1-移动匹配**

前面有相同的子串，后面有相同的子串，用 s + s，只要两个s拼接在一起，里面还出现一个s的话，就说明是由重复子串组成。

当然，我们在判断 s + s 拼接的字符串里是否出现一个s的的时候，**要刨除 s + s 的首字符和尾字符**，这样避免在s+s中搜索出原来的s，我们要搜索的是中间拼接出来的s。

```cpp
class Solution {
public:
    bool repeatedSubstringPattern(string s) {
        string t = s + s;
        t.erase(t.begin()); t.erase(t.end() - 1);
        if(t.find(s) != -1) return true;
        return false;
    }
};
```

**写法2-KMP算法**

> [代码随想录 | LeetCode：459.重复的子字符串_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1cg41127fw/?vd_source=178669e0797f36fb015c5fc3cb9c7a4f)

最长相等前后缀不包含的子串就是最小重复子串

例子：abababab，前缀是前6个字符ababab，后缀是后6个字符ababab，之间没有重叠的部分就是最小重复子串

如果整个字符串长度能 整除 整个字符串长度-next数组最后的值 的话，说明这个字符串是重复子字符串

**以下next数组的求法 是前缀表的整体减 1，要找遇到冲突的前 1 位，并 + 1，这种情况**

```cpp
class Solution {
public:
    bool repeatedSubstringPattern(string s) {
        if(s.size() == 0) return false;
        int next[s.size()];
        int j = -1;
        next[0] = -1;
        for(int i = 1; i < s.size(); i++){
            while(j >= 0 && s[i] != s[j + 1]) j = next[j];
            if(s[i] == s[j + 1]) j++;
            next[i] = j;
        }
        if(next[s.size() - 1] != -1 && s.size() % (s.size() - (next[s.size()- 1] + 1)) == 0){
            return true;
        }
        return false;
    }
};
```

## 栈与队列

### 栈与队列的理论基础

1. C++中stack和queue是容器吗？

   C++的STL中栈和栈往往不被归类为容器，而被归类为container adapter（容器适配器）。

2. 我们使用的STL中stack和queue是如何实现的？

   **栈是以底层容器完成其所有的工作，对外提供统一的接口，底层容器是可插拔的（也就是说我们可以控制使用哪种容器来实现栈的功能）。**栈的内部结构，栈的底层实现可以是vector，deque，list 都是可以的， 主要就是数组和链表的底层实现。**我们常用的SGI STL，如果没有指定底层实现的话，栈和队列默认都是以deque为缺省情况下栈的底层结构。**

3. stack 和queue提供迭代器来遍历空间吗？

   栈提供push 和 pop 等等接口，所有元素必须符合先进后出规则，所以栈不提供走访功能，也不提供迭代器(iterator)。 不像是set 或者map 提供迭代器iterator来遍历所有元素。队列中先进先出的数据结构，同样不允许有遍历行为，不提供迭代器, 

### 用栈实现队列

#### 相关链接

+ [232. 用栈实现队列 ](https://leetcode.cn/problems/implement-queue-using-stacks/description/)

#### 相关题目

请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（`push`、`pop`、`peek`、`empty`）：

实现 `MyQueue` 类：

+ `void push(int x)` 将元素 x 推到队列的末尾
+ `int pop()` 从队列的开头移除并返回元素
+ `int peek()` 返回队列开头的元素
+ `boolean empty()` 如果队列为空，返回 `true` ；否则，返回 `false`

**说明：**

+ 你 **只能** 使用标准的栈操作 —— 也就是只有 `push to top`, `peek/pop from top`, `size`, 和 `is empty` 操作是合法的。
+ 你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。

#### 解题思路

自己的代码存在的问题

+ 不需要将输出栈的内容再输入到输入栈中

+ peek()其实可以复用pop()的代码

```cpp
class MyQueue {
public:
    stack<int> s1;
    stack<int> s2;
    MyQueue() {}
    
    void push(int x) {
        s1.push(x);
    }
    
    int pop() {
        while(!s1.empty()){
            s2.push(s1.top());
            s1.pop();
        }
        int res = s2.top();
        s2.pop();
        while(!s2.empty()){
            s1.push(s2.top());
            s2.pop();
        }
        return res;
    }
    
    int peek() {
        while(!s1.empty()){
            s2.push(s1.top());
            s1.pop();
        }
        int res = s2.top();
        while(!s2.empty()){
            s1.push(s2.top());
            s2.pop();
        }
        return res;
    }
    
    bool empty() {
        return s1.empty();
    }
};

```

代码随想录的代码

```cpp
class MyQueue {
public:
    stack<int> sIn;
    stack<int> sOut;
    MyQueue() {}
    
    void push(int x) {
        sIn.push(x);
    }
    
    int pop() {
        if(sOut.empty()){
            while(!sIn.empty()){
                sOut.push(sIn.top());
                sIn.pop();
            }
        }
        int res = sOut.top();
        sOut.pop();
        return res;
    }
    
    int peek() {
        int res = this->pop(); 
        sOut.push(res);
        return res;
    }
    
    bool empty() {
        return sIn.empty() && sOut.empty();
    }
};
```

### 用队列实现栈

#### 相关链接

+ [225. 用队列实现栈](https://leetcode.cn/problems/implement-stack-using-queues/)

#### 相关题目

请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（`push`、`top`、`pop` 和 `empty`）。

实现 `MyStack` 类：

+ `void push(int x)` 将元素 x 压入栈顶。
+ `int pop()` 移除并返回栈顶元素。
+ `int top()` 返回栈顶元素。
+ `boolean empty()` 如果栈是空的，返回 `true` ；否则，返回 `false` 。

#### 解题思路

两个队列，一个队列负责输入输出，另一个队列只负责暂存

```cpp
class MyStack {
public:
    queue<int> que1;
    queue<int> que2;
    MyStack() {}
    
    void push(int x) {
        que1.push(x);
    }

    int pop() {
        int size = que1.size();
        while(size > 1){
            que2.push(que1.front());
            que1.pop();
            size--;
        }
        int res = que1.front();
        que1.pop();
        while(!que2.empty()){
            que1.push(que2.front());
            que2.pop();
        }
        return res;
    }
    int pop() {
        int size = que.size();
        size--;
        while (size--) { // 将队列头部的元素（除了最后一个元素外） 重新添加到队列尾部
            que.push(que.front());
            que.pop();
        }
        int result = que.front(); // 此时弹出的元素顺序就是栈的顺序了
        que.pop();
        return result;
    }
    //只用一个队列优化，只需要将元素重新添加到队列尾部
    // int pop() {
    //     int size = que.size();
    //     size--;
    //     while (size--) { // 将队列头部的元素（除了最后一个元素外） 重新添加到队列尾部
    //         que.push(que.front());
    //         que.pop();
    //     }
    //     int result = que.front(); // 此时弹出的元素顺序就是栈的顺序了
    //     que.pop();
    //     return result;
    // }    
    int top() {
        return que1.back();
    }
    
    bool empty() {
        return que1.empty();
    }
};
```

### 滑动窗口的平均值

#### 相关链接

+ [剑指 Offer II 041. 滑动窗口的平均值](https://leetcode.cn/problems/qIsx9U/description/)

#### 相关题目

给定一个整数数据流和一个窗口大小，根据该滑动窗口的大小，计算滑动窗口里所有数字的平均值。

实现 `MovingAverage` 类：

+ `MovingAverage(int size)` 用窗口大小 `size` 初始化对象。
+ `double next(int val)` 成员函数 `next` 每次调用的时候都会往滑动窗口增加一个整数，请计算并返回数据流中最后 `size` 个值的移动平均值，即滑动窗口里所有数字的平均值。

#### 解题思路

```cpp
class MovingAverage {
public:
    int cnt = 0, sum = 0;
    queue<int> q;
    MovingAverage(int size) { cnt = size; }
    
    double next(int val) {
        sum += val;
        q.push(val);
        if(q.size() > cnt) {
            sum -= q.front();
            q.pop();
        }
        return (double)sum / q.size();
    }
};
```



### 有效的括号

#### 相关链接

+ [20. 有效的括号](https://leetcode.cn/problems/valid-parentheses/description/)
+ [921. 使括号有效的最少添加 ](https://leetcode.cn/problems/minimum-add-to-make-parentheses-valid/)
+ [1541. 平衡括号字符串的最少插入次数 ](https://leetcode.cn/problems/minimum-insertions-to-balance-a-parentheses-string/description/)
+ [剑指 Offer II 085. 生成匹配的括号---需要用递归解决](https://leetcode.cn/problems/IDBivT/description/)

#### 相关题目

给定一个只包括 `'('`，`')'`，`'{'`，`'}'`，`'['`，`']'` 的字符串 `s` ，判断字符串是否有效。

有效字符串需满足：

1. 左括号必须用相同类型的右括号闭合。
2. 左括号必须以正确的顺序闭合。
3. 每个右括号都有一个对应的相同类型的左括号。

**示例 1：**

```
输入：s = "()"
输出：true
```

#### 解题思路

+ 第一种情况，字符串里左方向的括号多余了 。( [ { } ] ( )
+ 第二种情况，括号没有多余，但是 括号的类型没有匹配上。 
+ 第三种情况，字符串里右方向的括号多余了。( [ { } ] ) )

代码随想录--栈里放入右括号

```cpp
class Solution {
public:
    bool isValid(string s) {
        if (s.size() % 2 != 0) return false; // 如果s的长度为奇数，一定不符合要求
        stack<char> st;
        for (int i = 0; i < s.size(); i++) {
            if (s[i] == '(') st.push(')');
            else if (s[i] == '{') st.push('}');
            else if (s[i] == '[') st.push(']');
            // 第三种情况：说明右括号没有找到对应的左括号 
            // 第二种情况：栈里没有我们要匹配的字符。
            else if (st.empty() || st.top() != s[i]) return false;
            else st.pop(); // st.top() 与 s[i]相等，栈弹出元素
        }
        // 第一种情况：此时我们已经遍历完了字符串，但是栈不为空，说明有相应的左括号没有右括号来匹配
        return st.empty();
    }
};
```

### 删除字符串所有相邻重复项

#### 相关链接

+ [1047. 删除字符串中的所有相邻重复项 ](https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/description/)

#### 相关题目

给出由小写字母组成的字符串 `S`，**重复项删除操作**会选择两个相邻且相同的字母，并删除它们。

在 S 上反复执行重复项删除操作，直到无法继续删除。

在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。

**示例：**

```
输入："abbaca"
输出："ca"
解释：
例如，在 "abbaca" 中，我们可以删除 "bb" 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 "aaca"，其中又只有 "aa" 可以执行重复项删除操作，所以最后的字符串为 "ca"。
```

#### 解题思路

只需要注意只用字符串就行，不必非得用栈

```cpp
class Solution {
public:
    string removeDuplicates(string s) {
        string res;
        for(char c : s){
            if(res.empty() || res.back() != c) res.push_back(c);
            else res.pop_back();
        }
        return res;
    }
};
```

### 逆波兰表达式求值

#### 相关链接

+ [150. 逆波兰表达式求值 ](https://leetcode.cn/problems/evaluate-reverse-polish-notation/description/)

#### 相关题目

给你一个字符串数组 `tokens` ，表示一个根据 逆波兰表示法表示的算术表达式。

请你计算该表达式。返回一个表示表达式值的整数。

**注意：**

+ 有效的算符为 `'+'`、`'-'`、`'*'` 和 `'/'` 。
+ 每个操作数（运算对象）都可以是一个整数或者另一个表达式。
+ 两个整数之间的除法总是 **向零截断** 。
+ 表达式中不含除零运算。
+ 输入是一个根据逆波兰表示法表示的算术表达式。
+ 答案及所有中间计算结果可以用 **32 位** 整数表示。

**示例 1：**

```
输入：tokens = ["2","1","+","3","*"]
输出：9
解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9
```

#### 解题思路

逆波兰表达式主要有以下两个优点：

+ 去掉括号后表达式无歧义，上式即便写成 1 2 + 3 4 + * 也可以依据次序计算出正确结果。
+ 适合用栈操作运算：遇到数字则入栈；遇到运算符则取出栈顶两个数字进行计算，并将结果压入栈中。

C++ 中stoll 函数将在函数调用中作为参数提供的字符串转换为long long。

```cpp
class Solution {
public:
    int evalRPN(vector<string>& tokens) {
        stack<long long> st;
        for(int i = 0; i < tokens.size(); i++){
            if(tokens[i] == "+" || tokens[i] == "-" || tokens[i] == "*" || tokens[i] == "/"){
                long long t1 = st.top();
                st.pop();
                long long t2 = st.top();
                st.pop();
                if (tokens[i] == "+") st.push(t2 + t1);
                if (tokens[i] == "-") st.push(t2 - t1);
                if (tokens[i] == "*") st.push(t2 * t1);
                if (tokens[i] == "/") st.push(t2 / t1);
            } else st.push(stoll(tokens[i]));
        }
        return st.top();
    }
};
```

## 哈希表

哈希表能解决什么问题呢，**一般哈希表都是用来快速判断一个元素是否出现集合里。**

当我们需要查询一个元素是否出现过，或者一个元素是否在集合里的时候，就要第一时间想到哈希法。

**Y总的模板-开放定址法**

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 200003, null = 0x3f3f3f3f;
int h[N];
int find(int x) {
	int k = (x % N + N) % N;
	while(h[k] != null && h[k] != x) {
		k++;
		if(k == N) k = 0;	
	}
	return k; 
}
int main(){
	int n;
    cin>>n;
	memset(h, 0x3f, sizeof h);
	while(n--) {
		char op[2];
		int x;
		scanf("%s%d", op, &x);
		int k = find(x);
		if(*op == 'I') h[k] = x;
		else {
			if(h[k] != null) puts("Yes");
			else puts("No");
		} 
	}
	return 0;
}
```

**Y总的模板-拉链法**

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 100003;
int h[N], e[N], ne[N], idx;
void insert(int x){
	int k = (x % N + N) % N;
	e[idx] = x;
	ne[idx] = h[k];
	h[k] = idx++;
}
bool find(int x){
	int k = ( x % N + N ) % N;
	for(int i = h[k]; i != -1; i = ne[i]){
		if(e[i] == k) return true;
	}
	return false;
}
int main(){
	int n;
    cin>>n;
	memset(h, -1, sizeof h);
	while(n--){
		char op[2];
		int x;
		scanf("%s%d", op, &x);
		if(*op == 'I') insert(x);
		else{
			if( find(x) ) puts("Yes");
			else puts("No");
		} 
	}
	return 0;
}
```

### 有效的字母异位词 

#### 相关链接

+ [242. 有效的字母异位词 ](https://leetcode.cn/problems/valid-anagram/)

#### 相关题目

给定两个字符串 `s` 和 `t` ，编写一个函数来判断 `t` 是否是 `s` 的字母异位词。

**注意：**若 `s` 和 `t` 中每个字符出现的次数都相同，则称 `s` 和 `t` 互为字母异位词。

**示例 1:**

```
输入: s = "anagram", t = "nagaram"
输出: true
```

#### 解题思路

**数组其实就是一个简单哈希表**，而且这道题目中字符串只有小写字符，那么就可以定义一个数组，来记录字符串s里字符出现的次数。

```cpp
class Solution {
public:
    bool isAnagram(string s, string t) {
        int record[26] = {0};
        for(int i = 0; i < s.size(); i++) record[s[i] - 'a']++;
        for(int i = 0; i < t.size(); i++) record[t[i] - 'a']--;
        for(int i = 0; i < 26; i++) if(record[i] != 0) return false;
        return true;        
    }
};
```

### 赎金信

#### 相关链接

+ [383. 赎金信 ](https://leetcode.cn/problems/ransom-note/)

#### 相关题目

给你两个字符串：`ransomNote` 和 `magazine` ，判断 `ransomNote` 能不能由 `magazine` 里面的字符构成。

如果可以，返回 `true` ；否则返回 `false` 。

`magazine` 中的每个字符只能在 `ransomNote` 中使用一次。

**示例 1：**

```
输入：ransomNote = "a", magazine = "b"
输出：false
```

#### 解题思路

因为题目所只有小写字母，那可以采用空间换取时间的哈希策略， 用一个长度为26的数组还记录magazine里字母出现的次数。

然后再用ransomNote去验证这个数组是否包含了ransomNote所需要的所有字母。

依然是数组在哈希法中的应用。

```cpp
class Solution {
public:
    bool canConstruct(string ransomNote, string magazine) {
        if(ransomNote.size() > magazine.size()) return false;
        int record[26] = {0};
        for(int i = 0; i < magazine.size(); i++) record[magazine[i] - 'a']++;
        for(int i = 0; i < ransomNote.size(); i++) {
            record[ransomNote[i] -'a']--;
            if(record[ransomNote[i] -'a'] < 0) return false;
        }
        return true;
    }
};
```

### 两个数组的交集

#### 相关链接

+ [349. 两个数组的交集 ](https://leetcode.cn/problems/intersection-of-two-arrays/)

#### 相关题目

给定两个数组 `nums1` 和 `nums2` ，返回 *它们的交集* 。输出结果中的每个元素一定是 **唯一** 的。我们可以 **不考虑输出结果的顺序** 。

**示例 1：**

```
输入：nums1 = [1,2,2,1], nums2 = [2,2]
输出：[2]
```

#### 解题思路

std::set和std::multiset底层实现都是红黑树，std::unordered_set的底层实现是哈希表， 使用unordered_set 读写效率是最高的，并不需要对数据进行排序，而且还不要让数据重复，所以选择unordered_set。

```cpp
class Solution {
public:
    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
        unordered_set<int> res_set;
        unordered_set<int> num1_set(nums1.begin(), nums1.end());
        for(int i = 0; i < nums2.size(); i++) {
            if(num1_set.find(nums2[i]) != num1_set.end()) res_set.insert(nums2[i]);
        }
        return vector<int>(res_set.begin(), res_set.end());
    }
};
```

### 快乐数

#### 相关链接

+ [202. 快乐数](https://leetcode.cn/problems/happy-number/)

#### 相关题目

编写一个算法来判断一个数 `n` 是不是快乐数。

**「快乐数」** 定义为：

+ 对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。
+ 然后重复这个过程直到这个数变为 1，也可能是 **无限循环** 但始终变不到 1。
+ 如果这个过程 **结果为** 1，那么这个数就是快乐数。

如果 `n` 是 *快乐数* 就返回 `true` ；不是，则返回 `false` 。

**示例 1：**

```
输入：n = 19
输出：true
解释：
12 + 92 = 82
82 + 22 = 68
62 + 82 = 100
12 + 02 + 02 = 1
```

#### 解题思路

```cpp
class Solution {
public:
    int getSum(int n){
        int sum = 0;
        while(n){
            sum += (n % 10) * (n % 10);
            n /= 10;
        }
        return sum;
    }
    bool isHappy(int n) {
        unordered_set<int> set;
        while(1){
            int sum = getSum(n);
            if(sum == 1) return true;
            if(set.find(sum) != set.end()) return false;
            else set.insert(sum);
            n = sum;
        }
    }
};
```

### 两数之和

#### 相关链接

+ [1. 两数之和](https://leetcode.cn/problems/two-sum/description/)

#### 相关题目

给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出 **和为目标值** *`target`* 的那 **两个** 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。

你可以按任意顺序返回答案。

**示例 1：**

```
输入：nums = [2,7,11,15], target = 9
输出：[0,1]
解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。
```

#### 解题思路

使用数组和set来做哈希法的局限。

+ 数组的大小是受限制的，而且如果元素很少，而哈希值太大会造成内存空间的浪费。
+ set是一个集合，里面放的元素只能是一个key，而两数之和这道题目，不仅要判断y是否存在而且还要记录y的下标位置，因为要返回x 和 y的下标。所以set 也不能用。

此时就要选择另一种数据结构：map ，map是一种key value的存储结构，可以用key保存数值，用value在保存数值所在的下标。

C++中map，有三种类型：

| 映射               | 底层实现 | 是否有序 | 数值是否可以重复 | 能否更改数值 | 查询效率 | 增删效率 |
| ------------------ | -------- | -------- | ---------------- | ------------ | -------- | -------- |
| std::map           | 红黑树   | key有序  | key不可重复      | key不可修改  | O(log n) | O(log n) |
| std::multimap      | 红黑树   | key有序  | key可重复        | key不可修改  | O(log n) | O(log n) |
| std::unordered_map | 哈希表   | key无序  | key不可重复      | key不可修改  | O(1)     | O(1)     |

std::unordered_map 底层实现为哈希表，std::map 和std::multimap 的底层实现是红黑树。

**这道题目中并不需要key有序，选择std::unordered_map 效率更高！**

```cpp
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int,int> hash;
        for(int i = 0; i < nums.size(); i++) hash[nums[i]] = i;
        for(int i = 0; i < nums.size(); i++)
            if(hash.find(target - nums[i]) != hash.end() && hash[target - nums[i]] != i)
                return {i, hash[target - nums[i]]};
        return {};
    }
};
```

**需要注意的是：**两数之和 不能使用双指针法，因为要求返回的是索引下标， 而双指针法一定要排序，一旦排序之后原数组的索引就被改变了。如果要求返回的是数值的话，就可以使用双指针法了。

### 四数相加 II

#### 相关链接

+ [454. 四数相加 II ](https://leetcode.cn/problems/4sum-ii/)

#### 相关题目

给你四个整数数组 `nums1`、`nums2`、`nums3` 和 `nums4` ，数组长度都是 `n` ，请你计算有多少个元组 `(i, j, k, l)` 能满足：

+ `0 <= i, j, k, l < n`
+ `nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0`

**示例 1：**

```
输入：nums1 = [1,2], nums2 = [-2,-1], nums3 = [-1,2], nums4 = [0,2]
输出：2
解释：
两个元组如下：
1. (0, 0, 0, 1) -> nums1[0] + nums2[0] + nums3[0] + nums4[1] = 1 + (-2) + (-1) + 2 = 0
2. (1, 1, 0, 0) -> nums1[1] + nums2[1] + nums3[0] + nums4[0] = 2 + (-1) + (-1) + 0 = 0
```

#### 解题思路

本题解题步骤：

1. 首先定义 一个unordered_map，key放a和b两数之和，value 放a和b两数之和出现的次数。
2. 遍历大A和大B数组，统计两个数组元素之和，和出现的次数，放到map中。
3. 定义int变量count，用来统计 a+b+c+d = 0 出现的次数。
4. 在遍历大C和大D数组，找到如果 0-(c+d) 在map中出现过的话，就用count把map中key对应的value也就是出现次数统计出来。
5. 最后返回统计值 count 就可以了

```cpp
class Solution {
public:
    int fourSumCount(vector<int>& A, vector<int>& B, vector<int>& C, vector<int>& D) {
        unordered_map<int, int> umap;
        for(int a : A)
            for(int b : B)
                umap[a + b]++;
        int cnt = 0;
        for(int c : C)
            for(int d : D)
                if(umap.find(0 - (c + d)) != umap.end())
                    cnt += umap[0 - (c + d)];
        return cnt;
    }
};
```

## 堆

### 理论部分

对于大顶堆来说，所有父节点的值要大于其子节点的值，即大顶堆的第一个结点是最大值

对于小顶堆来说，所有父节点的值要小于其子节点的值，即小顶堆的第一个结点是最小值

而他们的兄弟节点之间并无任何大小上的关联。

二叉搜索树才是左孩子小于父亲，右孩子大于父亲

堆兄弟结点都除以2是同一个值

建堆要从1开始

堆的父节点索引==子结点索引/2

### 前 K 个高频元素

#### 相关链接

+ [347. 前 K 个高频元素 ](https://leetcode.cn/problems/top-k-frequent-elements/)
+ [692. 前K个高频单词 ](https://leetcode.cn/problems/top-k-frequent-words/)
+ [剑指 Offer II 059. 数据流的第 K 大数值](https://leetcode.cn/problems/jBjn9C/description/)
+ [剑指 Offer II 060. 出现频率最高的 k 个数字 ](https://leetcode.cn/problems/g5c51o/)

#### 相关题目

给你一个整数数组 `nums` 和一个整数 `k` ，请你返回其中出现频率前 `k` 高的元素。你可以按 **任意顺序** 返回答案。

**示例 1:**

```
输入: nums = [1,1,1,2,2,3], k = 2
输出: [1,2]
```

#### 解题思路

[347. 前 K 个高频元素 ](https://leetcode.cn/problems/top-k-frequent-elements/)

[剑指 Offer II 060. 出现频率最高的 k 个数字 ](https://leetcode.cn/problems/g5c51o/)

**写法1-使用快排**

```cpp
class Solution {
public:
    vector<int> topKFrequent(vector<int>& nums, int k) {
        if(nums.size() == 0) return {};
        
        vector<pair<int,int>> vc;
        vector<int> ans;
        unordered_map<int,int> mp;
        
        for(int i = 0; i < nums.size(); i++) mp[nums[i]]++;
        for(auto i : mp) vc.push_back({i.second,i.first});
        
        sort(vc.begin(), vc.end());
        for(int i = vc.size() - 1; i >= vc.size() - k && i >= 0; i--) ans.push_back(vc[i].second);

        return ans;
    }
};
```

**写法2-优先队列**

这道题目主要涉及到如下三块内容：

1. 要统计元素出现频率
2. 对频率排序
3. 找出前K个高频元素

三个步骤如下：

1、首先统计元素出现的频率，这一类的问题可以使用map来进行统计。

2、然后是对频率进行排序，这里我们可以使用一种 容器适配器就是**优先级队列即堆**。

**堆是一棵完全二叉树，树中每个结点的值都不小于（或不大于）其左右孩子的值。** 为什么不用快排呢， 使用快排要将map转换为vector的结构，然后对整个数组进行排序， 而这种场景下，我们其实只需要维护k个有序的序列就可以了，所以使用优先级队列是最优的。

3、找出前K个高频元素，如果定义一个大小为k的大顶堆，在每次移动更新大顶堆的时候，每次弹出都把最大的元素弹出去了，那么怎么保留下来前K个高频元素呢。而且使用大顶堆就要把所有元素都进行排序，那能不能只排序k个元素呢？

**所以我们要用小顶堆，因为要统计最大前k个元素，只有小顶堆每次将最小的元素弹出，最后小顶堆里积累的才是前k个最大元素。**

```cpp
// 时间复杂度：O(nlogk)
// 空间复杂度：O(n)
class Solution {
public:
    // 小顶堆
    class mycomparison {
    public:
        bool operator()(const pair<int, int>& lhs, const pair<int, int>& rhs) {
            return lhs.second > rhs.second;
        }
    };
    vector<int> topKFrequent(vector<int>& nums, int k) {
        // 要统计元素出现频率
        unordered_map<int, int> map; // map<nums[i],对应出现的次数>
        for (int i = 0; i < nums.size(); i++) {
            map[nums[i]]++;
        }

        // 对频率排序
        // 定义一个小顶堆，大小为k
        priority_queue<pair<int, int>, vector<pair<int, int>>, mycomparison> pri_que;

        // 用固定大小为k的小顶堆，扫所有频率的数值
        for (unordered_map<int, int>::iterator it = map.begin(); it != map.end(); it++) {
            pri_que.push(*it);
            if (pri_que.size() > k) { // 如果堆的大小大于了K，则队列弹出，保证堆的大小一直为k
                pri_que.pop();
            }
        }

        // 找出前K个高频元素，因为小顶堆先弹出的是最小的，所以倒序来输出到数组
        vector<int> result(k);
        for (int i = k - 1; i >= 0; i--) {
            result[i] = pri_que.top().first;
            pri_que.pop();
        }
        return result;

    }
};
```

[剑指 Offer II 059. 数据流的第 K 大数值](https://leetcode.cn/problems/jBjn9C/description/)

```cpp
class KthLargest {
public:
    priority_queue<int,vector<int>,greater<int>> q;
    int k;
    KthLargest(int k, vector<int>& nums) {
        this->k = k;
        for(auto &x : nums) add(x);
    }
    
    int add(int val) {
        q.push(val);
        if(q.size()>k) q.pop();
        return q.top();
    }
};
```

[692. 前K个高频单词 ](https://leetcode.cn/problems/top-k-frequent-words/)

```cpp
class Solution {
public:
    class mycomparison {
    public:
        bool operator()(const pair<string, int>&lhs, const pair<string, int>& rhs) {
            if(lhs.second == rhs.second) return lhs.first < rhs.first;
            return lhs.second > rhs.second;
        }
    };
    vector<string> topKFrequent(vector<string>& nums, int k) {
        unordered_map<string, int> mp;
        for(int i = 0; i < nums.size(); i++) mp[nums[i]]++;
        
        priority_queue<pair<string, int>,vector<pair<string, int>>, mycomparison> pri_que;
        
        for(unordered_map<string, int> :: iterator it = mp.begin(); it != mp.end(); it++){
            pri_que.push(*it);
            if(pri_que.size() > k) pri_que.pop();
        }

        vector<string> res(k);
        for(int i = k - 1; i >= 0; i--) {
            res[i] = pri_que.top().first;
            pri_que.pop();
        }
        return res;
    }
};
```

## 单调队列

### 滑动窗口最大值

#### 相关链接

+ [239. 滑动窗口最大值](https://leetcode.cn/problems/sliding-window-maximum/description/)

#### 相关题目

给你一个整数数组 `nums`，有一个大小为 `k` 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 `k` 个数字。滑动窗口每次只向右移动一位。

返回 *滑动窗口中的最大值* 。

**示例 1：**

```
输入：nums = [1,3,-1,-3,5,3,6,7], k = 3
输出：[3,3,5,5,6,7]
解释：
滑动窗口的位置                最大值
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7
```

#### 解题思路

设计单调队列的时候，pop，和push操作要保持如下规则：

1. pop(value)：如果窗口移除的元素value等于单调队列的出口元素，那么队列弹出元素，否则不用任何操作
2. push(value)：如果push的元素value大于入口元素的数值，那么就将队列入口的元素弹出，直到push元素的数值小于等于队列入口元素的数值为止

保持如上规则，每次窗口移动的时候，只要que.front()就可以返回当前窗口的最大值。

```cpp
class Solution {
private:
    class MyQueue { //单调队列（从大到小）
    public:
        deque<int> que; // 使用deque来实现单调队列
        // 每次弹出的时候，比较当前要弹出的数值是否等于队列出口元素的数值，如果相等则弹出。
        // 同时pop之前判断队列当前是否为空。
        void pop(int value) {
            if (!que.empty() && value == que.front()) {
                que.pop_front();
            }
        }
        // 如果push的数值大于入口元素的数值，那么就将队列后端的数值弹出，直到push的数值小于等于队列入口元素的数值为止。
        // 这样就保持了队列里的数值是单调从大到小的了。
        void push(int value) {
            while (!que.empty() && value > que.back()) {
                que.pop_back();
            }
            que.push_back(value);

        }
        // 查询当前队列里的最大值 直接返回队列前端也就是front就可以了。
        int front() {
            return que.front();
        }
    };
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        MyQueue que;
        vector<int> result;
        for (int i = 0; i < k; i++) { // 先将前k的元素放进队列
            que.push(nums[i]);
        }
        result.push_back(que.front()); // result 记录前k的元素的最大值
        for (int i = k; i < nums.size(); i++) {
            que.pop(nums[i - k]); // 滑动窗口移除最前面元素
            que.push(nums[i]); // 滑动窗口前加入最后面的元素
            result.push_back(que.front()); // 记录对应的最大值
        }
        return result;
    }
};
```

## 单调栈

### 每日温度

#### 相关链接

+ [739. 每日温度 ](https://leetcode.cn/problems/daily-temperatures/)

#### 相关题目

给定一个整数数组 `temperatures` ，表示每天的温度，返回一个数组 `answer` ，其中 `answer[i]` 是指对于第 `i` 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 `0` 来代替。

**示例 1:**

```
输入: temperatures = [73,74,75,71,69,72,76,73]
输出: [1,1,4,2,1,1,0,0]
```

#### 解题思路

​	首先想到的当然是暴力解法，两层for循环，把至少需要等待的天数就搜出来了。时间复杂度是O(n^2)，那么接下来在来看看使用单调栈的解法。**通常是一维数组，要寻找任一个元素的右边或者左边第一个比自己大或者小的元素的位置，此时我们就要想到可以用单调栈了**，时间复杂度为O(n)。

​	单调栈的本质是空间换时间，因为在遍历的过程中需要用一个栈来记录右边第一个比当前元素高的元素，优点是只需要遍历一次。在使用单调栈的时候首先要明确如下几点：

1. 单调栈里存放的元素是什么？

单调栈里只需要存放元素的下标i就可以了，如果需要使用对应的元素，直接T[i]就可以获取。

2. 单调栈里元素是递增的**注意一下顺序为 从栈头到栈底的顺序**。

```cpp
class Solution {
public:
    vector<int> dailyTemperatures(vector<int>& T) {
        // 递增栈
        stack<int> st;
        vector<int> result(T.size(), 0);
        st.push(0);
        for (int i = 1; i < T.size(); i++) {
            if (T[i] < T[st.top()]) {                       // 情况一
                st.push(i);
            } else if (T[i] == T[st.top()]) {               // 情况二
                st.push(i);
            } else {
                while (!st.empty() && T[i] > T[st.top()]) { // 情况三
                    result[st.top()] = i - st.top();
                    st.pop();
                }
                st.push(i);
            }
        }
        return result;
    }
};
```

### 下一个更大元素 I

#### 相关链接

+ [496. 下一个更大元素 I](https://leetcode.cn/problems/next-greater-element-i/)

#### 相关题目

`nums1` 中数字 `x` 的 **下一个更大元素** 是指 `x` 在 `nums2` 中对应位置 **右侧** 的 **第一个** 比 `x` 大的元素。

给你两个 **没有重复元素** 的数组 `nums1` 和 `nums2` ，下标从 **0** 开始计数，其中`nums1` 是 `nums2` 的子集。

对于每个 `0 <= i < nums1.length` ，找出满足 `nums1[i] == nums2[j]` 的下标 `j` ，并且在 `nums2` 确定 `nums2[j]` 的 **下一个更大元素** 。如果不存在下一个更大元素，那么本次查询的答案是 `-1` 。

返回一个长度为 `nums1.length` 的数组 `ans` 作为答案，满足 `ans[i]` 是如上所述的 **下一个更大元素** 。

**示例 1：**

```
输入：nums1 = [4,1,2], nums2 = [1,3,4,2].
输出：[-1,3,-1]
解释：nums1 中每个值的下一个更大元素如下所述：
- 4 ，用加粗斜体标识，nums2 = [1,3,4,2]。不存在下一个更大元素，所以答案是 -1 。
- 1 ，用加粗斜体标识，nums2 = [1,3,4,2]。下一个更大元素是 3 。
- 2 ，用加粗斜体标识，nums2 = [1,3,4,2]。不存在下一个更大元素，所以答案是 -1 。
```

#### 解题思路

本题和739. 每日温度是一样的。

栈头到栈底的顺序，要从小到大，也就是保持栈里的元素为递增顺序。只要保持递增，才能找到右边第一个比自己大的元素。

1. 情况一：当前遍历的元素T[i]小于栈顶元素T[st.top()]的情况

   此时满足递增栈（栈头到栈底的顺序），所以直接入栈。

2. 情况二：当前遍历的元素T[i]等于栈顶元素T[st.top()]的情况

   如果相等的话，依然直接入栈，因为我们要求的是右边第一个比自己大的元素，而不是大于等于！

3. 情况三：当前遍历的元素T[i]大于栈顶元素T[st.top()]的情况

   此时如果入栈就不满足递增栈了，这也是找到右边第一个比自己大的元素的时候。

   判断栈顶元素是否在nums1里出现过，（注意栈里的元素是nums2的元素），如果出现过，开始记录结果。

```cpp
class Solution {
public:
    vector<int> nextGreaterElement(vector<int>& nums1, vector<int>& nums2) {
        stack<int> st;
        vector<int> result(nums1.size(), -1);
        if (nums1.size() == 0) return result;

        unordered_map<int, int> umap; // key:下标元素，value：下标
        for (int i = 0; i < nums1.size(); i++) {
            umap[nums1[i]] = i;
        }
        st.push(0);
        for (int i = 1; i < nums2.size(); i++) {
            if (nums2[i] < nums2[st.top()]) {           // 情况一
                st.push(i);
            } else if (nums2[i] == nums2[st.top()]) {   // 情况二
                st.push(i);
            } else {                                    // 情况三
                while (!st.empty() && nums2[i] > nums2[st.top()]) {
                    if (umap.count(nums2[st.top()]) > 0) { // 看map里是否存在这个元素
                        int index = umap[nums2[st.top()]]; // 根据map找到nums2[st.top()] 在 nums1中的下标
                        result[index] = nums2[i];
                    }
                    st.pop();
                }
                st.push(i);
            }
        }
        return result;
    }
};
```

### 下一个更大元素 II

#### 相关链接

+ [503. 下一个更大元素 II ](https://leetcode.cn/problems/next-greater-element-ii/)

#### 相关题目

给定一个循环数组 `nums` （ `nums[nums.length - 1]` 的下一个元素是 `nums[0]` ），返回 *`nums` 中每个元素的 **下一个更大元素*** 。

数字 `x` 的 **下一个更大的元素** 是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 `-1` 。

**示例 1:**

```
输入: nums = [1,2,1]
输出: [2,-1,2]
解释: 第一个 1 的下一个更大的数是 2；
数字 2 找不到下一个更大的数； 
第二个 1 的下一个最大的数需要循环搜索，结果也是 2。
```

#### 解题思路

**写法1**

将两个nums数组拼接在一起，使用单调栈计算出每一个元素的下一个最大值，最后再把结果集即result数组resize到原数组大小就可以了。

```cpp
class Solution {
public:
    vector<int> nextGreaterElements(vector<int>& nums) {
        // 拼接一个新的nums
        vector<int> nums1(nums.begin(), nums.end());
        nums.insert(nums.end(), nums1.begin(), nums1.end());
        // 用新的nums大小来初始化result
        vector<int> result(nums.size(), -1);
        if (nums.size() == 0) return result;

        // 开始单调栈
        stack<int> st;
        for (int i = 0; i < nums.size(); i++) {
            while (!st.empty() && nums[i] > nums[st.top()]) {
                result[st.top()] = nums[i];
                st.pop();
            }
            st.push(i);
        }
        // 最后再把结果集即result数组resize到原数组大小
        result.resize(nums.size() / 2);
        return result;
    }
};
```

**写法2**

```cpp
class Solution {
public:
    vector<int> nextGreaterElements(vector<int>& nums) {
        vector<int> result(nums.size(), -1);
        if (nums.size() == 0) return result;
        stack<int> st;
        for (int i = 0; i < nums.size() * 2; i++) {
            // 模拟遍历两边nums，注意一下都是用i % nums.size()来操作
            while (!st.empty() && nums[i % nums.size()] > nums[st.top()]) {
                result[st.top()] = nums[i % nums.size()];
                st.pop();
            }
            st.push(i % nums.size());
        }
        return result;
    }
};
```

### 接雨水

#### 相关链接

+ [42. 接雨水](https://leetcode.cn/problems/trapping-rain-water/)

#### 相关题目

给定 `n` 个非负整数表示每个宽度为 `1` 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。

**示例 1：**

<img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png" style="zoom:80%;box-shadow:rgba(0,0,0,0) 0 0px 0px 0px;" />

```
输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]
输出：6
解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 
```

#### 解题思路

**写法1-双指针**

**如果按照列来计算的话，宽度一定是1了，我们再把每一列的雨水的高度求出来就可以了。**

可以看出每一列雨水的高度，取决于，该列 左侧最高的柱子和右侧最高的柱子中最矮的那个柱子的高度。

列4 左侧最高的柱子是列3，高度为2（以下用lHeight表示）。

列4 右侧最高的柱子是列7，高度为3（以下用rHeight表示）。

列4 柱子的高度为1（以下用height表示）

那么列4的雨水高度为 列3和列7的高度最小值减列4高度，即： min(lHeight, rHeight) - height。

列4的雨水高度求出来了，宽度为1，相乘就是列4的雨水体积了。

整体代码如下：

```cpp
class Solution {
public:
    int trap(vector<int>& height) {
        int sum = 0;
        for (int i = 0; i < height.size(); i++) {
            // 第一个柱子和最后一个柱子不接雨水
            if (i == 0 || i == height.size() - 1) continue;

            int rHeight = height[i]; // 记录右边柱子的最高高度
            int lHeight = height[i]; // 记录左边柱子的最高高度
            for (int r = i + 1; r < height.size(); r++) {
                if (height[r] > rHeight) rHeight = height[r];
            }
            for (int l = i - 1; l >= 0; l--) {
                if (height[l] > lHeight) lHeight = height[l];
            }
            int h = min(lHeight, rHeight) - height[i];
            if (h > 0) sum += h;
        }
        return sum;
    }
};
```

因为每次遍历列的时候，还要向两边寻找最高的列，所以时间复杂度为O(n^2)。 空间复杂度为O(1)，这种解法过不了全部用例。

**写法2-动态规划**

在上一节的双指针解法中，我们可以看到只要记录左边柱子的最高高度 和 右边柱子的最高高度，就可以计算当前位置的雨水面积，这就是通过列来计算。

当前列雨水面积：min(左边柱子的最高高度，记录右边柱子的最高高度) - 当前柱子高度。

为了得到两边的最高高度，使用了双指针来遍历，每到一个柱子都向两边遍历一遍，这其实是有重复计算的。我们把每一个位置的左边最高高度记录在一个数组上（maxLeft），右边最高高度记录在一个数组上（maxRight）。这样就避免了重复计算，这就用到了动态规划。

当前位置，左边的最高高度是前一个位置的左边最高高度和本高度的最大值。

即从左向右遍历：maxLeft[i] = max(height[i], maxLeft[i - 1]);

从右向左遍历：maxRight[i] = max(height[i], maxRight[i + 1]);

这样就找到递推公式。

代码如下：

```cpp
class Solution {
public:
    int trap(vector<int>& height) {
        if(height.size() <= 2) return 0;
        vector<int> maxLeft(height.size(), 0);
        vector<int> maxRight(height.size(), 0);
        int size = maxRight.size();

        maxLeft[0] = height[0];
        for(int i = 1; i < size; i++)
            maxLeft[i] = max(height[i], maxLeft[i - 1]);
        maxRight[size - 1] = height[size - 1];
        for(int i = size - 2; i >= 0; i--)
            maxRight[i] = max(height[i], maxRight[i + 1]);
        int sum = 0;
        for(int i = 0; i < size; i++){
            int cnt = min(maxLeft[i], maxRight[i]) - height[i];
            if(cnt > 0) sum += cnt;
        }
        return sum;
    }
};
```

**写法3-单调栈**

```

```



### 柱状图中最大的矩形

#### 相关链接

+ [84. 柱状图中最大的矩形](https://leetcode.cn/problems/largest-rectangle-in-histogram/)

#### 相关题目

给定 *n* 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。

求在该柱状图中，能够勾勒出来的矩形的最大面积。

**示例 1:**

<img src="https://assets.leetcode.com/uploads/2021/01/04/histogram.jpg"  style="zoom:80%;box-shadow:rgba(0,0,0,0) 0 0px 0px 0px;" />

```
输入：heights = [2,1,5,6,2,3]
输出：10
解释：最大的矩形为图中红色区域，面积为 10
```

#### 解题思路

**写法1-双指针**

```cpp
class Solution {
public:
    int largestRectangleArea(vector<int>& heights) {
        int sum = 0;
        for (int i = 0; i < heights.size(); i++) {
            int left = i;
            int right = i;
            for (; left >= 0; left--) {
                if (heights[left] < heights[i]) break;
            }
            for (; right < heights.size(); right++) {
                if (heights[right] < heights[i]) break;
            }
            int w = right - left - 1;
            int h = heights[i];
            sum = max(sum, w * h);
        }
        return sum;
    }
};
```

**写法2-动态规划**

本题要记录记录每个柱子 左边第一个小于该柱子的下标，而不是左边第一个小于该柱子的高度。

所以需要循环查找，也就是下面在寻找的过程中使用了while，

```cpp
class Solution {
public:
    int largestRectangleArea(vector<int>& heights) {
        vector<int> minLeftIndex(heights.size());
        vector<int> minRightIndex(heights.size());
        int size = heights.size();

        // 记录每个柱子 左边第一个小于该柱子的下标
        minLeftIndex[0] = -1; // 注意这里初始化，防止下面while死循环
        for (int i = 1; i < size; i++) {
            int t = i - 1;
            // 这里不是用if，而是不断向左寻找的过程
            while (t >= 0 && heights[t] >= heights[i]) t = minLeftIndex[t];
            minLeftIndex[i] = t;
        }
        // 记录每个柱子 右边第一个小于该柱子的下标
        minRightIndex[size - 1] = size; // 注意这里初始化，防止下面while死循环
        for (int i = size - 2; i >= 0; i--) {
            int t = i + 1;
            // 这里不是用if，而是不断向右寻找的过程
            while (t < size && heights[t] >= heights[i]) t = minRightIndex[t];
            minRightIndex[i] = t;
        }
        // 求和
        int result = 0;
        for (int i = 0; i < size; i++) {
            int sum = heights[i] * (minRightIndex[i] - minLeftIndex[i] - 1);
            result = max(sum, result);
        }
        return result;
    }
};
```

**写法3-单调栈**

```

```

## LRU缓存-高频

#### 相关链接

+ [146. LRU 缓存 ](https://leetcode.cn/problems/lru-cache/)

+ [剑指 Offer II 031. 最近最少使用缓存](https://leetcode.cn/problems/OrIXps/description/)

#### 相关题目

运用所掌握的数据结构，设计和实现一个 LRU (Least Recently Used，最近最少使用) 缓存机制。

实现 `LRUCache` 类：

+ `LRUCache(int capacity)` 以正整数作为容量 `capacity` 初始化 LRU 缓存
+ `int get(int key)` 如果关键字 `key` 存在于缓存中，则返回关键字的值，否则返回 `-1` 。
+ `void put(int key, int value)` 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字-值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。

#### 解题思路

自己定义哈希双向链表

1、如果我们每次默认从**链表头部添加元素**，那么显然越靠头部的元素就是最近使用的，越靠尾部的元素就是最久未使用的。

2、对于某一个 `key`，我们可以通过哈希表快速定位到链表中的节点，从而取得对应 `val`。

3、链表显然是支持在任意位置快速插入和删除的，改改指针就行。只不过传统的链表无法按照索引快速访问某一个位置的元素，而这里借助哈希表，可以通过 `key` 快速映射到任意一个链表节点，然后进行插入和删除。

<img src="https://labuladong.gitee.io/algo/images/LRU%e7%ae%97%e6%b3%95/4.jpg" alt="示例1" style="zoom:50%;box-shadow:rgba(0,0,0,0) 0 0px 0px 0px;" />

对于 get 操作，首先判断 key 是否存在：

+ 如果 key 不存在，则返回 −1；

+ 如果 key 存在，则 key 对应的节点是最近被使用的节点。

  （1）通过哈希表定位到该节点在双向链表中的位置

  （2）将其移动到双向链表的头部，

  （3）最后返回该节点的值。

对于 put 操作，首先判断 key 是否存在：

+ 如果 key 不存在

  （1）使用 key 和 value 创建一个新的节点

  （2）在双向链表的头部添加该节点

  （3）并将 key 和该节点添加进哈希表中

  （4）判断双向链表的节点数是否超出容量

  （5）如果超出容量则删除双向链表的尾部节点，并删除哈希表中对应的项；

+ 如果 key 存在，则与 get 操作类似

  （1）通过哈希表定位

  （2）将对应的节点的值更新为 value

  （3）并将该节点移到双向链表的头部。

上述各项操作中，访问哈希表的时间复杂度为 O(1)，在双向链表的头部添加节点、在双向链表的尾部删除节点的复杂度也为 O(1)。

而将一个节点移到双向链表的头部，可以分成「删除该节点」和「在双向链表的头部添加节点」两步操作，都可以在 O(1) 时间内完成。

```cpp
struct DLinkedNode {
    int key, value;
    DLinkedNode* prev;
    DLinkedNode* next;
    DLinkedNode(): key(0), value(0), prev(nullptr), next(nullptr) {}
    DLinkedNode(int _key, int _value): key(_key), value(_value), prev(nullptr), next(nullptr) {}
};
class LRUCache {
private:
    unordered_map<int, DLinkedNode*> cache;
    DLinkedNode* head;
    DLinkedNode* tail;
    int size;
    int capacity;
public:
    LRUCache(int _capacity): capacity(_capacity), size(0) {
        head = new DLinkedNode();
        tail = new DLinkedNode();
        head->next = tail;
        tail->prev = head;
    }
    int get(int key) {
        if (!cache.count(key)) return -1;
        DLinkedNode* node = cache[key];
        moveToHead(node);
        return node->value;
    }
    void put(int key, int value) {
        if (!cache.count(key)) {
            DLinkedNode* node = new DLinkedNode(key, value);
            cache[key] = node;
            addToHead(node);
            ++size;
            if (size > capacity) {
                DLinkedNode* removed = removeTail();
                cache.erase(removed->key);
                delete removed;
                --size;
            }
        }
        else {
            DLinkedNode* node = cache[key];
            node->value = value;
            moveToHead(node);
        }
    }
    void moveToHead(DLinkedNode* node) {
        removeNode(node);
        addToHead(node);
    }
    void addToHead(DLinkedNode* node) {
        node->prev = head;
        node->next = head->next;
        head->next->prev = node;
        head->next = node;
    }
    void removeNode(DLinkedNode* node) {
        node->prev->next = node->next;
        node->next->prev = node->prev;
    }

    DLinkedNode* removeTail() {
        DLinkedNode* node = tail->prev;
        removeNode(node);
        return node;
    }
};
```

