---
rauthor: WangXinYi
img: /images/homePage/数据结构.webp
summary: 基本数据结构
categories:
  - 算法
  - C++
  - 数据结构
tags:
  - 算法
  - C++
  - 数据结构
top: false
typora-root-url: ..
date: 2021-10-20 12:06:57
---

# 基本数据结构

## 数组

### 旋转单维数组

#### 相关链接

+ [旋转数组_牛客题霸](https://www.nowcoder.com/practice/e19927a8fd5d477794dac67096862042?tpId=295&tqId=1024689&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26tab%3D%E7%AE%97%E6%B3%95%E7%AF%87%26topicId%3D295%26fromPut%3Dpc_kol_aaaxiu)

#### 相关题目

一个数组A中存有 n 个整数，在不允许使用另外数组的前提下，将每个整数循环向右移 M（ M >=0）个位置，即将A中的数据由（A0 A1 ……AN-1 ）变换为（AN-M …… AN-1 A0 A1 ……AN-M-1 ）（最后 M 个数循环移至最前面的 M 个位置）。如果需要考虑程序移动数据的次数尽量少，要如何设计移动的方法？

#### 解题思路

```cpp
class Solution {
public:
    vector<int> solve(int n, int m, vector<int>& a) {
        m = m % n;
        reverse(a.begin(), a.end());
        reverse(a.begin(), a.begin() + m);
        reverse(a.begin() + m, a.end());
        return a;
    }
};
```

### 螺旋矩阵-二维变一维

#### 相关链接

+ [54. 螺旋矩阵](https://leetcode.cn/problems/spiral-matrix/)
+ [螺旋矩阵_牛客题霸](https://www.nowcoder.com/practice/7edf70f2d29c4b599693dc3aaeea1d31?tpId=295&tqId=693&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26tab%3D%E7%AE%97%E6%B3%95%E7%AF%87%26topicId%3D295%26fromPut%3Dpc_kol_aaaxiu)

#### 相关题目

给定一个m x n大小的矩阵（m行，n列），按螺旋的顺序返回矩阵中的所有元素。

#### 解题思路

```cpp
class Solution {
public:
    vector<int> spiralOrder(vector<vector<int>>& mat) {
        
        int m = mat.size();
        if(!m ) return {};
        int n = mat[0].size();
        
        vector<int> res;
        int l = 0, r = n - 1, t = 0, b = m - 1;
        int num = n * m;
        while(num >= 1){
            for(int i = l; i <= r && num >= 1; i++) { // num >= 1 切记有这个
                res.push_back(mat[t][i]); 
                num--;
            }
            t++;
            for(int i = t; i <= b && num >= 1; i++) {
                res.push_back(mat[i][r]); 
                num--;
            }
            r--;
            for(int i = r; i >= l && num >= 1; i--) {
                res.push_back(mat[b][i]);
                num--;
            }  
            b--;
            for(int i = b; i >= t && num >= 1; i--) {
                res.push_back(mat[i][l]);
                num--;
            }
            l++;
        }
        return res;
    }
};
```

### 螺旋矩阵 II-一维变二维

#### 相关链接

+ [48. 旋转图像](https://leetcode.cn/problems/rotate-image/)
+ [1886. 判断矩阵经轮转后是否一致 - 力扣（Leetcode）](https://leetcode.cn/problems/determine-whether-matrix-can-be-obtained-by-rotation/)

+ [59. 螺旋矩阵 II](https://leetcode.cn/problems/spiral-matrix-ii/)
+ [剑指 Offer 29. 顺时针打印矩阵 ](https://leetcode.cn/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/)

#### 相关题目

给你一个正整数 `n` ，生成一个包含 `1` 到 `n` 所有元素，且元素按顺时针顺序螺旋排列的 `n x n` 正方形矩阵 `matrix` 。

**示例 1：**

<img src="https://assets.leetcode.com/uploads/2020/11/13/spiraln.jpg" alt="示例1"  style="zoom:80%;" />

```
输入：n = 3
输出：[[1,2,3],[8,9,4],[7,6,5]]
```

**示例 2：**

```
输入：n = 1
输出：[[1]]
```

#### 解题思路

求解本题依然是要坚持循环不变量原则。

模拟顺时针画矩阵的过程:

+ 填充上行从左到右
+ 填充右列从上到下
+ 填充下行从右到左
+ 填充左列从下到上

坚持每条边左闭右开的原则。

那么我按照左闭右开的原则，来画一圈，大家看一下：

<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20220922102236.png" style="zoom: 18%;box-shadow:rgba(0,0,0,0) 0 0px 0px 0px;" />

代码随想录完整代码加详细注释如下：

```cpp
class Solution {
public:
    vector<vector<int>> generateMatrix(int n) {
        vector<vector<int>> res(n, vector<int>(n, 0)); // 使用vector定义一个二维数组
        int startx = 0, starty = 0; // 定义每循环一个圈的起始位置
        int loop = n / 2; // 每个圈循环几次，例如n为奇数3，那么loop = 1 只是循环一圈，矩阵中间的值需要单独处理
        int mid = n / 2; // 矩阵中间的位置，例如：n为3， 中间的位置就是(1，1)，n为5，中间位置为(2, 2)
        int count = 1; // 用来给矩阵中每一个空格赋值
        int offset = 1; // 需要控制每一条边遍历的长度，每次循环右边界收缩一位
        int i,j;
        while (loop --) {
            i = startx;
            j = starty;

            // 下面开始的四个for就是模拟转了一圈
            // 模拟填充上行从左到右(左闭右开)
            for (j = starty; j < n - offset; j++) {
                res[i][j] = count++;
            }
            // 模拟填充右列从上到下(左闭右开)
            for (i = startx; i < n - offset; i++) {
                res[i][j] = count++;
            }
            // 模拟填充下行从右到左(左闭右开)
            for (; j > starty; j--) {
                res[i][j] = count++;
            }
            // 模拟填充左列从下到上(左闭右开)
            for (; i > startx; i--) {
                res[i][j] = count++;
            }

            // 第二圈开始的时候，起始位置要各自加1， 例如：第一圈起始位置是(0, 0)，第二圈起始位置是(1, 1)
            startx++;
            starty++;

            // offset 控制每一圈里每一条边遍历的长度
            offset += 1;
        }

        // 如果n为奇数的话，需要单独给矩阵最中间的位置赋值
        if (n % 2) {
            res[mid][mid] = count;
        }
        return res;
    }
};
```

[其他简单思路](https://leetcode.cn/problems/spiral-matrix-ii/solutions/12594/spiral-matrix-ii-mo-ni-fa-she-ding-bian-jie-qing-x/)

生成一个 n×n 空矩阵 mat，随后模拟整个向内环绕的填入过程：

+ 定义当前左右上下边界 l,r,t,b，初始值 num = 1，迭代终止值 tar = n * n；

+ 当 num <= tar 时，始终按照 从左到右 从上到下 从右到左 从下到上 填入顺序循环，每次填入后：
  执行 num += 1：得到下一个需要填入的数字；

  更新边界：例如从左到右填完后，上边界 t += 1，相当于上边界向内缩 1。

  使用num <= tar而不是l < r || t < b作为迭代条件，是为了解决当n为奇数时，矩阵中心数字无法在迭代过程中被填充的问题。

```c++
class Solution {
public:
    vector<vector<int>> generateMatrix(int n) {
        vector<vector<int>> res(n, vector<int>(n, 0));
        int l = 0, r = n - 1, t = 0, b = n - 1;
        int num = 1, tar = n * n;
        while(num <= tar){
            for(int i = l; i <= r; i++) mat[t][i] = num++; // left to right.
            t++;
            for(int i = t; i <= b; i++) mat[i][r] = num++; // top to bottom.
            r--;
            for(int i = r; i >= l; i--) mat[b][i] = num++; // right to left.
            b--;
            for(int i = b; i >= t; i--) mat[i][l] = num++; // bottom to top.
            l++;
        }
        return res;
    }
};
```

### 旋转图像90 度

#### 相关链接

+ [48. 旋转图像](https://leetcode.cn/problems/rotate-image/description/)
+ [顺时针旋转矩阵_牛客题霸](https://www.nowcoder.com/practice/2e95333fbdd4451395066957e24909cc?tpId=295&tqId=25283&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26tab%3D%E7%AE%97%E6%B3%95%E7%AF%87%26topicId%3D295%26fromPut%3Dpc_kol_aaaxiu)

#### 相关题目

给定一个 *n* × *n* 的二维矩阵 `matrix` 表示一个图像。请你将图像顺时针旋转 90 度。

你必须在原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。**请不要** 使用另一个矩阵来旋转图像。

#### 解题思路

使用新数组

```cpp
class Solution {
public:
    void rotate(vector<vector<int>>& matrix) {
        int n = matrix.size();
        auto matrix_new = matrix;
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < n; ++j) {
                matrix_new[j][n - i - 1] = matrix[i][j];
            }
        }
        matrix = matrix_new;
    }
};
```

原地旋转

```cpp
class Solution {
public:
    void rotate(vector<vector<int>>& matrix) {
        int n = matrix.size();
        for(int i = 0; i < n / 2; i++) {
            for(int j = 0;j < (n + 1) / 2; j++) {
                int tmp = matrix[i][j];
                matrix[i][j] = matrix[n-j-1][i];
                matrix[n-j-1][i] = matrix[n-i-1][n-j-1];
                matrix[n-i-1][n-j-1] = matrix[j][n-i-1];
                matrix[j][n-i-1] = tmp;
            }
        }
    }
};
```

[顺时针旋转矩阵_牛客题霸](https://www.nowcoder.com/practice/2e95333fbdd4451395066957e24909cc?tpId=295&tqId=25283&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26tab%3D%E7%AE%97%E6%B3%95%E7%AF%87%26topicId%3D295%26fromPut%3Dpc_kol_aaaxiu) 效果都一样，只不过这个多给了n，可以省略int n = matrix.size();

```cpp
class Solution {
public:
    vector<vector<int> > rotateMatrix(vector<vector<int> > mat, int n) {
        for(int i = 0; i < n ;i++)
            for(int j = 0; j < i; j++) 
                swap(mat[i][j], mat[j][i]);
        for(int i = 0; i < n; i++) reverse(mat[i].begin(), mat[i].end());
        return mat;
    }
};
```

### 判断矩阵经轮转后是否一致

#### 相关链接

+ [1886. 判断矩阵经轮转后是否一致 ](https://leetcode.cn/problems/determine-whether-matrix-can-be-obtained-by-rotation/)

#### 相关题目

给你两个大小为 `n x n` 的二进制矩阵 `mat` 和 `target` 。

现 **以 90 度顺时针轮转** 矩阵 `mat` 中的元素 **若干次** ，如果能够使 `mat` 与 `target` 一致，返回 `true` ；否则，返回 `false` *。*

#### 解题思路

原地旋转

```cpp
class Solution {
public:
    bool findRotation(vector<vector<int>>& mat, vector<vector<int>>& target) {
        int n = mat.size();
        for(int k = 0; k < 4; k++) {
            for(int i = 0; i < n / 2; i++) {
                for(int j = 0; j < ( n + 1 ) / 2; j++) {
                    int tmp = mat[i][j];
                    mat[i][j] = mat[n-j-1][i];
                    mat[n-j-1][i] = mat[n-i-1][n-j-1];
                    mat[n-i-1][n-j-1] = mat[j][n-i-1];
                    mat[j][n-i-1] = tmp;
                }
            }
            if(mat == target) return true; 
        }
        return false;
    }
};
```

### 顺时针旋转矩阵

#### 相关链接

+ 

#### 相关题目

有一个NxN整数矩阵，请编写一个算法，将矩阵顺时针旋转90度。

给定一个NxN的矩阵，和矩阵的阶数N,请返回旋转后的NxN矩阵。

#### 解题思路

```cpp

```

## 字符串

### 反转字符串II

#### 相关链接

+ [344. 反转字符串](https://leetcode.cn/problems/reverse-string/description/)
+ [541. 反转字符串 II ](https://leetcode.cn/problems/reverse-string-ii/)

#### 相关题目

给定一个字符串 `s` 和一个整数 `k`，从字符串开头算起，每计数至 `2k` 个字符，就反转这 `2k` 字符中的前 `k` 个字符。

+ 如果剩余字符少于 `k` 个，则将剩余字符全部反转。
+ 如果剩余字符小于 `2k` 但大于或等于 `k` 个，则反转前 `k` 个字符，其余字符保持原样。

**示例 1：**

```
输入：s = "abcdefg", k = 2
输出："bacdfeg"
```

#### 解题思路

[344. 反转字符串](https://leetcode.cn/problems/reverse-string/description/)

```cpp
class Solution {
public:
    void reverseString(vector<char>& s) {
        for(int i = 0, j = s.size() - 1; i < j; i++, j--) {
            swap(s[i], s[j]);
        }
    }
};
```

swap可以有两种实现。

一种就是常见的交换数值：

```cpp
int tmp = s[i];
s[i] = s[j];
s[j] = tmp;
```

一种就是通过位运算：

```cpp
s[i] ^= s[j];
s[j] ^= s[i];
s[i] ^= s[j];
```

[541. 反转字符串 II ](https://leetcode.cn/problems/reverse-string-ii/)

+ 剩余字符大于等于 `2k` 

+ 剩余字符小于 `2k` 但大于或等于 `k` 个
+ 剩余字符少于 `k` 个

前两种情况可以合并

```cpp
class Solution {
public:
    string reverseStr(string s, int k) {
        for(int i = 0; i < s.size(); i += 2 * k){
            if(i + k < s.size() ) {
                reverse(s.begin() + i, s.begin() + i + k);             
            } else {
                reverse(s.begin() + i, s.end());      
            }
        }
        return s;
    }
};
```

### 替换空格

#### 相关链接

+ [剑指 Offer 05. 替换空格 ](https://leetcode.cn/problems/ti-huan-kong-ge-lcof/description/)

#### 相关题目

请实现一个函数，把字符串 `s` 中的每个空格替换成"%20"。

**示例 1：**

```
输入：s = "We are happy."
输出："We%20are%20happy."
```

#### 解题思路

不用额外的辅助空间，首先扩充数组到每个空格替换成"%20"之后的大小。

然后从后向前替换空格，也就是双指针法，i指向新长度的末尾，j指向旧长度的末尾。

从前向后填充就是O(n^2)的算法了，因为每次添加元素都要将添加元素之后的所有元素向后移动。

**其实很多数组填充类的问题，都可以先预先给数组扩容带填充后的大小，然后在从后向前进行操作。**

这么做有两个好处：

1. 不用申请新数组。
2. 从后向前填充元素，避免了从前向后填充元素时，每次添加元素都要将添加元素之后的所有元素向后移动的问题。

```cpp
class Solution {
public:
    string replaceSpace(string s) {
        int cnt = 0;
        int oldSize = s.size();
        for(int i = 0; i < s.size(); i++) 
            if(s[i] == ' ') cnt++;
        s.resize(s.size() + cnt * 2);
        int newSize = s.size();
        for(int i = newSize - 1, j = oldSize - 1; j >= 0;i--,j--) {
            if(s[j] != ' ') s[i] = s[j];
            else {
                s[i] = '0';
                s[i - 1] = '2';
                s[i - 2] = '%';
                i -= 2;
            }
        }
        return s;
    }
};
```

### 反转字符串中的单词

#### 相关链接

+ [151. 反转字符串中的单词 ](https://leetcode.cn/problems/reverse-words-in-a-string/description/)

#### 相关题目

给你一个字符串 `s` ，请你反转字符串中 **单词** 的顺序。

**单词** 是由非空格字符组成的字符串。`s` 中使用至少一个空格将字符串中的 **单词** 分隔开。

返回 **单词** 顺序颠倒且 **单词** 之间用单个空格连接的结果字符串。

**注意：**输入字符串 `s`中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。

**示例 1：**

```
输入：s = "  hello world  "
输出："world hello"
解释：反转后的字符串中不能存在前导空格和尾随空格。
```

#### 解题思路

**不使用辅助空间，空间复杂度要求为O(1)。**

+ 移除多余空格
+ 将整个字符串反转
+ 将每个单词反转

举个例子，源字符串为："the sky is blue "

+ 移除多余空格 : "the sky is blue"
+ 字符串反转："eulb si yks eht"
+ 单词反转："blue is sky the"

移除多余空格 erase是O(n),erase操作上面还套了一个for循环，移除冗余空格的代码时间复杂度为O(n^2)。

使用之前快慢指针-移除元素的模板 [27. 移除元素](https://leetcode.cn/problems/remove-element/)

接下来就是将整个字符串反转，遇到空格或是末尾将每个单词反转

完整代码如下：

```cpp
class Solution {
public:
    string reverseWords(string s) {
        //快慢指针-移除元素的模板
        int slowIndex = 0;
        for(int fastIndex = 0; fastIndex < s.size(); fastIndex++) {
            if(s[fastIndex] != ' ') {
                if(slowIndex != 0) s[slowIndex++] = ' ';
                while(fastIndex < s.size() && s[fastIndex] != ' ')
                    s[slowIndex++] = s[fastIndex++];
            }
        }
        s.resize(slowIndex);
        reverse(s.begin(), s.end());
        int start = 0;
        for(int i = 0; i <= s.size(); i++){
            if(s[i] == ' ' || i == s.size()){
                reverse(s.begin() + start, s.begin() + i);
                start = i + 1;
            }
        }
        return s;
    }
};
```

### 左旋转字符串

#### 相关链接

+ [剑指 Offer 58 - II. 左旋转字符串](https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/)

#### 相关题目

字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串"abcdefg"和数字2，该函数将返回左旋转两位得到的结果"cdefgab"。

**示例 1：**

```
输入: s = "abcdefg", k = 2
输出: "cdefgab"
```

#### 解题思路

**不能申请额外空间，只能在本串上操作**。

可以通过局部反转+整体反转 达到左旋转的目的。

具体步骤为：

1. 反转区间为前n的子串
2. 反转区间为n到末尾的子串
3. 反转整个字符串

完整代码如下：

```cpp
class Solution {
public:
    string reverseLeftWords(string s, int n) {
        reverse(s.begin(), s.begin() + n);
        reverse(s.begin() + n, s.end());
        reverse(s.begin(), s.end());
        return s;
    }
};
```

需要注意的是：不同编程语言底层的字符串实现原理（可变/不可变），使用substr 和 反转 时间复杂度是一样的 ，都是O(n)，但是使用substr申请了额外空间，所以空间复杂度是O(n)，而反转方法的空间复杂度是O(1)。

```java
class Solution {
public:
    string reverseLeftWords(string s, int n) {
        return s.substr(n) + s.substr(0, n);
    }
};
```

### 找出字符串首个匹配项的下标

#### 相关链接

+ [28. 找出字符串中第一个匹配项的下标 ](https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/)

#### 相关题目

给你两个字符串 `haystack` 和 `needle` ，请你在 `haystack` 字符串中找出 `needle` 字符串的第一个匹配项的下标（下标从 0 开始）。如果 `needle` 不是 `haystack` 的一部分，则返回 `-1` 。

**示例 1：**

```
输入：haystack = "sadbutsad", needle = "sad"
输出：0
解释："sad" 在下标 0 和 6 处匹配。
第一个匹配项的下标是 0 ，所以返回 0 。
```

#### 解题思路

忘记了 KMP 先看这两个视频

> [代码随想录   帮你把KMP算法学个通透！（理论篇）_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1PD4y1o7nd/?vd_source=178669e0797f36fb015c5fc3cb9c7a4f)
>
> [代码随想录   帮你把KMP算法学个通透！（求next数组代码篇）_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1M5411j7Xx/)

KMP 的next数组有多种实现，其实是对应的遇到冲突解决方法不一致

+ next数组 是前缀表原封不动 ，要找遇到冲突的前 1 位
+ **next数组 是前缀表的整体减 1，要找遇到冲突的前 1 位，并 + 1，这种情况最常见！！！**
+ next数组 是前缀表后移 1 位，开头赋值为 -1，要找遇到冲突那位对应的下标

**伪代码实现**

i 表示后缀末尾，j 表示前缀末尾，并且表示 i 之前的子串的最长相等前后缀长度，按以下四部走：

（1）初始化

（2）前后缀不相同

（3）前后缀相同

（4）更新next数组

前缀表统一减 1 来构建next数组，（优先记忆这个）代码如下：

```cpp
void getNext(int* next, const string& s){
    int j = -1;
    next[0] = j;
    for(int i = 1; i < s.size(); i++) { // 注意i从1开始
        while (j >= 0 && s[i] != s[j + 1]) { // 前后缀不相同了
            j = next[j]; // 向前回退
        }
        if (s[i] == s[j + 1]) { // 找到相同的前后缀
            j++;
        }
        next[i] = j; // 将j（前缀的长度）赋给next[i]
    }
}
```

前缀表统一减 1 来构建next数组，完整代码如下：

```cpp
class Solution {
public:
    void getNext(int* next, const string& s) {
        int j = -1;
        next[0] = j;
        for(int i = 1; i < s.size(); i++) { // 注意i从1开始
            while (j >= 0 && s[i] != s[j + 1]) { // 前后缀不相同了
                j = next[j]; // 向前回退
            }
            if (s[i] == s[j + 1]) { // 找到相同的前后缀
                j++;
            }
            next[i] = j; // 将j（前缀的长度）赋给next[i]
        }
    }
    int strStr(string haystack, string needle) {
        if (needle.size() == 0) {
            return 0;
        }
        int next[needle.size()];
        getNext(next, needle);
        int j = -1; // // 因为next数组里记录的起始位置为-1
        for (int i = 0; i < haystack.size(); i++) { // 注意i就从0开始
            while(j >= 0 && haystack[i] != needle[j + 1]) { // 不匹配
                j = next[j]; // j 寻找之前匹配的位置
            }
            if (haystack[i] == needle[j + 1]) { // 匹配，j和i同时向后移动
                j++; // i的增加在for循环里
            }
            if (j == (needle.size() - 1) ) { // 文本串s里出现了模式串t
                return (i - needle.size() + 1);
            }
        }
        return -1;
    }
};
```

前缀表不减 1 来构建next数组，代码如下：

```cpp
void getNext(int* next, const string& s) {
    int j = 0;
    next[0] = 0;
    for(int i = 1; i < s.size(); i++) {
        while (j > 0 && s[i] != s[j]) { // j要保证大于0，因为下面有取j-1作为数组下标的操作
            j = next[j - 1]; // 注意这里，是要找前一位的对应的回退位置了
        }
        if (s[i] == s[j]) {
            j++;
        }
        next[i] = j;
    }
}
```

前缀表不减 1 来构建next数组，完整代码如下：

```cpp
class Solution {
public:
    void getNext(int* next, const string& s) {
        int j = 0;
        next[0] = 0;
        for(int i = 1; i < s.size(); i++) {
            while (j > 0 && s[i] != s[j]) {
                j = next[j - 1];
            }
            if (s[i] == s[j]) {
                j++;
            }
            next[i] = j;
        }
    }
    int strStr(string haystack, string needle) {
        if (needle.size() == 0) {
            return 0;
        }
        int next[needle.size()];
        getNext(next, needle);
        int j = 0;
        for (int i = 0; i < haystack.size(); i++) {
            while(j > 0 && haystack[i] != needle[j]) {
                j = next[j - 1];
            }
            if (haystack[i] == needle[j]) {
                j++;
            }
            if (j == needle.size() ) {
                return (i - needle.size() + 1);
            }
        }
        return -1;
    }
};
```

Y总的模板

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=10010,M=100010;
int n,m;
char p[N],s[N];
int next[N];
int main() 
{	
	cin>>m>>p+1>>n>>s+1;
	// s[]是长文本，n是s的长度，p[]是模式串，m是p的长度
	//求模式串的Next数组：
	for (int i = 2, j = 0; i <= m; i ++ ) {
	    while (j && p[i] != p[j + 1]) j = next[j];
	    if (p[i] == p[j + 1]) j ++ ;
	    next[i] = j;
	}
	
	// kmp匹配
	for (int i = 1, j = 0; i <= n; i ++ ) {
	    while (j && s[i] != p[j + 1]) j = next[j];
	    if (s[i] == p[j + 1]) j ++ ;
	    if (j == m) {// 匹配成功后的逻辑
			cout<< i - m <<" ";
	        j = next[j];
	    }
	}
	return 0;
}
```

**总结 自己最后的写法**

```cpp
class Solution {
public:
    //KMP算法
    int strStr(string s, string p) {
        if(p.size() == 0) return 0;
        int next[p.size()];
        int j = -1;
        next[0] = -1;
        for(int i = 1; i < p.size(); i++){
            while(j >= 0 && p[i] != p[j + 1]) j = next[j];
            if(p[i] == p[j + 1]) j++;
            next[i] = j; 
        }
        j = -1;
        for(int i = 0; i < s.size(); i++){
            while(j >= 0 && s[i] != p[j + 1]) j = next[j];
            if(s[i] == p[j + 1]) j++;
            if(j == (p.size() - 1)) return (i - p.size() + 1);
        }        
        return -1;
    }
};
```

### 重复的子字符串

#### 相关链接

+ [459. 重复的子字符串](https://leetcode.cn/problems/repeated-substring-pattern/)

#### 相关题目

给你两个字符串 `haystack` 和 `needle` ，请你在 `haystack` 字符串中找出 `needle` 字符串的第一个匹配项的下标（下标从 0 开始）。如果 `needle` 不是 `haystack` 的一部分，则返回 `-1` 。

**示例 1：**

```
输入：haystack = "sadbutsad", needle = "sad"
输出：0
解释："sad" 在下标 0 和 6 处匹配。
第一个匹配项的下标是 0 ，所以返回 0 。
```

#### 解题思路

**写法1-移动匹配**

前面有相同的子串，后面有相同的子串，用 s + s，只要两个s拼接在一起，里面还出现一个s的话，就说明是由重复子串组成。

当然，我们在判断 s + s 拼接的字符串里是否出现一个s的的时候，**要刨除 s + s 的首字符和尾字符**，这样避免在s+s中搜索出原来的s，我们要搜索的是中间拼接出来的s。

```cpp
class Solution {
public:
    bool repeatedSubstringPattern(string s) {
        string t = s + s;
        t.erase(t.begin()); t.erase(t.end() - 1);
        if(t.find(s) != -1) return true;
        return false;
    }
};
```

**写法2-KMP算法**

> [代码随想录 | LeetCode：459.重复的子字符串_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1cg41127fw/?vd_source=178669e0797f36fb015c5fc3cb9c7a4f)

最长相等前后缀不包含的子串就是最小重复子串

例子：abababab，前缀是前6个字符ababab，后缀是后6个字符ababab，之间没有重叠的部分就是最小重复子串

如果整个字符串长度能 整除 整个字符串长度-next数组最后的值 的话，说明这个字符串是重复子字符串

**以下next数组的求法 是前缀表的整体减 1，要找遇到冲突的前 1 位，并 + 1，这种情况**

```cpp
class Solution {
public:
    bool repeatedSubstringPattern(string s) {
        if(s.size() == 0) return false;
        int next[s.size()];
        int j = -1;
        next[0] = -1;
        for(int i = 1; i < s.size(); i++){
            while(j >= 0 && s[i] != s[j + 1]) j = next[j];
            if(s[i] == s[j + 1]) j++;
            next[i] = j;
        }
        if(next[s.size() - 1] != -1 && s.size() % (s.size() - (next[s.size()- 1] + 1)) == 0){
            return true;
        }
        return false;
    }
};
```

## 栈与队列

### 栈与队列的理论基础

1. C++中stack和queue是容器吗？

   C++的STL中栈和栈往往不被归类为容器，而被归类为container adapter（容器适配器）。

2. 我们使用的STL中stack和queue是如何实现的？

   **栈是以底层容器完成其所有的工作，对外提供统一的接口，底层容器是可插拔的（也就是说我们可以控制使用哪种容器来实现栈的功能）。**栈的内部结构，栈的底层实现可以是vector，deque，list 都是可以的， 主要就是数组和链表的底层实现。**我们常用的SGI STL，如果没有指定底层实现的话，栈和队列默认都是以deque为缺省情况下栈的底层结构。**

3. stack 和queue提供迭代器来遍历空间吗？

   栈提供push 和 pop 等等接口，所有元素必须符合先进后出规则，所以栈不提供走访功能，也不提供迭代器(iterator)。 不像是set 或者map 提供迭代器iterator来遍历所有元素。队列中先进先出的数据结构，同样不允许有遍历行为，不提供迭代器, 

### 用栈实现队列

#### 相关链接

+ [232. 用栈实现队列 ](https://leetcode.cn/problems/implement-queue-using-stacks/description/)

#### 相关题目

请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（`push`、`pop`、`peek`、`empty`）：

实现 `MyQueue` 类：

+ `void push(int x)` 将元素 x 推到队列的末尾
+ `int pop()` 从队列的开头移除并返回元素
+ `int peek()` 返回队列开头的元素
+ `boolean empty()` 如果队列为空，返回 `true` ；否则，返回 `false`

**说明：**

+ 你 **只能** 使用标准的栈操作 —— 也就是只有 `push to top`, `peek/pop from top`, `size`, 和 `is empty` 操作是合法的。
+ 你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。

#### 解题思路

自己的代码存在的问题

+ 不需要将输出栈的内容再输入到输入栈中

+ peek()其实可以复用pop()的代码

```cpp
class MyQueue {
private:
    stack<int> s1;
    stack<int> s2;
public:
    MyQueue() {}
    void push(int x) {
        s1.push(x);
    }
    int pop() {
        while(!s1.empty()){
            s2.push(s1.top());
            s1.pop();
        }
        int res = s2.top();
        s2.pop();
        while(!s2.empty()){
            s1.push(s2.top());
            s2.pop();
        }
        return res;
    }
    int peek() {
        while(!s1.empty()){
            s2.push(s1.top());
            s1.pop();
        }
        int res = s2.top();
        while(!s2.empty()){
            s1.push(s2.top());
            s2.pop();
        }
        return res;
    }
    bool empty() {
        return s1.empty();
    }
};
```

代码随想录的代码

```cpp
class MyQueue {
public:
    stack<int> sIn;
    stack<int> sOut;
    MyQueue() {}
    
    void push(int x) {
        sIn.push(x);
    }
    
    int pop() {
        if(sOut.empty()){
            while(!sIn.empty()){
                sOut.push(sIn.top());
                sIn.pop();
            }
        }
        int res = sOut.top();
        sOut.pop();
        return res;
    }
    
    int peek() {
        int res = this->pop(); 
        sOut.push(res);
        return res;
    }
    
    bool empty() {
        return sIn.empty() && sOut.empty();
    }
};
```

### 包含min函数的栈

#### 相关链接

+ [包含min函数的栈_牛客题霸](https://www.nowcoder.com/practice/4c776177d2c04c2494f2555c9fcc1e49?tpId=295&tqId=23268&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26tab%3D%E7%AE%97%E6%B3%95%E7%AF%87%26topicId%3D295%26fromPut%3Dpc_kol_aaaxiu)

#### 相关题目

定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的 min 函数，输入操作时保证 pop、top 和 min 函数操作时，栈中一定有元素。

#### 解题思路

```cpp
class Solution {
public:
    stack<int> st1;
    stack<int> st2;
    void push(int value) {
        st1.push(value);
        if(st2.empty() || st2.top() > value) st2.push(value);
        else st2.push(st2.top());
    }
    void pop() {
        st1.pop();
        st2.pop();
    }
    int top() {
        return st1.top();
    }
    int min() {
        return st2.top();
    }
};
```

### 用队列实现栈

#### 相关链接

+ [225. 用队列实现栈](https://leetcode.cn/problems/implement-stack-using-queues/)

#### 相关题目

请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（`push`、`top`、`pop` 和 `empty`）。

实现 `MyStack` 类：

+ `void push(int x)` 将元素 x 压入栈顶。
+ `int pop()` 移除并返回栈顶元素。
+ `int top()` 返回栈顶元素。
+ `boolean empty()` 如果栈是空的，返回 `true` ；否则，返回 `false` 。

#### 解题思路

两个队列，一个队列负责输入输出，另一个队列只负责暂存

```cpp
class MyStack {
public:
    queue<int> que1;
    queue<int> que2;
    MyStack() {}
    
    void push(int x) {
        que1.push(x);
    }

    int pop() {
        int size = que1.size();
        while(size > 1){
            que2.push(que1.front());
            que1.pop();
            size--;
        }
        int res = que1.front();
        que1.pop();
        while(!que2.empty()){
            que1.push(que2.front());
            que2.pop();
        }
        return res;
    }
    //只用一个队列优化，只需要将元素重新添加到队列尾部
    // int pop() {
    //     int size = que.size();
    //     size--;
    //     while (size--) { // 将队列头部的元素（除了最后一个元素外） 重新添加到队列尾部
    //         que.push(que.front());
    //         que.pop();
    //     }
    //     int result = que.front(); // 此时弹出的元素顺序就是栈的顺序了
    //     que.pop();
    //     return result;
    // }    
    int top() {
        return que1.back();
    }
    
    bool empty() {
        return que1.empty();
    }
};
```

### 滑动窗口的平均值

#### 相关链接

+ [剑指 Offer II 041. 滑动窗口的平均值](https://leetcode.cn/problems/qIsx9U/description/)

#### 相关题目

给定一个整数数据流和一个窗口大小，根据该滑动窗口的大小，计算滑动窗口里所有数字的平均值。

实现 `MovingAverage` 类：

+ `MovingAverage(int size)` 用窗口大小 `size` 初始化对象。
+ `double next(int val)` 成员函数 `next` 每次调用的时候都会往滑动窗口增加一个整数，请计算并返回数据流中最后 `size` 个值的移动平均值，即滑动窗口里所有数字的平均值。

#### 解题思路

```cpp
class MovingAverage {
public:
    int cnt = 0, sum = 0;
    queue<int> q;
    MovingAverage(int size) { cnt = size; }
    
    double next(int val) {
        sum += val;
        q.push(val);
        if(q.size() > cnt) {
            sum -= q.front();
            q.pop();
        }
        return (double)sum / q.size();
    }
};
```



### 有效的括号

#### 相关链接

+ [20. 有效的括号](https://leetcode.cn/problems/valid-parentheses/description/)
+ [921. 使括号有效的最少添加 ](https://leetcode.cn/problems/minimum-add-to-make-parentheses-valid/)
+ [1541. 平衡括号字符串的最少插入次数 ](https://leetcode.cn/problems/minimum-insertions-to-balance-a-parentheses-string/description/)
+ [剑指 Offer II 085. 生成匹配的括号---需要用递归解决](https://leetcode.cn/problems/IDBivT/description/)

#### 相关题目

给定一个只包括 `'('`，`')'`，`'{'`，`'}'`，`'['`，`']'` 的字符串 `s` ，判断字符串是否有效。

有效字符串需满足：

1. 左括号必须用相同类型的右括号闭合。
2. 左括号必须以正确的顺序闭合。
3. 每个右括号都有一个对应的相同类型的左括号。

**示例 1：**

```
输入：s = "()"
输出：true
```

#### 解题思路

+ 第一种情况，字符串里左方向的括号多余了 。( [ { } ] ( )
+ 第二种情况，括号没有多余，但是 括号的类型没有匹配上。 
+ 第三种情况，字符串里右方向的括号多余了。( [ { } ] ) )

代码随想录--栈里放入右括号

```cpp
class Solution {
public:
    bool isValid(string s) {
        if (s.size() % 2 != 0) return false; // 如果s的长度为奇数，一定不符合要求
        stack<char> st;
        for (int i = 0; i < s.size(); i++) {
            if (s[i] == '(') st.push(')');
            else if (s[i] == '{') st.push('}');
            else if (s[i] == '[') st.push(']');
            // 第三种情况：说明右括号没有找到对应的左括号 
            // 第二种情况：栈里没有我们要匹配的字符。
            else if (st.empty() || st.top() != s[i]) return false;
            else st.pop(); // st.top() 与 s[i]相等，栈弹出元素
        }
        // 第一种情况：此时我们已经遍历完了字符串，但是栈不为空，说明有相应的左括号没有右括号来匹配
        return st.empty();
    }
};
```

### 删除字符串所有相邻重复项

#### 相关链接

+ [1047. 删除字符串中的所有相邻重复项 ](https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/description/)

#### 相关题目

给出由小写字母组成的字符串 `S`，**重复项删除操作**会选择两个相邻且相同的字母，并删除它们。

在 S 上反复执行重复项删除操作，直到无法继续删除。

在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。

**示例：**

```
输入："abbaca"
输出："ca"
解释：
例如，在 "abbaca" 中，我们可以删除 "bb" 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 "aaca"，其中又只有 "aa" 可以执行重复项删除操作，所以最后的字符串为 "ca"。
```

#### 解题思路

只需要注意只用字符串就行，不必非得用栈

```cpp
class Solution {
public:
    string removeDuplicates(string s) {
        string res;
        for(char c : s){
            if(res.empty() || res.back() != c) res.push_back(c);
            else res.pop_back();
        }
        return res;
    }
};
```

### 逆波兰表达式求值

#### 相关链接

+ [150. 逆波兰表达式求值 ](https://leetcode.cn/problems/evaluate-reverse-polish-notation/description/)

#### 相关题目

给你一个字符串数组 `tokens` ，表示一个根据 逆波兰表示法表示的算术表达式。

请你计算该表达式。返回一个表示表达式值的整数。

**注意：**

+ 有效的算符为 `'+'`、`'-'`、`'*'` 和 `'/'` 。
+ 每个操作数（运算对象）都可以是一个整数或者另一个表达式。
+ 两个整数之间的除法总是 **向零截断** 。
+ 表达式中不含除零运算。
+ 输入是一个根据逆波兰表示法表示的算术表达式。
+ 答案及所有中间计算结果可以用 **32 位** 整数表示。

**示例 1：**

```
输入：tokens = ["2","1","+","3","*"]
输出：9
解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9
```

#### 解题思路

逆波兰表达式主要有以下两个优点：

+ 去掉括号后表达式无歧义，上式即便写成 1 2 + 3 4 + * 也可以依据次序计算出正确结果。
+ 适合用栈操作运算：遇到数字则入栈；遇到运算符则取出栈顶两个数字进行计算，并将结果压入栈中。

C++ 中stoll 函数将在函数调用中作为参数提供的字符串转换为long long。

```cpp
class Solution {
public:
    int evalRPN(vector<string>& tokens) {
        stack<long long> st;
        for(int i = 0; i < tokens.size(); i++){
            if(tokens[i] == "+" || tokens[i] == "-" || tokens[i] == "*" || tokens[i] == "/"){
                long long t1 = st.top();
                st.pop();
                long long t2 = st.top();
                st.pop();
                if (tokens[i] == "+") st.push(t2 + t1);
                if (tokens[i] == "-") st.push(t2 - t1);
                if (tokens[i] == "*") st.push(t2 * t1);
                if (tokens[i] == "/") st.push(t2 / t1);
            } else st.push(stoll(tokens[i]));
        }
        return st.top();
    }
};
```

### 表达式求值

#### 相关链接

+ [表达式求值_牛客题霸](https://www.nowcoder.com/practice/c215ba61c8b1443b996351df929dc4d4?tpId=295&tqId=1076787&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26tab%3D%E7%AE%97%E6%B3%95%E7%AF%87%26topicId%3D295%26fromPut%3Dpc_kol_aaaxiu)

#### 相关题目

请写一个整数计算器，支持加减乘三种运算和括号。

#### 解题思路

对于上述两个要求，我们要考虑的是两点，一是处理运算优先级的问题，二是处理括号的问题。

处理优先级问题，那必定是乘号有着优先运算的权利，加号减号先一边看，我们甚至可以把减号看成加一个数的相反数，则这里只有乘法和加法，那我们优先处理乘法，遇到乘法，把前一个数和后一个数乘起来，遇到加法就把这些数字都暂时存起来，最后乘法处理完了，就剩余加法，把之前存起来的数字都相加就好了。

处理括号的问题，我们可以将括号中的部分看成一个新的表达式，即一个子问题，因此可以将新的表达式递归地求解，得到一个数字，再运算：

+ **终止条件：** 每次遇到左括号意味着进入括号子问题进行计算，那么遇到右括号代表这个递归结束。
+ **返回值：** 将括号内部的计算结果值返回。
+ **本级任务：** 遍历括号里面的字符，进行计算。

**具体做法：**

+ step 1：使用栈辅助处理优先级，默认符号为加号。
+ step 2：遍历字符串，遇到数字，则将连续的数字字符部分转化为int型数字。
+ step 3：遇到左括号，则将括号后的部分送入递归，处理子问题；遇到右括号代表已经到了这个子问题的结尾，结束继续遍历字符串，将子问题的加法部分相加为一个数字，返回。
+ step 4：当遇到符号的时候如果是+，得到的数字正常入栈，如果是-，则将其相反数入栈，如果是*，则将栈中内容弹出与后一个元素相乘再入栈。
+ step 5：最后将栈中剩余的所有元素，进行一次全部相加。

```cpp
class Solution {
  public:
    vector<int> f(string s, int index) {
        stack<int> stack;
        int num = 0;
        char op = '+';
        int i;
        for (i = index; i < s.length(); i++) {
            //数字转换成int数字
            if(isdigit(s[i])) {
                num = num * 10 + s[i] - '0';
                if(i != s.length() - 1) continue;
            }
            //碰到'('时，把整个括号内的当成一个数字处理
            if(s[i] == '(') {
                //递归处理括号
                vector<int> res = f(s, i + 1);
                num = res[0];
                i =  res[1];
                if(i != s.length() - 1) continue;
            }
            switch (op) {
            //加减号先入栈
                case '+':
                    stack.push(num);
                    break;
                //相反数
                case '-':
                    stack.push(-num);
                    break;
                //优先计算乘号  
                case '*':
                    int tmp = stack.top();
                    stack.pop();
                    stack.push(tmp * num);
                    break;
            }
            num = 0;
            //右括号结束递归
            if(s[i] == ')') break;
            else op = s[i];
        }
        int sum = 0;
        //栈中元素相加
        while (!stack.empty()) {
            sum += stack.top();
            stack.pop();
        }
        return vector<int> {sum, i};
    }
    int solve(string s) {
        return f(s, 0)[0];
    }
};
```





## 哈希表

哈希表能解决什么问题呢，**一般哈希表都是用来快速判断一个元素是否出现集合里。**

当我们需要查询一个元素是否出现过，或者一个元素是否在集合里的时候，就要第一时间想到哈希法。

**Y总的模板-开放定址法**

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 200003, null = 0x3f3f3f3f;
int h[N];
int find(int x) {
	int k = (x % N + N) % N;
	while(h[k] != null && h[k] != x) {
		k++;
		if(k == N) k = 0;	
	}
	return k; 
}
int main(){
	int n;
    cin>>n;
	memset(h, 0x3f, sizeof h);
	while(n--) {
		char op[2];
		int x;
		scanf("%s%d", op, &x);
		int k = find(x);
		if(*op == 'I') h[k] = x;
		else {
			if(h[k] != null) puts("Yes");
			else puts("No");
		} 
	}
	return 0;
}
```

**Y总的模板-拉链法**

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 100003;
int h[N], e[N], ne[N], idx;
void insert(int x){
	int k = (x % N + N) % N;
	e[idx] = x;
	ne[idx] = h[k];
	h[k] = idx++;
}
bool find(int x){
	int k = ( x % N + N ) % N;
	for(int i = h[k]; i != -1; i = ne[i]){
		if(e[i] == k) return true;
	}
	return false;
}
int main(){
	int n;
    cin>>n;
	memset(h, -1, sizeof h);
	while(n--){
		char op[2];
		int x;
		scanf("%s%d", op, &x);
		if(*op == 'I') insert(x);
		else{
			if( find(x) ) puts("Yes");
			else puts("No");
		} 
	}
	return 0;
}
```

### 有效的字母异位词 

#### 相关链接

+ [242. 有效的字母异位词 ](https://leetcode.cn/problems/valid-anagram/)

#### 相关题目

给定两个字符串 `s` 和 `t` ，编写一个函数来判断 `t` 是否是 `s` 的字母异位词。

**注意：**若 `s` 和 `t` 中每个字符出现的次数都相同，则称 `s` 和 `t` 互为字母异位词。

**示例 1:**

```
输入: s = "anagram", t = "nagaram"
输出: true
```

#### 解题思路

**数组其实就是一个简单哈希表**，而且这道题目中字符串只有小写字符，那么就可以定义一个数组，来记录字符串s里字符出现的次数。

```cpp
class Solution {
public:
    bool isAnagram(string s, string t) {
        int record[26] = {0};
        for(int i = 0; i < s.size(); i++) record[s[i] - 'a']++;
        for(int i = 0; i < t.size(); i++) record[t[i] - 'a']--;
        for(int i = 0; i < 26; i++) if(record[i] != 0) return false;
        return true;        
    }
};
```

### 赎金信

#### 相关链接

+ [383. 赎金信 ](https://leetcode.cn/problems/ransom-note/)

#### 相关题目

给你两个字符串：`ransomNote` 和 `magazine` ，判断 `ransomNote` 能不能由 `magazine` 里面的字符构成。

如果可以，返回 `true` ；否则返回 `false` 。

`magazine` 中的每个字符只能在 `ransomNote` 中使用一次。

**示例 1：**

```
输入：ransomNote = "a", magazine = "b"
输出：false
```

#### 解题思路

因为题目所只有小写字母，那可以采用空间换取时间的哈希策略， 用一个长度为26的数组还记录magazine里字母出现的次数。

然后再用ransomNote去验证这个数组是否包含了ransomNote所需要的所有字母。

依然是数组在哈希法中的应用。

```cpp
class Solution {
public:
    bool canConstruct(string ransomNote, string magazine) {
        if(ransomNote.size() > magazine.size()) return false;
        int record[26] = {0};
        for(int i = 0; i < magazine.size(); i++) record[magazine[i] - 'a']++;
        for(int i = 0; i < ransomNote.size(); i++) {
            record[ransomNote[i] -'a']--;
            if(record[ransomNote[i] -'a'] < 0) return false;
        }
        return true;
    }
};
```

### 两个数组的交集

#### 相关链接

+ [349. 两个数组的交集 ](https://leetcode.cn/problems/intersection-of-two-arrays/)

#### 相关题目

给定两个数组 `nums1` 和 `nums2` ，返回 *它们的交集* 。输出结果中的每个元素一定是 **唯一** 的。我们可以 **不考虑输出结果的顺序** 。

**示例 1：**

```
输入：nums1 = [1,2,2,1], nums2 = [2,2]
输出：[2]
```

#### 解题思路

std::set和std::multiset底层实现都是红黑树，std::unordered_set的底层实现是哈希表， 使用unordered_set 读写效率是最高的，并不需要对数据进行排序，而且还不要让数据重复，所以选择unordered_set。

```cpp
class Solution {
public:
    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
        unordered_set<int> res_set;
        unordered_set<int> num1_set(nums1.begin(), nums1.end());
        for(int i = 0; i < nums2.size(); i++) {
            if(num1_set.find(nums2[i]) != num1_set.end()) res_set.insert(nums2[i]);
        }
        return vector<int>(res_set.begin(), res_set.end());
    }
};
```

### 快乐数

#### 相关链接

+ [202. 快乐数](https://leetcode.cn/problems/happy-number/)

#### 相关题目

编写一个算法来判断一个数 `n` 是不是快乐数。

**「快乐数」** 定义为：

+ 对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。
+ 然后重复这个过程直到这个数变为 1，也可能是 **无限循环** 但始终变不到 1。
+ 如果这个过程 **结果为** 1，那么这个数就是快乐数。

如果 `n` 是 *快乐数* 就返回 `true` ；不是，则返回 `false` 。

**示例 1：**

```
输入：n = 19
输出：true
解释：
12 + 92 = 82
82 + 22 = 68
62 + 82 = 100
12 + 02 + 02 = 1
```

#### 解题思路

```cpp
class Solution {
public:
    int getSum(int n){
        int sum = 0;
        while(n){
            sum += (n % 10) * (n % 10);
            n /= 10;
        }
        return sum;
    }
    bool isHappy(int n) {
        unordered_set<int> set;
        while(1){
            int sum = getSum(n);
            if(sum == 1) return true;
            if(set.find(sum) != set.end()) return false;
            else set.insert(sum);
            n = sum;
        }
    }
};
```

### 两数之和

#### 相关链接

+ [1. 两数之和](https://leetcode.cn/problems/two-sum/description/)

#### 相关题目

给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出 **和为目标值** *`target`* 的那 **两个** 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。

你可以按任意顺序返回答案。

**示例 1：**

```
输入：nums = [2,7,11,15], target = 9
输出：[0,1]
解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。
```

#### 解题思路

使用数组和set来做哈希法的局限。

+ 数组的大小是受限制的，而且如果元素很少，而哈希值太大会造成内存空间的浪费。
+ set是一个集合，里面放的元素只能是一个key，而两数之和这道题目，不仅要判断y是否存在而且还要记录y的下标位置，因为要返回x 和 y的下标。所以set 也不能用。

此时就要选择另一种数据结构：map ，map是一种key value的存储结构，可以用key保存数值，用value在保存数值所在的下标。

C++中map，有三种类型：

| 映射               | 底层实现 | 是否有序 | 数值是否可以重复 | 能否更改数值 | 查询效率 | 增删效率 |
| ------------------ | -------- | -------- | ---------------- | ------------ | -------- | -------- |
| std::map           | 红黑树   | key有序  | key不可重复      | key不可修改  | O(log n) | O(log n) |
| std::multimap      | 红黑树   | key有序  | key可重复        | key不可修改  | O(log n) | O(log n) |
| std::unordered_map | 哈希表   | key无序  | key不可重复      | key不可修改  | O(1)     | O(1)     |

std::unordered_map 底层实现为哈希表，std::map 和std::multimap 的底层实现是红黑树。

**这道题目中并不需要key有序，选择std::unordered_map 效率更高！**

```cpp
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int,int> hash;
        for(int i = 0; i < nums.size(); i++) hash[nums[i]] = i;
        for(int i = 0; i < nums.size(); i++)
            if(hash.find(target - nums[i]) != hash.end() && hash[target - nums[i]] != i)
                return {i, hash[target - nums[i]]};
        return {};
    }
};
```

**需要注意的是：**两数之和 不能使用双指针法，因为要求返回的是索引下标， 而双指针法一定要排序，一旦排序之后原数组的索引就被改变了。如果要求返回的是数值的话，就可以使用双指针法了。

### 四数相加 II

#### 相关链接

+ [454. 四数相加 II ](https://leetcode.cn/problems/4sum-ii/)

#### 相关题目

给你四个整数数组 `nums1`、`nums2`、`nums3` 和 `nums4` ，数组长度都是 `n` ，请你计算有多少个元组 `(i, j, k, l)` 能满足：

+ `0 <= i, j, k, l < n`
+ `nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0`

**示例 1：**

```
输入：nums1 = [1,2], nums2 = [-2,-1], nums3 = [-1,2], nums4 = [0,2]
输出：2
解释：
两个元组如下：
1. (0, 0, 0, 1) -> nums1[0] + nums2[0] + nums3[0] + nums4[1] = 1 + (-2) + (-1) + 2 = 0
2. (1, 1, 0, 0) -> nums1[1] + nums2[1] + nums3[0] + nums4[0] = 2 + (-1) + (-1) + 0 = 0
```

#### 解题思路

本题解题步骤：

1. 首先定义 一个unordered_map，key放a和b两数之和，value 放a和b两数之和出现的次数。
2. 遍历大A和大B数组，统计两个数组元素之和，和出现的次数，放到map中。
3. 定义int变量count，用来统计 a+b+c+d = 0 出现的次数。
4. 在遍历大C和大D数组，找到如果 0-(c+d) 在map中出现过的话，就用count把map中key对应的value也就是出现次数统计出来。
5. 最后返回统计值 count 就可以了

```cpp
class Solution {
public:
    int fourSumCount(vector<int>& A, vector<int>& B, vector<int>& C, vector<int>& D) {
        unordered_map<int, int> umap;
        for(int a : A)
            for(int b : B)
                umap[a + b]++;
        int cnt = 0;
        for(int c : C)
            for(int d : D)
                if(umap.find(0 - (c + d)) != umap.end())
                    cnt += umap[0 - (c + d)];
        return cnt;
    }
};
```

### 数组中出现次数超过一半的数字

#### 相关链接

+ [数组中出现次数超过一半的数字_牛客题霸](https://www.nowcoder.com/practice/e8a1b01a2df14cb2b228b30ee6a92163?tpId=295&tqId=23271&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26tab%3D%E7%AE%97%E6%B3%95%E7%AF%87%26topicId%3D295%26fromPut%3Dpc_kol_aaaxiu)

#### 相关题目

给一个长度为 n 的数组，数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。

例如输入一个长度为9的数组[1,2,3,2,2,2,5,4,2]。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。

#### 解题思路

Map或者是摩尔投票，Map思路就不说了

```cpp
class Solution {
public:
    int MoreThanHalfNum_Solution(vector<int> numbers) {
        int cad = numbers[0], cnt = 1;
        for(auto i : numbers) {
            if(cad == i) cnt++;
            else if(--cnt == 0) {
                cad = i;
                cnt = 1;
            }
        }
        return cad;
    }
};
```

### 无序数组中只出现一次的两个数字

#### 相关链接

+ 有序用双指针[剑指 Offer II 070. 排序数组中只出现一次的数字 ](https://leetcode.cn/problems/skFtm2/description/)
+ 无序用哈希 [数组中只出现一次的两个数字_牛客题霸_](https://www.nowcoder.com/practice/389fc1c3d3be4479a154f63f495abff8?tpId=295&tqId=1375231&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26tab%3D%E7%AE%97%E6%B3%95%E7%AF%87%26topicId%3D295%26fromPut%3Dpc_kol_aaaxiu)

#### 相关题目

一个整型数组里除了两个数字只出现一次，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。

#### 解题思路

```cpp
class Solution {
public:
    vector<int> FindNumsAppearOnce(vector<int>& array) {
        unordered_map<int, int> mp;
        vector<int> res;
        for(auto i : array) mp[i]++;
        for(auto i : mp){
            if(i.second == 1) res.push_back(i.first);
        } 
        sort(res.begin(), res.end());
        return res;
    }
};
```

### 缺失的第一个正整数

#### 相关链接

+ [缺失的第一个正整数_牛客题霸](https://www.nowcoder.com/practice/50ec6a5b0e4e45348544348278cdcee5?tpId=295&tqId=2188893&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26tab%3D%E7%AE%97%E6%B3%95%E7%AF%87%26topicId%3D295%26fromPut%3Dpc_kol_aaaxiu)

#### 相关题目

给定一个无重复元素的整数数组nums，请你找出其中没有出现的最小的正整数

#### 解题思路

```cpp
class Solution {
public:
    int minNumberDisappeared(vector<int>& nums) {
        unordered_map<int, int> mp;
        for(auto i : nums) mp[i]++;
        int res = 1;
        while(mp.find(res) != mp.end()) res++;
        return res;
    }
};
```

## 堆

### 理论部分

对于大顶堆来说，所有父节点的值要大于其子节点的值，即大顶堆的第一个结点是最大值

对于小顶堆来说，所有父节点的值要小于其子节点的值，即小顶堆的第一个结点是最小值

而他们的兄弟节点之间并无任何大小上的关联。

二叉搜索树才是左孩子小于父亲，右孩子大于父亲

堆兄弟结点都除以2是同一个值

建堆要从1开始

堆的父节点索引==子结点索引/2

### 最小的K个数

#### 相关链接

+ 最小的K个数

#### 相关题目

给定一个长度为 n 的可能有重复值的数组，找出其中不去重的最小的 k 个数。例如数组元素是4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4(任意顺序皆可)。

#### 解题思路

```cpp
class Solution {
public:
    vector<int> GetLeastNumbers_Solution(vector<int> input, int k) {
        vector<int> res;
        if(k == 0 || input.size() == 0) return res;
        priority_queue<int> q;
        for(int i = 0 ;i < k; i++) q.push(input[i]);
        for(int i = k; i < input.size(); i++) {
            if(q.top() > input[i]) {
                q.pop();
                q.push(input[i]);
            }
        }
        for(int i = 0; i < k; i++) {
            res.push_back(q.top());
            q.pop();
        }
        reverse(res.begin(), res.end());
        return res;
    }
};
```

### 前 K 个高频元素

#### 相关链接

+ [347. 前 K 个高频元素 ](https://leetcode.cn/problems/top-k-frequent-elements/)
+ [692. 前K个高频单词 ](https://leetcode.cn/problems/top-k-frequent-words/)
+ [剑指 Offer II 059. 数据流的第 K 大数值](https://leetcode.cn/problems/jBjn9C/description/)
+ [剑指 Offer II 060. 出现频率最高的 k 个数字 ](https://leetcode.cn/problems/g5c51o/)

#### 相关题目

给你一个整数数组 `nums` 和一个整数 `k` ，请你返回其中出现频率前 `k` 高的元素。你可以按 **任意顺序** 返回答案。

**示例 1:**

```
输入: nums = [1,1,1,2,2,3], k = 2
输出: [1,2]
```

#### 解题思路

[347. 前 K 个高频元素 ](https://leetcode.cn/problems/top-k-frequent-elements/)

[剑指 Offer II 060. 出现频率最高的 k 个数字 ](https://leetcode.cn/problems/g5c51o/)

**写法1-使用快排**

```cpp
class Solution {
public:
    vector<int> topKFrequent(vector<int>& nums, int k) {
        if(nums.size() == 0) return {};
        
        vector<pair<int,int>> vc;
        vector<int> ans;
        unordered_map<int,int> mp;
        
        for(int i = 0; i < nums.size(); i++) mp[nums[i]]++;
        for(auto i : mp) vc.push_back({i.second,i.first});
        
        sort(vc.begin(), vc.end());
        for(int i = vc.size() - 1; i >= vc.size() - k && i >= 0; i--) ans.push_back(vc[i].second);

        return ans;
    }
};
```

**写法2-优先队列**

这道题目主要涉及到如下三块内容：

1. 要统计元素出现频率
2. 对频率排序
3. 找出前K个高频元素

三个步骤如下：

1、首先统计元素出现的频率，这一类的问题可以使用map来进行统计。

2、然后是对频率进行排序，这里我们可以使用一种 容器适配器就是**优先级队列即堆**。

**堆是一棵完全二叉树，树中每个结点的值都不小于（或不大于）其左右孩子的值。** 为什么不用快排呢， 使用快排要将map转换为vector的结构，然后对整个数组进行排序， 而这种场景下，我们其实只需要维护k个有序的序列就可以了，所以使用优先级队列是最优的。

3、找出前K个高频元素，如果定义一个大小为k的大顶堆，在每次移动更新大顶堆的时候，每次弹出都把最大的元素弹出去了，那么怎么保留下来前K个高频元素呢。而且使用大顶堆就要把所有元素都进行排序，那能不能只排序k个元素呢？

**所以我们要用小顶堆，因为要统计最大前k个元素，只有小顶堆每次将最小的元素弹出，最后小顶堆里积累的才是前k个最大元素。**

```cpp
// 时间复杂度：O(nlogk)
// 空间复杂度：O(n)
class Solution {
public:
    // 小顶堆
    class mycomparison {
    public:
        bool operator()(const pair<int, int>& lhs, const pair<int, int>& rhs) {
            return lhs.second > rhs.second;
        }
    };
    vector<int> topKFrequent(vector<int>& nums, int k) {
        // 要统计元素出现频率
        unordered_map<int, int> map; // map<nums[i],对应出现的次数>
        for (int i = 0; i < nums.size(); i++) {
            map[nums[i]]++;
        }

        // 对频率排序
        // 定义一个小顶堆，大小为k
        priority_queue<pair<int, int>, vector<pair<int, int>>, mycomparison> pri_que;

        // 用固定大小为k的小顶堆，扫所有频率的数值
        for (unordered_map<int, int>::iterator it = map.begin(); it != map.end(); it++) {
            pri_que.push(*it);
            if (pri_que.size() > k) { // 如果堆的大小大于了K，则队列弹出，保证堆的大小一直为k
                pri_que.pop();
            }
        }

        // 找出前K个高频元素，因为小顶堆先弹出的是最小的，所以倒序来输出到数组
        vector<int> result(k);
        for (int i = k - 1; i >= 0; i--) {
            result[i] = pri_que.top().first;
            pri_que.pop();
        }
        return result;

    }
};
```

[剑指 Offer II 059. 数据流的第 K 大数值](https://leetcode.cn/problems/jBjn9C/description/)

```cpp
class KthLargest {
public:
    priority_queue<int,vector<int>,greater<int>> q;
    int k;
    KthLargest(int k, vector<int>& nums) {
        this->k = k;
        for(auto &x : nums) add(x);
    }
    
    int add(int val) {
        q.push(val);
        if(q.size()>k) q.pop();
        return q.top();
    }
};
```

[692. 前K个高频单词 ](https://leetcode.cn/problems/top-k-frequent-words/)

```cpp
class Solution {
public:
    class mycomparison {
    public:
        bool operator()(const pair<string, int>&lhs, const pair<string, int>& rhs) {
            if(lhs.second == rhs.second) return lhs.first < rhs.first;
            return lhs.second > rhs.second;
        }
    };
    vector<string> topKFrequent(vector<string>& nums, int k) {
        unordered_map<string, int> mp;
        for(int i = 0; i < nums.size(); i++) mp[nums[i]]++;
        
        priority_queue<pair<string, int>,vector<pair<string, int>>, mycomparison> pri_que;
        
        for(unordered_map<string, int> :: iterator it = mp.begin(); it != mp.end(); it++){
            pri_que.push(*it);
            if(pri_que.size() > k) pri_que.pop();
        }

        vector<string> res(k);
        for(int i = k - 1; i >= 0; i--) {
            res[i] = pri_que.top().first;
            pri_que.pop();
        }
        return res;
    }
};
```

## 单调队列

### 滑动窗口最大值

#### 相关链接

+ [239. 滑动窗口最大值](https://leetcode.cn/problems/sliding-window-maximum/description/)

#### 相关题目

给你一个整数数组 `nums`，有一个大小为 `k` 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 `k` 个数字。滑动窗口每次只向右移动一位。

返回 *滑动窗口中的最大值* 。

**示例 1：**

```
输入：nums = [1,3,-1,-3,5,3,6,7], k = 3
输出：[3,3,5,5,6,7]
解释：
滑动窗口的位置                最大值
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7
```

#### 解题思路

设计单调队列的时候，pop，和push操作要保持如下规则：

1. pop(value)：如果窗口移除的元素value等于单调队列的出口元素，那么队列弹出元素，否则不用任何操作
2. push(value)：如果push的元素value大于入口元素的数值，那么就将队列入口的元素弹出，直到push元素的数值小于等于队列入口元素的数值为止

保持如上规则，每次窗口移动的时候，只要que.front()就可以返回当前窗口的最大值。

```cpp
class Solution {
private:
    class MyQueue { //单调队列（从大到小）
    public:
        deque<int> que; // 使用deque来实现单调队列
        // 每次弹出的时候，比较当前要弹出的数值是否等于队列出口元素的数值，如果相等则弹出。
        // 同时pop之前判断队列当前是否为空。
        void pop(int value) {
            if (!que.empty() && value == que.front()) {
                que.pop_front();
            }
        }
        // 如果push的数值大于入口元素的数值，那么就将队列后端的数值弹出，直到push的数值小于等于队列入口元素的数值为止。
        // 这样就保持了队列里的数值是单调从大到小的了。
        void push(int value) {
            while (!que.empty() && value > que.back()) {
                que.pop_back();
            }
            que.push_back(value);
        }
        // 查询当前队列里的最大值 直接返回队列前端也就是front就可以了。
        int front() {
            return que.front();
        }
    };
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        if(k == 0 || num.size() < k) return {};
        MyQueue que;
        vector<int> result;
        for (int i = 0; i < k; i++) { // 先将前k的元素放进队列
            que.push(nums[i]);
        }
        result.push_back(que.front()); // result 记录前k的元素的最大值
        for (int i = k; i < nums.size(); i++) {
            que.pop(nums[i - k]); // 滑动窗口移除最前面元素
            que.push(nums[i]); // 滑动窗口前加入最后面的元素
            result.push_back(que.front()); // 记录对应的最大值
        }
        return result;
    }
};
```

## 单调栈

### 每日温度

#### 相关链接

+ [739. 每日温度 ](https://leetcode.cn/problems/daily-temperatures/)

#### 相关题目

给定一个整数数组 `temperatures` ，表示每天的温度，返回一个数组 `answer` ，其中 `answer[i]` 是指对于第 `i` 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 `0` 来代替。

**示例 1:**

```
输入: temperatures = [73,74,75,71,69,72,76,73]
输出: [1,1,4,2,1,1,0,0]
```

#### 解题思路

​	首先想到的当然是暴力解法，两层for循环，把至少需要等待的天数就搜出来了。时间复杂度是O(n^2)，那么接下来在来看看使用单调栈的解法。**通常是一维数组，要寻找任一个元素的右边或者左边第一个比自己大或者小的元素的位置，此时我们就要想到可以用单调栈了**，时间复杂度为O(n)。

​	单调栈的本质是空间换时间，因为在遍历的过程中需要用一个栈来记录右边第一个比当前元素高的元素，优点是只需要遍历一次。在使用单调栈的时候首先要明确如下几点：

1. 单调栈里存放的元素是什么？

单调栈里只需要存放元素的下标i就可以了，如果需要使用对应的元素，直接T[i]就可以获取。

2. 单调栈里元素是递增的**注意一下顺序为 从栈头到栈底的顺序**。

```cpp
class Solution {
public:
    vector<int> dailyTemperatures(vector<int>& T) {
        // 递增栈
        stack<int> st;
        vector<int> result(T.size(), 0);
        st.push(0);
        for (int i = 1; i < T.size(); i++) {
            if (T[i] < T[st.top()]) {                       // 情况一
                st.push(i);
            } else if (T[i] == T[st.top()]) {               // 情况二
                st.push(i);
            } else {
                while (!st.empty() && T[i] > T[st.top()]) { // 情况三
                    result[st.top()] = i - st.top();
                    st.pop();
                }
                st.push(i);
            }
        }
        return result;
    }
};
```

### 下一个更大元素 I

#### 相关链接

+ [496. 下一个更大元素 I](https://leetcode.cn/problems/next-greater-element-i/)

#### 相关题目

`nums1` 中数字 `x` 的 **下一个更大元素** 是指 `x` 在 `nums2` 中对应位置 **右侧** 的 **第一个** 比 `x` 大的元素。

给你两个 **没有重复元素** 的数组 `nums1` 和 `nums2` ，下标从 **0** 开始计数，其中`nums1` 是 `nums2` 的子集。

对于每个 `0 <= i < nums1.length` ，找出满足 `nums1[i] == nums2[j]` 的下标 `j` ，并且在 `nums2` 确定 `nums2[j]` 的 **下一个更大元素** 。如果不存在下一个更大元素，那么本次查询的答案是 `-1` 。

返回一个长度为 `nums1.length` 的数组 `ans` 作为答案，满足 `ans[i]` 是如上所述的 **下一个更大元素** 。

**示例 1：**

```
输入：nums1 = [4,1,2], nums2 = [1,3,4,2].
输出：[-1,3,-1]
解释：nums1 中每个值的下一个更大元素如下所述：
- 4 ，用加粗斜体标识，nums2 = [1,3,4,2]。不存在下一个更大元素，所以答案是 -1 。
- 1 ，用加粗斜体标识，nums2 = [1,3,4,2]。下一个更大元素是 3 。
- 2 ，用加粗斜体标识，nums2 = [1,3,4,2]。不存在下一个更大元素，所以答案是 -1 。
```

#### 解题思路

本题和739. 每日温度是一样的。

栈头到栈底的顺序，要从小到大，也就是保持栈里的元素为递增顺序。只要保持递增，才能找到右边第一个比自己大的元素。

1. 情况一：当前遍历的元素T[i]小于栈顶元素T[st.top()]的情况

   此时满足递增栈（栈头到栈底的顺序），所以直接入栈。

2. 情况二：当前遍历的元素T[i]等于栈顶元素T[st.top()]的情况

   如果相等的话，依然直接入栈，因为我们要求的是右边第一个比自己大的元素，而不是大于等于！

3. 情况三：当前遍历的元素T[i]大于栈顶元素T[st.top()]的情况

   此时如果入栈就不满足递增栈了，这也是找到右边第一个比自己大的元素的时候。

   判断栈顶元素是否在nums1里出现过，（注意栈里的元素是nums2的元素），如果出现过，开始记录结果。

```cpp
class Solution {
public:
    vector<int> nextGreaterElement(vector<int>& nums1, vector<int>& nums2) {
        stack<int> st;
        vector<int> result(nums1.size(), -1);
        if (nums1.size() == 0) return result;

        unordered_map<int, int> umap; // key:下标元素，value：下标
        for (int i = 0; i < nums1.size(); i++) {
            umap[nums1[i]] = i;
        }
        st.push(0);
        for (int i = 1; i < nums2.size(); i++) {
            if (nums2[i] < nums2[st.top()]) {           // 情况一
                st.push(i);
            } else if (nums2[i] == nums2[st.top()]) {   // 情况二
                st.push(i);
            } else {                                    // 情况三
                while (!st.empty() && nums2[i] > nums2[st.top()]) {
                    if (umap.count(nums2[st.top()]) > 0) { // 看map里是否存在这个元素
                        int index = umap[nums2[st.top()]]; // 根据map找到nums2[st.top()] 在 nums1中的下标
                        result[index] = nums2[i];
                    }
                    st.pop();
                }
                st.push(i);
            }
        }
        return result;
    }
};
```

### 下一个更大元素 II

#### 相关链接

+ [503. 下一个更大元素 II ](https://leetcode.cn/problems/next-greater-element-ii/)

#### 相关题目

给定一个循环数组 `nums` （ `nums[nums.length - 1]` 的下一个元素是 `nums[0]` ），返回 *`nums` 中每个元素的 **下一个更大元素*** 。

数字 `x` 的 **下一个更大的元素** 是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 `-1` 。

**示例 1:**

```
输入: nums = [1,2,1]
输出: [2,-1,2]
解释: 第一个 1 的下一个更大的数是 2；
数字 2 找不到下一个更大的数； 
第二个 1 的下一个最大的数需要循环搜索，结果也是 2。
```

#### 解题思路

**写法1**

将两个nums数组拼接在一起，使用单调栈计算出每一个元素的下一个最大值，最后再把结果集即result数组resize到原数组大小就可以了。

```cpp
class Solution {
public:
    vector<int> nextGreaterElements(vector<int>& nums) {
        // 拼接一个新的nums
        vector<int> nums1(nums.begin(), nums.end());
        nums.insert(nums.end(), nums1.begin(), nums1.end());
        // 用新的nums大小来初始化result
        vector<int> result(nums.size(), -1);
        if (nums.size() == 0) return result;

        // 开始单调栈
        stack<int> st;
        for (int i = 0; i < nums.size(); i++) {
            while (!st.empty() && nums[i] > nums[st.top()]) {
                result[st.top()] = nums[i];
                st.pop();
            }
            st.push(i);
        }
        // 最后再把结果集即result数组resize到原数组大小
        result.resize(nums.size() / 2);
        return result;
    }
};
```

**写法2**

```cpp
class Solution {
public:
    vector<int> nextGreaterElements(vector<int>& nums) {
        vector<int> result(nums.size(), -1);
        if (nums.size() == 0) return result;
        stack<int> st;
        for (int i = 0; i < nums.size() * 2; i++) {
            // 模拟遍历两边nums，注意一下都是用i % nums.size()来操作
            while (!st.empty() && nums[i % nums.size()] > nums[st.top()]) {
                result[st.top()] = nums[i % nums.size()];
                st.pop();
            }
            st.push(i % nums.size());
        }
        return result;
    }
};
```

### 接雨水

#### 相关链接

+ [42. 接雨水](https://leetcode.cn/problems/trapping-rain-water/)

#### 相关题目

给定 `n` 个非负整数表示每个宽度为 `1` 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。

**示例 1：**

<img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png" style="zoom:80%;box-shadow:rgba(0,0,0,0) 0 0px 0px 0px;" />

```
输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]
输出：6
解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 
```

#### 解题思路

**写法1-双指针**

[代码随想录-双指针写法](https://programmercarl.com/0042.接雨水.html#暴力解法)

**如果按照列来计算的话，宽度一定是1了，我们再把每一列的雨水的高度求出来就可以了。**

可以看出每一列雨水的高度，取决于，该列 左侧最高的柱子和右侧最高的柱子中最矮的那个柱子的高度。

列4 左侧最高的柱子是列3，高度为2（以下用lHeight表示）。

列4 右侧最高的柱子是列7，高度为3（以下用rHeight表示）。

列4 柱子的高度为1（以下用height表示）

那么列4的雨水高度为 列3和列7的高度最小值减列4高度，即： min(lHeight, rHeight) - height。

列4的雨水高度求出来了，宽度为1，相乘就是列4的雨水体积了。

整体代码如下：

```cpp
class Solution {
public:
    int trap(vector<int>& height) {
        int sum = 0;
        for (int i = 0; i < height.size(); i++) {
            // 第一个柱子和最后一个柱子不接雨水
            if (i == 0 || i == height.size() - 1) continue;

            int rHeight = height[i]; // 记录右边柱子的最高高度
            int lHeight = height[i]; // 记录左边柱子的最高高度
            for (int r = i + 1; r < height.size(); r++) {
                if (height[r] > rHeight) rHeight = height[r];
            }
            for (int l = i - 1; l >= 0; l--) {
                if (height[l] > lHeight) lHeight = height[l];
            }
            int h = min(lHeight, rHeight) - height[i];
            if (h > 0) sum += h;
        }
        return sum;
    }
};
```

因为每次遍历列的时候，还要向两边寻找最高的列，所以时间复杂度为O(n^2)。 空间复杂度为O(1)，这种解法过不了全部用例。

在暴力解法中，我们可以看到只要记录左边柱子的最高高度 和 右边柱子的最高高度，就可以计算当前位置的雨水面积，这就是通过列来计算。

当前列雨水面积：min(左边柱子的最高高度，记录右边柱子的最高高度) - 当前柱子高度。

为了得到两边的最高高度，使用了双指针来遍历，每到一个柱子都向两边遍历一遍，这其实是有重复计算的。我们把每一个位置的左边最高高度记录在一个数组上（maxLeft），右边最高高度记录在一个数组上（maxRight），这样就避免了重复计算。

当前位置，左边的最高高度是前一个位置的左边最高高度和本高度的最大值。

即从左向右遍历：maxLeft[i] = max(height[i], maxLeft[i - 1]);

从右向左遍历：maxRight[i] = max(height[i], maxRight[i + 1]);

代码如下：

```cpp
class Solution {
public:
    int trap(vector<int>& height) {
        if (height.size() <= 2) return 0;
        vector<int> maxLeft(height.size(), 0);
        vector<int> maxRight(height.size(), 0);
        int size = maxRight.size();

        // 记录每个柱子左边柱子最大高度
        maxLeft[0] = height[0];
        for (int i = 1; i < size; i++) {
            maxLeft[i] = max(height[i], maxLeft[i - 1]);
        }
        // 记录每个柱子右边柱子最大高度
        maxRight[size - 1] = height[size - 1];
        for (int i = size - 2; i >= 0; i--) {
            maxRight[i] = max(height[i], maxRight[i + 1]);
        }
        // 求和
        int sum = 0;
        for (int i = 0; i < size; i++) {
            int count = min(maxLeft[i], maxRight[i]) - height[i];
            if (count > 0) sum += count;
        }
        return sum;
    }
};
```

**写法2-动态规划**

在上一节的双指针解法中，我们可以看到只要记录左边柱子的最高高度 和 右边柱子的最高高度，就可以计算当前位置的雨水面积，这就是通过列来计算。

当前列雨水面积：min(左边柱子的最高高度，记录右边柱子的最高高度) - 当前柱子高度。

为了得到两边的最高高度，使用了双指针来遍历，每到一个柱子都向两边遍历一遍，这其实是有重复计算的。我们把每一个位置的左边最高高度记录在一个数组上（maxLeft），右边最高高度记录在一个数组上（maxRight）。这样就避免了重复计算，这就用到了动态规划。

当前位置，左边的最高高度是前一个位置的左边最高高度和本高度的最大值。

即从左向右遍历：maxLeft[i] = max(height[i], maxLeft[i - 1]);

从右向左遍历：maxRight[i] = max(height[i], maxRight[i + 1]);

这样就找到递推公式。

代码如下：

```cpp
class Solution {
public:
    int trap(vector<int>& height) {
        if(height.size() <= 2) return 0;
        vector<int> maxLeft(height.size(), 0);
        vector<int> maxRight(height.size(), 0);
        int size = maxRight.size();

        maxLeft[0] = height[0];
        for(int i = 1; i < size; i++)
            maxLeft[i] = max(height[i], maxLeft[i - 1]);
        maxRight[size - 1] = height[size - 1];
        for(int i = size - 2; i >= 0; i--)
            maxRight[i] = max(height[i], maxRight[i + 1]);
        int sum = 0;
        for(int i = 0; i < size; i++){
            int cnt = min(maxLeft[i], maxRight[i]) - height[i];
            if(cnt > 0) sum += cnt;
        }
        return sum;
    }
};
```

**写法3-单调栈**

```

```



### 柱状图中最大的矩形

#### 相关链接

+ [84. 柱状图中最大的矩形](https://leetcode.cn/problems/largest-rectangle-in-histogram/)

#### 相关题目

给定 *n* 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。

求在该柱状图中，能够勾勒出来的矩形的最大面积。

**示例 1:**

<img src="https://assets.leetcode.com/uploads/2021/01/04/histogram.jpg"  style="zoom:80%;box-shadow:rgba(0,0,0,0) 0 0px 0px 0px;" />

```
输入：heights = [2,1,5,6,2,3]
输出：10
解释：最大的矩形为图中红色区域，面积为 10
```

#### 解题思路

**写法1-双指针**

```cpp
class Solution {
public:
    int largestRectangleArea(vector<int>& heights) {
        int sum = 0;
        for (int i = 0; i < heights.size(); i++) {
            int left = i;
            int right = i;
            for (; left >= 0; left--) {
                if (heights[left] < heights[i]) break;
            }
            for (; right < heights.size(); right++) {
                if (heights[right] < heights[i]) break;
            }
            int w = right - left - 1;
            int h = heights[i];
            sum = max(sum, w * h);
        }
        return sum;
    }
};
```

**写法2-动态规划**

本题要记录记录每个柱子 左边第一个小于该柱子的下标，而不是左边第一个小于该柱子的高度。

所以需要循环查找，也就是下面在寻找的过程中使用了while，

```cpp
class Solution {
public:
    int largestRectangleArea(vector<int>& heights) {
        vector<int> minLeftIndex(heights.size());
        vector<int> minRightIndex(heights.size());
        int size = heights.size();

        // 记录每个柱子 左边第一个小于该柱子的下标
        minLeftIndex[0] = -1; // 注意这里初始化，防止下面while死循环
        for (int i = 1; i < size; i++) {
            int t = i - 1;
            // 这里不是用if，而是不断向左寻找的过程
            while (t >= 0 && heights[t] >= heights[i]) t = minLeftIndex[t];
            minLeftIndex[i] = t;
        }
        // 记录每个柱子 右边第一个小于该柱子的下标
        minRightIndex[size - 1] = size; // 注意这里初始化，防止下面while死循环
        for (int i = size - 2; i >= 0; i--) {
            int t = i + 1;
            // 这里不是用if，而是不断向右寻找的过程
            while (t < size && heights[t] >= heights[i]) t = minRightIndex[t];
            minRightIndex[i] = t;
        }
        // 求和
        int result = 0;
        for (int i = 0; i < size; i++) {
            int sum = heights[i] * (minRightIndex[i] - minLeftIndex[i] - 1);
            result = max(sum, result);
        }
        return result;
    }
};
```

**写法3-单调栈**

```

```

## LRU缓存-高频

#### 相关链接

+ [146. LRU 缓存 ](https://leetcode.cn/problems/lru-cache/)

+ [剑指 Offer II 031. 最近最少使用缓存](https://leetcode.cn/problems/OrIXps/description/)

#### 相关题目

运用所掌握的数据结构，设计和实现一个 LRU (Least Recently Used，最近最少使用) 缓存机制。

实现 `LRUCache` 类：

+ `LRUCache(int capacity)` 以正整数作为容量 `capacity` 初始化 LRU 缓存
+ `int get(int key)` 如果关键字 `key` 存在于缓存中，则返回关键字的值，否则返回 `-1` 。
+ `void put(int key, int value)` 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字-值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。

#### 解题思路

自己定义哈希双向链表

1、如果我们每次默认从**链表头部添加元素**，那么显然越靠头部的元素就是最近使用的，越靠尾部的元素就是最久未使用的。

2、对于某一个 `key`，我们可以通过哈希表快速定位到链表中的节点，从而取得对应 `val`。

3、链表显然是支持在任意位置快速插入和删除的，改改指针就行。只不过传统的链表无法按照索引快速访问某一个位置的元素，而这里借助哈希表，可以通过 `key` 快速映射到任意一个链表节点，然后进行插入和删除。

<img src="https://labuladong.gitee.io/algo/images/LRU%e7%ae%97%e6%b3%95/4.jpg" alt="示例1" style="zoom:50%;box-shadow:rgba(0,0,0,0) 0 0px 0px 0px;" />

对于 get 操作，首先判断 key 是否存在：

+ 如果 key 不存在，则返回 −1；

+ 如果 key 存在，则 key 对应的节点是最近被使用的节点。

  （1）通过哈希表定位到该节点在双向链表中的位置

  （2）将其移动到双向链表的头部，

  （3）最后返回该节点的值。

对于 put 操作，首先判断 key 是否存在：

+ 如果 key 不存在

  （1）使用 key 和 value 创建一个新的节点

  （2）在双向链表的头部添加该节点

  （3）并将 key 和该节点添加进哈希表中

  （4）判断双向链表的节点数是否超出容量

  （5）如果超出容量则删除双向链表的尾部节点，并删除哈希表中对应的项；

+ 如果 key 存在，则与 get 操作类似

  （1）通过哈希表定位

  （2）将对应的节点的值更新为 value

  （3）并将该节点移到双向链表的头部。

上述各项操作中，访问哈希表的时间复杂度为 O(1)，在双向链表的头部添加节点、在双向链表的尾部删除节点的复杂度也为 O(1)。

而将一个节点移到双向链表的头部，可以分成「删除该节点」和「在双向链表的头部添加节点」两步操作，都可以在 O(1) 时间内完成。

```cpp
struct DLinkedNode {
    int key, value;
    DLinkedNode* prev;
    DLinkedNode* next;
    DLinkedNode(): key(0), value(0), prev(nullptr), next(nullptr) {}
    DLinkedNode(int _key, int _value): key(_key), value(_value), prev(nullptr), next(nullptr) {}
};
class LRUCache {
private:
    unordered_map<int, DLinkedNode*> cache;
    DLinkedNode* head;
    DLinkedNode* tail;
    int size;
    int capacity;
public:
    //LRUCache(int _capacity): capacity(_capacity), size(0) {
        // LRUCache(int _capacity): capacity(_capacity), size(0) {
        // 等于 capacity = _capacity; size = 0;
        // head = new DLinkedNode();
        // tail = new DLinkedNode();
        // head->next = tail;
        // tail->prev = head;
    //}
     LRUCache(int _capacity){
        capacity = _capacity; 
        size = 0;
        head = new DLinkedNode();
        tail = new DLinkedNode();
        head->next = tail;
        tail->prev = head;
    }
    int get(int key) {
        if (!cache.count(key)) return -1;
        DLinkedNode* node = cache[key];
        moveToHead(node);
        return node->value;
    }
    void put(int key, int value) {
        if (!cache.count(key)) {
            DLinkedNode* node = new DLinkedNode(key, value);
            cache[key] = node;
            addToHead(node);
            ++size;
            if (size > capacity) {
                DLinkedNode* removed = removeTail();
                cache.erase(removed->key);
                delete removed;
                --size;
            }
        }
        else {
            DLinkedNode* node = cache[key];
            node->value = value;
            moveToHead(node);
        }
    }
    void moveToHead(DLinkedNode* node) {
        removeNode(node);
        addToHead(node);
    }
    void addToHead(DLinkedNode* node) {
        node->prev = head;
        node->next = head->next;
        head->next->prev = node;
        head->next = node;
    }
    void removeNode(DLinkedNode* node) {
        node->prev->next = node->next;
        node->next->prev = node->prev;
    }

    DLinkedNode* removeTail() {
        DLinkedNode* node = tail->prev;
        removeNode(node);
        return node;
    }
};
```

## LFU缓存

#### 相关链接

+ 

#### 相关题目



#### 解题思路

