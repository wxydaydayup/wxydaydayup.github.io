---
rauthor: WangXinYi
img: /images/homePage/双指针.webp
summary: 算法-双指针
categories:
  - 算法
  - C++
  - 双指针
tags:
  - 算法
  - C++
  - 双指针
top: false
typora-root-url: ..
date: 2021-10-20 12:06:57
---

# 双指针

### 移除元素-快慢指针

#### 相关链接

+ [26. 删除有序数组中的重复项 ](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/description/)
+ [27. 移除元素](https://leetcode.cn/problems/remove-element/)
+ [283. 移动零 ](https://leetcode.cn/problems/move-zeroes/description/)

#### 相关题目

给你一个数组 `nums` 和一个值 `val`，你需要 原地 移除所有数值等于 `val` 的元素，并返回移除后数组的新长度。

不要使用额外的数组空间，你必须仅使用 `O(1)` 额外空间并 原地 修改输入数组。

元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。

**说明:**

为什么返回数值是整数，但输出的答案是数组呢?

请注意，输入数组是以**「引用」**方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。

你可以想象内部操作如下:

```
// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝
int len = removeElement(nums, val);

// 在函数里修改输入数组对于调用者是可见的。
// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。
for (int i = 0; i < len; i++) {
    print(nums[i]);
}
```

#### 解题思路

双指针法

**写法1-快慢指针法**

快慢指针法： **通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。**

定义快慢指针

+ 快指针：寻找新数组的元素 ，新数组就是不含有目标元素的数组
+ 慢指针：指向更新 新数组下标的位置

这道题 慢指针 和 快指针 都是从0开始的

```cpp
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        int slowIndex = 0;
        for(int fastIndex = 0; fastIndex < nums.size(); fastIndex++){
            if(nums[fastIndex] != val){
                nums[slowIndex++] = nums[fastIndex];
                //nums[slowIndex] = nums[fastIndex];
            	//slowIndex++;
            }
        }
        return slowIndex;
    }
};
```

**写法2-相向双指针法**

由于题意元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。

相向双指针方法，基于元素顺序可以改变的题目描述改变了元素相对位置，确保了移动最少元素

```cpp
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        int leftIndex = 0;
        int rightIndex = nums.size() - 1;
        while(leftIndex <= rightIndex){
            while(leftIndex <= rightIndex && nums[leftIndex] != val) ++leftIndex;
            while(leftIndex <= rightIndex && nums[rightIndex] == val) --rightIndex;
            if(leftIndex < rightIndex) nums[leftIndex++] = nums[rightIndex--];
        }
        return leftIndex;
    }
};
```

[26. 删除有序数组中的重复项 ](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/description/)

```cpp
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        int slowIndex = 0;
        for(int fastIndex = 1; fastIndex < nums.size(); fastIndex++){
            if(nums[slowIndex] != nums[fastIndex]){
                nums[slowIndex + 1] = nums[fastIndex];
                slowIndex++;
                //以下写法也可以
                //slowIndex++;
                //nums[slowIndex] = nums[fastIndex];
            }
        }
        return slowIndex + 1;
    }
};
```

[283. 移动零 ](https://leetcode.cn/problems/move-zeroes/description/)

```
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        int slowIndex = 0;
        for(int fastIndex = 0; fastIndex < nums.size(); fastIndex++){
            if(nums[fastIndex]){
                swap(nums[slowIndex], nums[fastIndex]);
                slowIndex++;
            }
        }
        return;
    }
};

```

### 比较含退格字符串-快慢指针

#### 相关链接

+ [844. 比较含退格的字符串 ](https://leetcode.cn/problems/backspace-string-compare/description/)

#### 相关题目

给定 `s` 和 `t` 两个字符串，当它们分别被输入到空白的文本编辑器后，如果两者相等，返回 `true` 。`#` 代表退格字符。

**注意：**如果对空文本输入退格字符，文本继续为空。

**示例 1：**

```
输入：s = "ab#c", t = "ad#c"
输出：true
解释：s 和 t 都会变成 "ac"。
```

**示例 2：**

```
输入：s = "ab##", t = "c#d#"
输出：true
解释：s 和 t 都会变成 ""。
```

**示例 3：**

```
输入：s = "a#c", t = "b"
输出：false
解释：s 会变成 "c"，但 t 仍然是 "b"。
```

#### 解题思路

**写法1-双指针法**

```cpp
class Solution {
public:
    bool backspaceCompare(string S, string T) {
        int i = S.size() - 1, j = T.size() - 1;
        int skipS = 0, skipT = 0;
        while (i >= 0 || j >= 0){
            while (i >= 0){
                if (S[i] == '#'){
                    skipS++, i--;
                } else if (skipS > 0){
                    skipS--, i--;
                } else break;
            }
            while (j >= 0){
                if (T[j] == '#'){
                    skipT++, j--;
                } else if (skipT > 0){
                    skipT--, j--;
                } else break;
            }    
            if (i >= 0 && j >=0){
                if(S[i] != T[j]) return false;
            } else {
                if(i >= 0 || j >= 0) return false; 
            }     
            i--, j--;
        }
        return true;
    }
};
```

**写法2-重构字符串**

```cpp
class Solution {
public:
    bool backspaceCompare(string S, string T) {
        return compare(S) == compare(T);
    }
    string compare(string s){
        string str;
        for(char c: s){
            if(c != '#'){
                str.push_back(c);
            } else if (!str.empty()){
                str.pop_back();
            } 
        }
        return str;
    }
};
```

### 有序数组的平方-相向指针

#### 相关链接

+ [977. 有序数组的平方 ](https://leetcode.cn/problems/squares-of-a-sorted-array/)

#### 相关题目

给你一个按 **非递减顺序** 排序的整数数组 `nums`，返回 **每个数字的平方** 组成的新数组，要求也按 **非递减顺序** 排序。

**示例 1：**

```
输入：nums = [-4,-1,0,3,10]
输出：[0,1,9,16,100]
解释：平方后，数组变为 [16,1,0,9,100]
排序后，数组变为 [0,1,9,16,100]
```

**示例 2：**

```
输入：nums = [-7,-3,2,3,11]
输出：[4,9,9,49,121]
```

#### 解题思路

```cpp
class Solution {
public:
    vector<int> sortedSquares(vector<int>& nums) {
        int k = nums.size() - 1;
        vector<int> res(nums.size(), 0);
        for (int i = 0, j = nums.size() - 1; i <= j;) {
            if (nums[i] * nums[i] < nums[j] * nums[j]) {
                res[k--] = nums[j] * nums[j];
                j--;
            } else {
                res[k--] = nums[i] * nums[i];
                i++;                
            }
        }
        return res;
    }
};
```

### 三数之和-相向指针

#### 相关链接

+ [15. 三数之和 ](https://leetcode.cn/problems/3sum/)

+ [167. 两数之和 II - 输入有序数组](https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/)

+ [剑指 Offer II 007. 数组中和为 0 的三个数 ](https://leetcode.cn/problems/1fGaJU/)

#### 相关题目

给你一个整数数组 `nums` ，判断是否存在三元组 `[nums[i], nums[j], nums[k]]` 满足 `i != j`、`i != k` 且 `j != k` ，同时还满足 `nums[i] + nums[j] + nums[k] == 0` 。请

你返回所有和为 `0` 且不重复的三元组。

**注意：**答案中不可以包含重复的三元组。

**示例 1：**

```
输入：nums = [-1,0,1,2,-1,-4]
输出：[[-1,-1,2],[-1,0,1]]
解释：
nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。
nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。
nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。
不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。
注意，输出的顺序和三元组的顺序并不重要。
```

#### 解题思路

有一个问题，是判断 nums[i] 与 nums[i + 1]是否相同，还是判断 nums[i] 与 nums[i-1] 是否相同。

如果我们的写法是 这样：

```cpp
if (nums[i] == nums[i + 1]) { // 去重操作
    continue;
}
```

那就我们就把 三元组中出现重复元素的情况直接pass掉了。 例如{-1, -1 ,2} 这组数据，当遍历到第一个-1 的时候，判断 下一个也是-1，那这组数据就pass了。

**我们要做的是 不能有重复的三元组，但三元组内的元素是可以重复的！**

所以这里是有两个重复的维度。

那么应该这么写：

```cpp
if (i > 0 && nums[i] == nums[i - 1]) {
    continue;
}
```

这么写就是当前使用 nums[i]，我们判断前一位是不是一样的元素，在看 {-1, -1 ,2} 这组数据，当遍历到 第一个 -1 的时候，只要前一位没有-1，那么 {-1, -1 ,2} 这组数据一样可以收录到 结果集里。

```cpp
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        vector<vector<int>> result;
        sort(nums.begin(), nums.end());
        for (int i = 0; i < nums.size(); i++) {
            // 排序之后如果第一个元素已经大于零，那么无论如何组合都不可能凑成三元组，直接返回结果就可以了
            if (nums[i] > 0) return result;
            // 错误去重a方法，将会漏掉-1,-1,2 这种情况
            /*
            if (nums[i] == nums[i + 1]) {
                continue;
            }
            */
            // 正确去重a方法
            if (i > 0 && nums[i] == nums[i - 1]) continue;
            int left = i + 1, right = nums.size() - 1;
            while (left < right) {
                // 去重复逻辑如果放在这里，0，0，0 的情况，可能直接导致 right<=left 了，从而漏掉了 0,0,0 这种三元组
                /*
                while (left < right && nums[right] == nums[right - 1]) right--;
                while (left < right && nums[left] == nums[left + 1]) left++;
                */
                if (nums[i] + nums[left] + nums[right] > 0) right--;
                else if (nums[i] + nums[left] + nums[right] < 0) left++;
                else {
                    result.push_back(vector<int>{nums[i], nums[left], nums[right]});
                    // 去重逻辑应该放在找到一个三元组之后，对b 和 c去重
                    while (left < right && nums[right] == nums[right - 1]) right--;
                    while (left < right && nums[left] == nums[left + 1]) left++;
                    // 找到答案时，双指针同时收缩
                    right--, left++;
                }
            }

        }
        return result;
    }
};
```

### 四数之和-相向指针

#### 相关链接

+ [18. 四数之和](https://leetcode.cn/problems/4sum/)
+ [454. 四数相加 II - 这个用哈希解法](https://leetcode.cn/problems/4sum-ii/)

#### 相关题目

给你一个由 `n` 个整数组成的数组 `nums` ，和一个目标值 `target` 。请你找出并返回满足下述全部条件且**不重复**的四元组 `[nums[a], nums[b], nums[c], nums[d]]` （若两个四元组元素一一对应，则认为两个四元组重复）：

+ `0 <= a, b, c, d < n`
+ `a`、`b`、`c` 和 `d` **互不相同**
+ `nums[a] + nums[b] + nums[c] + nums[d] == target`

你可以按 **任意顺序** 返回答案 。

**示例 1：**

```
输入：nums = [1,0,-1,0,-2,2], target = 0
输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]
```

#### 解题思路

四数之和，和 三数之和 是一个思路，都是使用双指针法, 基本解法就是 在三数之和 的基础上再套一层for循环。

但是有一些细节需要注意：

例如： 不要判断`nums[k] > target` 就返回了，三数之和 可以通过 `nums[i] > 0` 就返回了，因为 0 已经是确定的数了，四数之和这道题目 target是任意值。

比如：数组是`[-4, -3, -2, -1]`，`target`是`-10`，不能因为`-4 > -10`而跳过。

但是我们依旧可以去做剪枝，逻辑变成`nums[i] > target && (nums[i] >=0 || target >= 0)`就可以了。

```cpp
class Solution {
public:
    vector<vector<int>> fourSum(vector<int>& nums, int target) {
        vector<vector<int>> result;
        sort(nums.begin(), nums.end());
        for (int k = 0; k < nums.size(); k++) {
            // 剪枝处理
            if (nums[k] > target && nums[k] >= 0) {
            	break; // 这里使用break，统一通过最后的return返回
            }
            // 对nums[k]去重
            if (k > 0 && nums[k] == nums[k - 1]) {
                continue;
            }
            for (int i = k + 1; i < nums.size(); i++) {
                // 2级剪枝处理
                if (nums[k] + nums[i] > target && nums[k] + nums[i] >= 0) {
                    break;
                }

                // 对nums[i]去重
                if (i > k + 1 && nums[i] == nums[i - 1]) {
                    continue;
                }
                int left = i + 1;
                int right = nums.size() - 1;
                while (right > left) {
                    // nums[k] + nums[i] + nums[left] + nums[right] > target 会溢出
                    if ((long) nums[k] + nums[i] + nums[left] + nums[right] > target) {
                        right--;
                    // nums[k] + nums[i] + nums[left] + nums[right] < target 会溢出
                    } else if ((long) nums[k] + nums[i] + nums[left] + nums[right]  < target) {
                        left++;
                    } else {
                        result.push_back(vector<int>{nums[k], nums[i], nums[left], nums[right]});
                        // 对nums[left]和nums[right]去重
                        while (right > left && nums[right] == nums[right - 1]) right--;
                        while (right > left && nums[left] == nums[left + 1]) left++;

                        // 找到答案时，双指针同时收缩
                        right--;
                        left++;
                    }
                }

            }
        }
        return result;
    }
};
```



### 长度最小的子数组-滑动窗口

#### 相关链接

+ [209. 长度最小的子数组 ](https://leetcode.cn/problems/minimum-size-subarray-sum/)
+ [剑指 Offer II 008. 和大于等于 target 的最短子数组 ](https://leetcode.cn/problems/2VG8Kg/description/)
+ [904. 水果成篮 ](https://leetcode.cn/problems/fruit-into-baskets/)
+ [76. 最小覆盖子串](https://leetcode.cn/problems/minimum-window-substring/)

#### 相关题目

给定一个含有 `n` 个正整数的数组和一个正整数 `target` **。**

找出该数组中满足其和 `≥ target` 的长度最小的 **连续子数组** `[numsl, numsl+1, ..., numsr-1, numsr]` ，并返回其长度**。**如果不存在符合条件的子数组，返回 `0` 。

**示例 1：**

```
输入：target = 7, nums = [2,3,1,2,4,3]
输出：2
解释：子数组 [4,3] 是该条件下的长度最小的子数组。
```

**示例 2：**

```
输入：target = 4, nums = [1,4,4]
输出：1
```

**示例 3：**

```
输入：target = 11, nums = [1,1,1,1,1,1,1,1]
输出：0
```

#### 解题思路

所谓滑动窗口，**就是不断的调节子序列的起始位置和终止位置，从而得出我们要想的结果**。

在暴力解法中，是一个for循环滑动窗口的起始位置，一个for循环为滑动窗口的终止位置，用两个for循环 完成了一个不断搜索区间的过程。那么滑动窗口如何用一个for循环来完成这个操作呢。

首先要思考 如果用一个for循环，那么应该表示 滑动窗口的起始位置，还是终止位置。

如果只用一个for循环来表示 滑动窗口的起始位置，那么如何遍历剩下的终止位置？此时难免再次陷入暴力解法的怪圈。

所以 只用一个for循环，那么这个循环的索引，一定是表示 滑动窗口的终止位置。

在本题中实现滑动窗口，主要确定如下三点：

+ 窗口内是什么？
+ 如何移动窗口的起始位置？
+ 如何移动窗口的结束位置？

窗口就是 满足其和 ≥ s 的长度最小的 连续 子数组。

窗口的起始位置如何移动：如果当前窗口的值大于s了，窗口就要向前移动了（也就是该缩小了）。

窗口的结束位置如何移动：窗口的结束位置就是遍历数组的指针，也就是for循环里的索引。

```cpp
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        int res = INT_MAX, len = 0, sum = 0, i = 0;
        for(int j = 0; j < nums.size(); j++){
            sum += nums[j];
            while(sum >= target){
                len = j - i + 1;
                res = min(res, len);
                sum -= nums[i];
                i++;
            }
        }
        return res == INT_MAX ? 0 : res;
    }
};
```

# 二分查找

### 二分查找

#### 相关链接

+ [35. 搜索插入位置](https://leetcode.cn/problems/search-insert-position/description/)

+ [704. 二分查找 ](https://leetcode.cn/problems/binary-search/description/)

#### 相关题目

给定一个 `n` 个元素有序的（升序）整型数组 `nums` 和一个目标值 `target` ，写一个函数搜索 `nums` 中的 `target`，如果目标值存在返回下标，否则返回 `-1`。


**示例 1:**

```
输入: nums = [-1,0,3,5,9,12], target = 9
输出: 4
解释: 9 出现在 nums 中并且下标为 4
```

**示例 2:**

```
输入: nums = [-1,0,3,5,9,12], target = 2
输出: -1
解释: 2 不存在 nums 中因此返回 -1
```

#### 解题思路

二分法的前提条件

+ 数组为有序数组
+ 无重复元素

二分查找涉及的很多的边界条件，逻辑比较简单，但就是写不好。例如到底是 `while(left < right)` 还是 `while(left <= right)`，到底是`right = middle`呢，还是要`right = middle - 1`呢？

大家写二分法经常写乱，主要是因为**对区间的定义没有想清楚，区间的定义就是不变量**。要在二分查找的过程中，保持不变量，就是在while寻找中每一次边界的处理都要坚持根据区间的定义来操作，这就是**循环不变量**规则。

写二分法，区间的定义一般为两种，左闭右闭即[left, right]，或者左闭右开即[left, right)。

下面我用这两种区间的定义分别讲解两种不同的二分写法。

**二分法第一种写法**

第一种写法，我们定义 target 是在一个在左闭右闭的区间里，**也就是[left, right] （这个很重要非常重要）**。

区间的定义这就决定了二分法的代码应该如何写，**因为定义target在[left, right]区间，所以有如下两点：**

+ while (left <= right) 要使用 <= ，因为left == right是有意义的，所以使用 <=
+ if (nums[middle] > target) right 要赋值为 middle - 1，因为当前这个nums[middle]一定不是target，那么接下来要查找的左区间结束下标位置就是 middle - 1

例如在数组：1,2,3,4,7,9,10中查找元素2，如图所示：

<img src="https://img-blog.csdnimg.cn/20210311153055723.jpg" alt="第一种 二分查找" style="zoom: 80%;box-shadow:rgba(0,0,0,0) 0 0px 0px 0px;" />

代码如下：（详细注释）

```cpp
// 版本一
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int left = 0;
        int right = nums.size() - 1; // 定义target在左闭右闭的区间里，[left, right]
        while (left <= right) { // 当left==right，区间[left, right]依然有效，所以用 <=
            int middle = left + (right - left) / 2;// 防止溢出 等同于(left + right)/2
            if (nums[middle] > target) {
                right = middle - 1; // target 在左区间，所以[left, middle - 1]
            } else if (nums[middle] < target) {
                left = middle + 1; // target 在右区间，所以[middle + 1, right]
            } else { // nums[middle] == target
                return middle; // 数组中找到目标值，直接返回下标
            }
        }
        // 未找到目标值
        return -1;
    }
};
```

**二分法第二种写法**

如果说定义 target 是在一个在左闭右开的区间里，也就是[left, right) ，那么二分法的边界处理方式则截然不同。

有如下两点：

+ while (left < right)，这里使用 < ,因为left == right在区间[left, right)是没有意义的
+ if (nums[middle] > target) right 更新为 middle，因为当前nums[middle]不等于target，去左区间继续寻找，而寻找区间是左闭右开区间，所以right更新为middle，即：下一个查询区间不会去比较nums[middle]

在数组：1,2,3,4,7,9,10中查找元素2，如图所示：（**注意和方法一的区别**）

<img src="https://img-blog.csdnimg.cn/20210311153123632.jpg" alt="第二种 二分查找" style="zoom:80%;box-shadow:rgba(0,0,0,0) 0 0px 0px 0px;" />

代码如下：（详细注释）

```cpp
// 版本二
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int left = 0;
        int right = nums.size(); // 定义target在左闭右开的区间里，即：[left, right)
        while (left < right) { // 因为left == right的时候，在[left, right)是无效的空间，所以使用 <
            int middle = left + ((right - left) >> 1);
            if (nums[middle] > target) {
                right = middle; // target 在左区间，在[left, middle)中
            } else if (nums[middle] < target) {
                left = middle + 1; // target 在右区间，在[middle + 1, right)中
            } else { // nums[middle] == target
                return middle; // 数组中找到目标值，直接返回下标
            }
        }
        // 未找到目标值
        return -1;
    }
};
```

**总结**

需要注意三个地方

+ [left, right] : `r = num.size() - 1`，[left, right) : `r = num.size() `
+ [left, right] : `while(l <= r) `，[left, right) : `while(l < r) `
+ [left, right] : `r = mid - 1`，[left, right) : `r = mid `

### 排序数组查找首尾元素位置

#### 相关链接

+ [34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/description/)
+ [789. 数的范围 - AcWing题库](https://www.acwing.com/problem/content/791/)

#### 相关题目

给你一个按照非递减顺序排列的整数数组 `nums`，和一个目标值 `target`。请你找出给定目标值在数组中的开始位置和结束位置。

如果数组中不存在目标值 `target`，返回 `[-1, -1]`。

你必须设计并实现时间复杂度为 `O(log n)` 的算法解决此问题。

**示例 1：**

```
输入：nums = [5,7,7,8,8,10], target = 8
输出：[3,4]
```

**示例 2：**

```
输入：nums = [5,7,7,8,8,10], target = 6
输出：[-1,-1]
```

**示例 3：**

```
输入：nums = [], target = 0
输出：[-1,-1]
```

#### 解题思路

下面我来把所有情况都讨论一下。

寻找target在数组里的左右边界，有如下三种情况：

+ 情况一：target 在数组范围的右边或者左边，例如数组{3, 4, 5}，target为2或者数组{3, 4, 5},target为6，此时应该返回{-1, -1}
+ 情况二：target 在数组范围中，且数组中不存在target，例如数组{3,6,7},target为5，此时应该返回{-1, -1}
+ 情况三：target 在数组范围中，且数组中存在target，例如数组{3,6,7},target为6，此时应该返回{1, 1}

这三种情况都考虑到，说明就想的很清楚了。

接下来，在去寻找左边界，和右边界了。

采用二分法来去寻找左右边界，为了让代码清晰，我分别写两个二分来寻找左边界和右边界。

**刚刚接触二分搜索的同学不建议上来就想用一个二分来查找左右边界，很容易把自己绕进去，建议扎扎实实的写两个二分分别找左边界和右边界**

寻找右边界

先来寻找右边界，至于二分查找，如果看过 [704. 二分查找 ](https://leetcode.cn/problems/binary-search/description/) 就会知道，二分查找中什么时候用while (left <= right)，有什么时候用while (left < right)，其实只要清楚**循环不变量**，很容易区分两种写法。

那么这里我采用while (left <= right)的写法，区间定义为[left, right]，即左闭右闭的区间确定好：计算出来的右边界是不包含target的右边界，左边界同理。可以写出右边界如下代码

```cpp
// 二分查找，寻找target的右边界（不包括target）
// 如果rightBorder为没有被赋值（即target在数组范围的左边，例如数组[3,3]，target为2），为了处理情况一
int getRightBorder(vector<int>& nums, int target) {
    int left = 0;
    int right = nums.size() - 1; // 定义target在左闭右闭的区间里，[left, right]
    int rightBorder = -2; // 记录一下rightBorder没有被赋值的情况
    while (left <= right) { // 当left==right，区间[left, right]依然有效
        int middle = left + ((right - left) / 2);// 防止溢出 等同于(left + right)/2
        if (nums[middle] > target) {
            right = middle - 1; // target 在左区间，所以[left, middle - 1]
        } else { // 当nums[middle] == target的时候，更新left，这样才能得到target的右边界
            left = middle + 1;
            rightBorder = left;
        }
    }
    return rightBorder;
}
```

寻找左边界

```cpp
// 二分查找，寻找target的左边界leftBorder（不包括target）
// 如果leftBorder没有被赋值（即target在数组范围的右边，例如数组[3,3],target为4），为了处理情况一
int getLeftBorder(vector<int>& nums, int target) {
    int left = 0;
    int right = nums.size() - 1; // 定义target在左闭右闭的区间里，[left, right]
    int leftBorder = -2; // 记录一下leftBorder没有被赋值的情况
    while (left <= right) {
        int middle = left + ((right - left) / 2);
        if (nums[middle] >= target) { // 寻找左边界，就要在nums[middle] == target的时候更新right
            right = middle - 1;
            leftBorder = right;
        } else {
            left = middle + 1;
        }
    }
    return leftBorder;
}
```

左右边界计算完之后，看一下主体代码，这里把上面讨论的三种情况，都覆盖了

```cpp
class Solution {
public:
    vector<int> searchRange(vector<int>& nums, int target) {
        int leftBorder = getLeftBorder(nums, target);
        int rightBorder = getRightBorder(nums, target);
        // 情况一
        if (leftBorder == -2 || rightBorder == -2) return {-1, -1};
        // 情况三
        if (rightBorder - leftBorder > 1) return {leftBorder + 1, rightBorder - 1};
        // 情况二
        return {-1, -1};
    }
private:
     int getRightBorder(vector<int>& nums, int target) {
        int left = 0;
        int right = nums.size() - 1;
        int rightBorder = -2; // 记录一下rightBorder没有被赋值的情况
        while (left <= right) {
            int middle = left + ((right - left) / 2);
            if (nums[middle] > target) {
                right = middle - 1;
            } else { // 寻找右边界，nums[middle] == target的时候更新left
                left = middle + 1;
                rightBorder = left;
            }
        }
        return rightBorder;
    }
    int getLeftBorder(vector<int>& nums, int target) {
        int left = 0;
        int right = nums.size() - 1;
        int leftBorder = -2; // 记录一下leftBorder没有被赋值的情况
        while (left <= right) {
            int middle = left + ((right - left) / 2);
            if (nums[middle] >= target) { // 寻找左边界，nums[middle] == target的时候更新right
                right = middle - 1;
                leftBorder = right;
            } else {
                left = middle + 1;
            }
        }
        return leftBorder;
    }
};
```

**自己的模板--重点！！！**

```cpp
class Solution {
private:
    int search_left(vector<int>& nums, int l, int r, int x){ 
        while (l <= r) {
            int mid = l + ((r - l) / 2);
            if (nums[mid] >= x) r = mid - 1; 
            else l = mid + 1;
        }
        return l;
    }
    int search_right(vector<int>& nums, int l, int r, int x){ 
        while (l <= r){
            int mid = l + ((r - l) / 2);
            if(nums[mid] > x) r = mid - 1; 
            else l = mid + 1;
        }
        return r;
    }
public:
    vector<int> searchRange(vector<int>& nums, int target) {
        if(nums.size() == 0) return {-1, -1};
        int l = 0, r = nums.size() - 1;
		int l1 = search_left(nums, l, r, target);
		if (l1 >= nums.size() || nums[l1] != target){
            return {-1, -1};
		}
		int l2 = search_right(nums, l, r, target);
		return {l1, l2};
    }
};
```

[789. 数的范围 - AcWing题库](https://www.acwing.com/problem/content/791/)

Y总的模板

```cpp
bool check(int x) {/* ... */} // 检查x是否满足某种性质

// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：
int bsearch_1(int l, int r)
{
    while (l < r)
    {
        int mid = l + r >> 1;
        if (check(mid)) r = mid;    // check()判断mid是否满足性质
        else l = mid + 1;
    }
    return l;
}
// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：
int bsearch_2(int l, int r)
{
    while (l < r)
    {
        int mid = l + r + 1 >> 1;
        if (check(mid)) l = mid;
        else r = mid - 1;
    }
    return l;
}

```

完整代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int q[100100];
int l, r;
int search_left(int l, int r, int x){ 
	while (l < r){
		int mid = (l + r ) >> 1;
		if (q[mid] >= x) r = mid; 
		else l = mid + 1;
	}
	return l;
}
int search_right(int l, int r, int x){ 
	while (l < r){
		int mid = (l + r + 1) >> 1;
		if(q[mid] > x) r = mid - 1; 
		else l = mid;
	}
	return l;
}
int main(){
	int n, m;
	cin >> n >> m;
	for (int i = 0; i < n; i++) cin >> q[i];
	while (m--){
		int x;
        cin >> x;
		l = 0, r = n - 1;
		int l1 = search_left(l, r, x);
		if (q[l1] != x){
		    cout<<"-1 -1"<<endl;
		    continue;
		} else {
		    cout<<l1<<" ";
		}
		l = 0, r = n - 1;
		int l2 = search_right(l, r, x);		
		cout << l2 << endl;
	}
	return 0;
}
```

**自己总结的模板**

[34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/description/)

```cpp
//力扣需要注意vector数组越界的问题，acwing是因为数组开到了 100100
class Solution {
private:
    int search_left(vector<int>& nums, int l, int r, int x) { 
        while (l <= r) {
            int mid = l + ((r - l) / 2);
            if (nums[mid] >= x) r = mid - 1; 
            else l = mid + 1;
        }
        return l;
    }
    int search_right(vector<int>& nums, int l, int r, int x) { 
        while (l <= r) {
            int mid = l + ((r - l) / 2);
            if(nums[mid] > x) r = mid - 1; 
            else l = mid + 1;
        }
        return r;
    }
public:
    vector<int> searchRange(vector<int>& nums, int target) {
        if(nums.size() == 0) return {-1, -1};
        int l = 0, r = nums.size() - 1;
		int l1 = search_left(nums, l, r, target);
		if (l1 >= nums.size() || nums[l1] != target){
            return {-1, -1};
		}
		int l2 = search_right(nums, l, r, target);
		return {l1, l2};
    }
};
```

[789. 数的范围 - AcWing题库](https://www.acwing.com/problem/content/791/)

```cpp
#include<bits/stdc++.h>
using namespace std;
int q[100100];
int l, r;
int search_left(int l, int r, int x){ 
	while (l <= r){
		int mid = l + ((r - l) / 2);
		if (q[mid] >= x) r = mid - 1; 
		else l = mid + 1;
	}
	return l;//r + 1;
}
int search_right(int l, int r, int x){ 
	while (l <= r){
		int mid = l + ((r - l) / 2);
		if(q[mid] > x) r = mid - 1; 
		else l = mid + 1;
	}
	return r;//l - 1;
}
int main(){
	int n, m;
	cin >> n >> m;
	for (int i = 0; i < n; i++) cin >> q[i];
	while (m--){
		int x;
        cin>>x;
		l = 0, r = n - 1;
		int l1 = search_left(l, r, x);
		if (q[l1] != x){
		    cout<<"-1 -1"<<endl;
		    continue;
		} else {
		    cout<<l1<<" ";
		}
		l = 0, r = n - 1;
		int l2 = search_right(l, r, x);		
		cout << l2 << endl;
	}
	return 0;
}
```

# 数组

### 螺旋矩阵 II

#### 相关链接

+ [48. 旋转图像](https://leetcode.cn/problems/rotate-image/)
+ [1886. 判断矩阵经轮转后是否一致 - 力扣（Leetcode）](https://leetcode.cn/problems/determine-whether-matrix-can-be-obtained-by-rotation/)

+ [54. 螺旋矩阵](https://leetcode.cn/problems/spiral-matrix/)

+ [59. 螺旋矩阵 II](https://leetcode.cn/problems/spiral-matrix-ii/)
+ [剑指 Offer 29. 顺时针打印矩阵 ](https://leetcode.cn/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/)

#### 相关题目

给你一个正整数 `n` ，生成一个包含 `1` 到 `n2` 所有元素，且元素按顺时针顺序螺旋排列的 `n x n` 正方形矩阵 `matrix` 。

**示例 1：**

<img src="https://assets.leetcode.com/uploads/2020/11/13/spiraln.jpg" alt="示例1"  style="zoom:80%;" />

```
输入：n = 3
输出：[[1,2,3],[8,9,4],[7,6,5]]
```

**示例 2：**

```
输入：n = 1
输出：[[1]]
```

#### 解题思路

求解本题依然是要坚持循环不变量原则。

模拟顺时针画矩阵的过程:

+ 填充上行从左到右
+ 填充右列从上到下
+ 填充下行从右到左
+ 填充左列从下到上

坚持每条边左闭右开的原则。

那么我按照左闭右开的原则，来画一圈，大家看一下：

<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20220922102236.png" style="zoom: 18%;box-shadow:rgba(0,0,0,0) 0 0px 0px 0px;" />

代码随想录完整代码加详细注释如下：

```cpp
class Solution {
public:
    vector<vector<int>> generateMatrix(int n) {
        vector<vector<int>> res(n, vector<int>(n, 0)); // 使用vector定义一个二维数组
        int startx = 0, starty = 0; // 定义每循环一个圈的起始位置
        int loop = n / 2; // 每个圈循环几次，例如n为奇数3，那么loop = 1 只是循环一圈，矩阵中间的值需要单独处理
        int mid = n / 2; // 矩阵中间的位置，例如：n为3， 中间的位置就是(1，1)，n为5，中间位置为(2, 2)
        int count = 1; // 用来给矩阵中每一个空格赋值
        int offset = 1; // 需要控制每一条边遍历的长度，每次循环右边界收缩一位
        int i,j;
        while (loop --) {
            i = startx;
            j = starty;

            // 下面开始的四个for就是模拟转了一圈
            // 模拟填充上行从左到右(左闭右开)
            for (j = starty; j < n - offset; j++) {
                res[i][j] = count++;
            }
            // 模拟填充右列从上到下(左闭右开)
            for (i = startx; i < n - offset; i++) {
                res[i][j] = count++;
            }
            // 模拟填充下行从右到左(左闭右开)
            for (; j > starty; j--) {
                res[i][j] = count++;
            }
            // 模拟填充左列从下到上(左闭右开)
            for (; i > startx; i--) {
                res[i][j] = count++;
            }

            // 第二圈开始的时候，起始位置要各自加1， 例如：第一圈起始位置是(0, 0)，第二圈起始位置是(1, 1)
            startx++;
            starty++;

            // offset 控制每一圈里每一条边遍历的长度
            offset += 1;
        }

        // 如果n为奇数的话，需要单独给矩阵最中间的位置赋值
        if (n % 2) {
            res[mid][mid] = count;
        }
        return res;
    }
};
```

[其他简单思路](https://leetcode.cn/problems/spiral-matrix-ii/solutions/12594/spiral-matrix-ii-mo-ni-fa-she-ding-bian-jie-qing-x/)

生成一个 n×n 空矩阵 mat，随后模拟整个向内环绕的填入过程：

+ 定义当前左右上下边界 l,r,t,b，初始值 num = 1，迭代终止值 tar = n * n；

+ 当 num <= tar 时，始终按照 从左到右 从上到下 从右到左 从下到上 填入顺序循环，每次填入后：
  执行 num += 1：得到下一个需要填入的数字；

  更新边界：例如从左到右填完后，上边界 t += 1，相当于上边界向内缩 1。

  使用num <= tar而不是l < r || t < b作为迭代条件，是为了解决当n为奇数时，矩阵中心数字无法在迭代过程中被填充的问题。

```c++
class Solution {
public:
    vector<vector<int>> generateMatrix(int n) {
        vector<vector<int>> res(n, vector<int>(n, 0));
        int l = 0, r = n - 1, t = 0, b = n - 1;
        int num = 1, tar = n * n;
        while(num <= tar){
            for(int i = l; i <= r; i++) mat[t][i] = num++; // left to right.
            t++;
            for(int i = t; i <= b; i++) mat[i][r] = num++; // top to bottom.
            r--;
            for(int i = r; i >= l; i--) mat[b][i] = num++; // right to left.
            b--;
            for(int i = b; i >= t; i--) mat[i][l] = num++; // bottom to top.
            l++;
        }
        return res;
    }
};
```

[54. 螺旋矩阵 ](https://leetcode.cn/problems/spiral-matrix/description/)

```cpp
class Solution {
public:
    vector<int> spiralOrder(vector<vector<int>>& mat) {
        
        int m = mat.size();
        if(!m ) return {};
        int n = mat[0].size();
        
        vector<int> res;
        int l = 0, r = n - 1, t = 0, b = m - 1;
        int num = n * m;
        while(num >= 1){
            for(int i = l; i <= r && num >= 1; i++) { // num >= 1 切记有这个
                res.push_back(mat[t][i]); 
                num--;
            }
            t++;
            for(int i = t; i <= b && num >= 1; i++) {
                res.push_back(mat[i][r]); 
                num--;
            }
            r--;
            for(int i = r; i >= l && num >= 1; i--) {
                res.push_back(mat[b][i]);
                num--;
            }  
            b--;
            for(int i = b; i >= t && num >= 1; i--) {
                res.push_back(mat[i][l]);
                num--;
            }
            l++;
        }
        return res;
    }
};
```

[48. 旋转图像](https://leetcode.cn/problems/rotate-image/description/)

使用新数组

```cpp
class Solution {
public:
    void rotate(vector<vector<int>>& matrix) {
        int n = matrix.size();
        auto matrix_new = matrix;
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < n; ++j) {
                matrix_new[j][n - i - 1] = matrix[i][j];
            }
        }
        matrix = matrix_new;
    }
};
```

原地旋转

```cpp
class Solution {
public:
    void rotate(vector<vector<int>>& matrix) {
        int n = matrix.size();
        for(int i = 0; i < n / 2; i++) {
            for(int j = 0;j < (n + 1) / 2; j++) {
                int tmp = matrix[i][j];
                matrix[i][j] = matrix[n-j-1][i];
                matrix[n-j-1][i] = matrix[n-i-1][n-j-1];
                matrix[n-i-1][n-j-1] = matrix[j][n-i-1];
                matrix[j][n-i-1] = tmp;
            }
        }
    }
};
```

[1886. 判断矩阵经轮转后是否一致 ](https://leetcode.cn/problems/determine-whether-matrix-can-be-obtained-by-rotation/)

原地旋转

```cpp
class Solution {
public:
    bool findRotation(vector<vector<int>>& mat, vector<vector<int>>& target) {
        int n = mat.size();
        for(int k=0;k<4;k++) {
            for(int i = 0; i < n / 2; i++) {
                for(int j = 0; j < ( n + 1 ) / 2; j++) {
                    int tmp = mat[i][j];
                    mat[i][j] = mat[n-j-1][i];
                    mat[n-j-1][i] = mat[n-i-1][n-j-1];
                    mat[n-i-1][n-j-1] = mat[j][n-i-1];
                    mat[j][n-i-1] = tmp;
                }
            }
            if(mat == target) return true; 
        }
        return false;

    }
};
```

