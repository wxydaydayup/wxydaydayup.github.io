---
rauthor: WangXinYi
img: /images/homePage/双指针.webp
summary: 算法-双指针
categories:
  - 算法
  - C++
  - 双指针
tags:
  - 算法
  - C++
  - 双指针
top: false
typora-root-url: ..
date: 2021-10-20 12:06:57
---

# 双指针 

### 合并两个有序数组

#### 相关链接

+ [88. 合并两个有序数组 ](https://leetcode.cn/problems/merge-sorted-array/)

#### 相关题目

给你两个按 **非递减顺序** 排列的整数数组 `nums1` 和 `nums2`，另有两个整数 `m` 和 `n` ，分别表示 `nums1` 和 `nums2` 中的元素数目。

请你 **合并** `nums2` 到 `nums1` 中，使合并后的数组同样按 **非递减顺序** 排列。

**注意：**最终，合并后数组不应由函数返回，而是存储在数组 `nums1` 中。为了应对这种情况，`nums1` 的初始长度为 `m + n`，其中前 `m` 个元素表示应合并的元素，后 `n` 个元素为 `0` ，应忽略。`nums2` 的长度为 `n` 。

**示例 1：**

```
输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
输出：[1,2,2,3,5,6]
解释：需要合并 [1,2,3] 和 [2,5,6] 。
合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素。
```

#### 解题思路

```cpp
class Solution {
public:
    void merge(int A[], int m, int B[], int n) {
        int i = m - 1;
        int j = n - 1;
        int k = m + n - 1;
        while(i >= 0 && j >= 0 && k >= 0) {
            if(A[i] > B[j]) A[k--] = A[i--]; 
            else A[k--] =  B[j--]; 
        }
        if(i < 0) while(j >= 0) A[k--] =  B[j--]; 
    }
};
```

[88. 合并两个有序数组 ](https://leetcode.cn/problems/merge-sorted-array/)

```cpp
class Solution {
public:
    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
        int i = m - 1, j = n - 1, k = m + n - 1;
        while(i >= 0 && j >= 0 && k >= 0) {
            if(nums1[i] > nums2[j]) nums1[k--] = nums1[i--];
            else nums1[k--] = nums2[j--];
        }
        if(i < 0) while(j >= 0) nums1[k--] = nums2[j--];
    }
};
```

### 移除元素-快慢指针

#### 相关链接

+ [26. 删除有序数组中的重复项 ](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/description/)
+ [27. 移除元素](https://leetcode.cn/problems/remove-element/)
+ [283. 移动零 ](https://leetcode.cn/problems/move-zeroes/description/)

#### 相关题目

给你一个数组 `nums` 和一个值 `val`，你需要 原地 移除所有数值等于 `val` 的元素，并返回移除后数组的新长度。

不要使用额外的数组空间，你必须仅使用 `O(1)` 额外空间并 原地 修改输入数组。

元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。

**说明:**

为什么返回数值是整数，但输出的答案是数组呢?

请注意，输入数组是以**「引用」**方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。

你可以想象内部操作如下:

```
// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝
int len = removeElement(nums, val);

// 在函数里修改输入数组对于调用者是可见的。
// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。
for (int i = 0; i < len; i++) {
    print(nums[i]);
}
```

#### 解题思路

双指针法

**写法1-快慢指针法**

快慢指针法： **通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。**

定义快慢指针

+ 快指针：寻找新数组的元素 ，新数组就是不含有目标元素的数组
+ 慢指针：指向更新 新数组下标的位置

这道题 慢指针 和 快指针 都是从0开始的

```cpp
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        int slowIndex = 0;
        for(int fastIndex = 0; fastIndex < nums.size(); fastIndex++){
            if(nums[fastIndex] != val){
                nums[slowIndex++] = nums[fastIndex];
                //nums[slowIndex] = nums[fastIndex];
            	//slowIndex++;
            }
        }
        return slowIndex;
    }
};
```

**写法2-相向双指针法**

由于题意元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。

相向双指针方法，基于元素顺序可以改变的题目描述改变了元素相对位置，确保了移动最少元素

```cpp
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        int leftIndex = 0;
        int rightIndex = nums.size() - 1;
        while(leftIndex <= rightIndex){
            while(leftIndex <= rightIndex && nums[leftIndex] != val) ++leftIndex;
            while(leftIndex <= rightIndex && nums[rightIndex] == val) --rightIndex;
            if(leftIndex < rightIndex) nums[leftIndex++] = nums[rightIndex--];
        }
        return leftIndex;
    }
};
```

[26. 删除有序数组中的重复项 ](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/description/)

```cpp
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        int slowIndex = 0;
        for(int fastIndex = 1; fastIndex < nums.size(); fastIndex++){
            if(nums[slowIndex] != nums[fastIndex]){
                nums[slowIndex + 1] = nums[fastIndex];
                slowIndex++;
                //以下写法也可以
                //slowIndex++;
                //nums[slowIndex] = nums[fastIndex];
            }
        }
        return slowIndex + 1;
    }
};
```

[283. 移动零 ](https://leetcode.cn/problems/move-zeroes/description/)

```
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        int slowIndex = 0;
        for(int fastIndex = 0; fastIndex < nums.size(); fastIndex++){
            if(nums[fastIndex]){
                swap(nums[slowIndex], nums[fastIndex]);
                slowIndex++;
            }
        }
        return;
    }
};

```

### 比较含退格字符串-快慢指针

#### 相关链接

+ [844. 比较含退格的字符串 ](https://leetcode.cn/problems/backspace-string-compare/description/)

#### 相关题目

给定 `s` 和 `t` 两个字符串，当它们分别被输入到空白的文本编辑器后，如果两者相等，返回 `true` 。`#` 代表退格字符。

**注意：**如果对空文本输入退格字符，文本继续为空。

**示例 1：**

```
输入：s = "ab#c", t = "ad#c"
输出：true
解释：s 和 t 都会变成 "ac"。
```

**示例 2：**

```
输入：s = "ab##", t = "c#d#"
输出：true
解释：s 和 t 都会变成 ""。
```

**示例 3：**

```
输入：s = "a#c", t = "b"
输出：false
解释：s 会变成 "c"，但 t 仍然是 "b"。
```

#### 解题思路

**写法1-双指针法**

```cpp
class Solution {
public:
    bool backspaceCompare(string S, string T) {
        int i = S.size() - 1, j = T.size() - 1;
        int skipS = 0, skipT = 0;
        while (i >= 0 || j >= 0){
            while (i >= 0){
                if (S[i] == '#'){
                    skipS++, i--;
                } else if (skipS > 0){
                    skipS--, i--;
                } else break;
            }
            while (j >= 0){
                if (T[j] == '#'){
                    skipT++, j--;
                } else if (skipT > 0){
                    skipT--, j--;
                } else break;
            }    
            if (i >= 0 && j >=0){
                if(S[i] != T[j]) return false;
            } else {
                if(i >= 0 || j >= 0) return false; 
            }     
            i--, j--;
        }
        return true;
    }
};
```

**写法2-重构字符串**

```cpp
class Solution {
public:
    bool backspaceCompare(string S, string T) {
        return compare(S) == compare(T);
    }
    string compare(string s){
        string str;
        for(char c: s){
            if(c != '#'){
                str.push_back(c);
            } else if (!str.empty()){
                str.pop_back();
            } 
        }
        return str;
    }
};
```

### 有序数组的平方-相向指针

#### 相关链接

+ [977. 有序数组的平方 ](https://leetcode.cn/problems/squares-of-a-sorted-array/)

#### 相关题目

给你一个按 **非递减顺序** 排序的整数数组 `nums`，返回 **每个数字的平方** 组成的新数组，要求也按 **非递减顺序** 排序。

**示例 1：**

```
输入：nums = [-4,-1,0,3,10]
输出：[0,1,9,16,100]
解释：平方后，数组变为 [16,1,0,9,100]
排序后，数组变为 [0,1,9,16,100]
```

**示例 2：**

```
输入：nums = [-7,-3,2,3,11]
输出：[4,9,9,49,121]
```

#### 解题思路

```cpp
class Solution {
public:
    vector<int> sortedSquares(vector<int>& nums) {
        int k = nums.size() - 1;
        vector<int> res(nums.size(), 0);
        for (int i = 0, j = nums.size() - 1; i <= j;) {
            if (nums[i] * nums[i] < nums[j] * nums[j]) {
                res[k--] = nums[j] * nums[j];
                j--;
            } else {
                res[k--] = nums[i] * nums[i];
                i++;                
            }
        }
        return res;
    }
};
```

### 三数之和-相向指针

#### 相关链接

+ [15. 三数之和 ](https://leetcode.cn/problems/3sum/)

+ [167. 两数之和 II - 输入有序数组](https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/)

+ [剑指 Offer II 007. 数组中和为 0 的三个数 ](https://leetcode.cn/problems/1fGaJU/)

#### 相关题目

给你一个整数数组 `nums` ，判断是否存在三元组 `[nums[i], nums[j], nums[k]]` 满足 `i != j`、`i != k` 且 `j != k` ，同时还满足 `nums[i] + nums[j] + nums[k] == 0` 。请

你返回所有和为 `0` 且不重复的三元组。

**注意：**答案中不可以包含重复的三元组。

**示例 1：**

```
输入：nums = [-1,0,1,2,-1,-4]
输出：[[-1,-1,2],[-1,0,1]]
解释：
nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。
nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。
nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。
不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。
注意，输出的顺序和三元组的顺序并不重要。
```

#### 解题思路

有一个问题，是判断 nums[i] 与 nums[i + 1]是否相同，还是判断 nums[i] 与 nums[i-1] 是否相同。

如果我们的写法是 这样：

```cpp
if (nums[i] == nums[i + 1]) { // 去重操作
    continue;
}
```

那就我们就把 三元组中出现重复元素的情况直接pass掉了。 例如{-1, -1 ,2} 这组数据，当遍历到第一个-1 的时候，判断 下一个也是-1，那这组数据就pass了。

**我们要做的是 不能有重复的三元组，但三元组内的元素是可以重复的！**

所以这里是有两个重复的维度。

那么应该这么写：

```cpp
if (i > 0 && nums[i] == nums[i - 1]) {
    continue;
}
```

这么写就是当前使用 nums[i]，我们判断前一位是不是一样的元素，在看 {-1, -1 ,2} 这组数据，当遍历到 第一个 -1 的时候，只要前一位没有-1，那么 {-1, -1 ,2} 这组数据一样可以收录到 结果集里。

```cpp
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        vector<vector<int>> result;
        sort(nums.begin(), nums.end());
        for (int i = 0; i < nums.size() - 2; i++) {
            // 排序之后如果第一个元素已经大于零，那么无论如何组合都不可能凑成三元组，直接返回结果就可以了
            if (nums[i] > 0) return result;
            // 错误去重a方法，将会漏掉-1,-1,2 这种情况
            /*
            if (nums[i] == nums[i + 1]) {
                continue;
            }
            */
            // 正确去重a方法
            if (i > 0 && nums[i] == nums[i - 1]) continue;
            int left = i + 1, right = nums.size() - 1;
            while (left < right) {
                // 去重复逻辑如果放在这里，0，0，0 的情况，可能直接导致 right<=left 了，从而漏掉了 0,0,0 这种三元组
                /*
                while (left < right && nums[right] == nums[right - 1]) right--;
                while (left < right && nums[left] == nums[left + 1]) left++;
                */
                if (nums[i] + nums[left] + nums[right] > 0) right--;
                else if (nums[i] + nums[left] + nums[right] < 0) left++;
                else {
                    result.push_back(vector<int>{nums[i], nums[left], nums[right]});
                    // 去重逻辑应该放在找到一个三元组之后，对b 和 c去重
                    while (left < right && nums[right] == nums[right - 1]) right--;
                    while (left < right && nums[left] == nums[left + 1]) left++;
                    // 找到答案时，双指针同时收缩
                    right--, left++;
                }
            }

        }
        return result;
    }
};
```

### 四数之和-相向指针

#### 相关链接

+ [18. 四数之和](https://leetcode.cn/problems/4sum/)
+ [454. 四数相加 II - 这个用哈希解法](https://leetcode.cn/problems/4sum-ii/)

#### 相关题目

给你一个由 `n` 个整数组成的数组 `nums` ，和一个目标值 `target` 。请你找出并返回满足下述全部条件且**不重复**的四元组 `[nums[a], nums[b], nums[c], nums[d]]` （若两个四元组元素一一对应，则认为两个四元组重复）：

+ `0 <= a, b, c, d < n`
+ `a`、`b`、`c` 和 `d` **互不相同**
+ `nums[a] + nums[b] + nums[c] + nums[d] == target`

你可以按 **任意顺序** 返回答案 。

**示例 1：**

```
输入：nums = [1,0,-1,0,-2,2], target = 0
输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]
```

#### 解题思路

四数之和，和 三数之和 是一个思路，都是使用双指针法, 基本解法就是 在三数之和 的基础上再套一层for循环。

但是有一些细节需要注意：

例如： 不要判断`nums[k] > target` 就返回了，三数之和 可以通过 `nums[i] > 0` 就返回了，因为 0 已经是确定的数了，四数之和这道题目 target是任意值。

比如：数组是`[-4, -3, -2, -1]`，`target`是`-10`，不能因为`-4 > -10`而跳过。

但是我们依旧可以去做剪枝，逻辑变成`nums[i] > target && (nums[i] >=0 || target >= 0)`就可以了。

```cpp
class Solution {
public:
    vector<vector<int>> fourSum(vector<int>& nums, int target) {
        vector<vector<int>> result;
        sort(nums.begin(), nums.end());
        for (int k = 0; k < nums.size(); k++) {
            // 剪枝处理
            if (nums[k] > target && nums[k] >= 0) {
            	break; // 这里使用break，统一通过最后的return返回
            }
            // 对nums[k]去重
            if (k > 0 && nums[k] == nums[k - 1]) {
                continue;
            }
            for (int i = k + 1; i < nums.size(); i++) {
                // 2级剪枝处理
                if (nums[k] + nums[i] > target && nums[k] + nums[i] >= 0) {
                    break;
                }

                // 对nums[i]去重
                if (i > k + 1 && nums[i] == nums[i - 1]) {
                    continue;
                }
                int left = i + 1;
                int right = nums.size() - 1;
                while (right > left) {
                    // nums[k] + nums[i] + nums[left] + nums[right] > target 会溢出
                    if ((long) nums[k] + nums[i] + nums[left] + nums[right] > target) {
                        right--;
                    // nums[k] + nums[i] + nums[left] + nums[right] < target 会溢出
                    } else if ((long) nums[k] + nums[i] + nums[left] + nums[right]  < target) {
                        left++;
                    } else {
                        result.push_back(vector<int>{nums[k], nums[i], nums[left], nums[right]});
                        // 对nums[left]和nums[right]去重
                        while (right > left && nums[right] == nums[right - 1]) right--;
                        while (right > left && nums[left] == nums[left + 1]) left++;

                        // 找到答案时，双指针同时收缩
                        right--;
                        left++;
                    }
                }

            }
        }
        return result;
    }
};
```

### 排序数组中只出现一次的数字-相向指针

#### 相关链接

+ 有序用双指针[剑指 Offer II 070. 排序数组中只出现一次的数字 ](https://leetcode.cn/problems/skFtm2/description/)
+ 无序用哈希 [数组中只出现一次的两个数字_牛客题霸](https://www.nowcoder.com/practice/389fc1c3d3be4479a154f63f495abff8?tpId=295&tqId=1375231&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26tab%3D%E7%AE%97%E6%B3%95%E7%AF%87%26topicId%3D295%26fromPut%3Dpc_kol_aaaxiu)

#### 相关题目

一个有序整型数组里除了两个数字只出现一次，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。

#### 解题思路

<img src="/images/%E7%AE%97%E6%B3%95-%E5%8F%8C%E6%8C%87%E9%92%88/image-20230427093337286.png" alt="image-20230427093337286" style="zoom: 80%;" />

```cpp
class Solution {
public:
    int singleNonDuplicate(vector<int>& nums) {
        if(nums.size() == 1 ) return nums[0];
        int l = 0, r = nums.size() - 1 ;
        while( l <= r){
            int mid = l + (r - l) / 2;
            if(nums[mid] == nums[mid ^ 1]) l = mid + 1;
            else r = mid - 1;
        }
        return nums[l];
    }
};
```

### 长度最小的子数组-滑动窗口

#### 相关链接

+ [209. 长度最小的子数组 ](https://leetcode.cn/problems/minimum-size-subarray-sum/)
+ [剑指 Offer II 008. 和大于等于 target 的最短子数组 ](https://leetcode.cn/problems/2VG8Kg/description/)
+ [904. 水果成篮 ](https://leetcode.cn/problems/fruit-into-baskets/)
+ [76. 最小覆盖子串](https://leetcode.cn/problems/minimum-window-substring/)

#### 相关题目

给定一个含有 `n` 个正整数的数组和一个正整数 `target` **。**

找出该数组中满足其和 `≥ target` 的长度最小的 **连续子数组** `[numsl, numsl+1, ..., numsr-1, numsr]` ，并返回其长度**。**如果不存在符合条件的子数组，返回 `0` 。

**示例 1：**

```
输入：target = 7, nums = [2,3,1,2,4,3]
输出：2
解释：子数组 [4,3] 是该条件下的长度最小的子数组。
```

**示例 2：**

```
输入：target = 4, nums = [1,4,4]
输出：1
```

**示例 3：**

```
输入：target = 11, nums = [1,1,1,1,1,1,1,1]
输出：0
```

#### 解题思路

所谓滑动窗口，**就是不断的调节子序列的起始位置和终止位置，从而得出我们要想的结果**。

在暴力解法中，是一个for循环滑动窗口的起始位置，一个for循环为滑动窗口的终止位置，用两个for循环 完成了一个不断搜索区间的过程。那么滑动窗口如何用一个for循环来完成这个操作呢。

首先要思考 如果用一个for循环，那么应该表示 滑动窗口的起始位置，还是终止位置。

如果只用一个for循环来表示 滑动窗口的起始位置，那么如何遍历剩下的终止位置？此时难免再次陷入暴力解法的怪圈。

所以 只用一个for循环，那么这个循环的索引，一定是表示 滑动窗口的终止位置。

在本题中实现滑动窗口，主要确定如下三点：

+ 窗口内是什么？
+ 如何移动窗口的起始位置？
+ 如何移动窗口的结束位置？

窗口就是 满足其和 ≥ s 的长度最小的 连续 子数组。

窗口的起始位置如何移动：如果当前窗口的值大于s了，窗口就要向前移动了（也就是该缩小了）。

窗口的结束位置如何移动：窗口的结束S位置就是遍历数组的指针，也就是for循环里的索引。

```cpp
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        int res = INT_MAX, len = 0, sum = 0, i = 0;
        for(int j = 0; j < nums.size(); j++){
            sum += nums[j];
            while(sum >= target){
                len = j - i + 1;
                res = min(res, len);
                sum -= nums[i];
                i++;
            }
        }
        return res == INT_MAX ? 0 : res;
    }
};
```

### 最长无重复子数组-滑动窗口

#### 相关链接

+ [最长无重复子数组_牛客题霸](https://www.nowcoder.com/practice/b56799ebfd684fb394bd315e89324fb4?tpId=295&tqId=1008889&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26tab%3D%E7%AE%97%E6%B3%95%E7%AF%87%26topicId%3D295%26fromPut%3Dpc_kol_aaaxiu)

#### 相关题目

给定一个长度为n的数组arr，返回arr的最长无重复元素子数组的长度，无重复指的是所有数字都不相同。

子数组是连续的，比如[1,3,5,7,9]的子数组有[1,3]，[3,5,7]等等，但是[1,3,7]不是子数组。

#### 解题思路

```cpp
#include <unordered_map>
class Solution {
public:
    int maxLength(vector<int>& arr) {
        unordered_map<int, int> mp;
        int res = 0;
        for(int l = 0, r = 0; r < arr.size(); r++) {
            mp[arr[r]]++;   //窗口右移进入哈希表统计次数
            while(mp[arr[r]] > 1) mp[arr[l++]]--; //窗口左移，同时减去该数字出现次数
            res = max(res , r - l + 1);//维护子数组长度最大长度
        }
        return res;
    }
};
```

### 区间合并问题

#### 相关链接

+ [合并区间_牛客题霸](https://www.nowcoder.com/practice/69f4e5b7ad284a478777cb2a17fb5e6a?tpId=295&tqId=691&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26tab%3D%E7%AE%97%E6%B3%95%E7%AF%87%26topicId%3D295%26fromPut%3Dpc_kol_aaaxiu)
+ [422. 校门外的树 - AcWing题库](https://www.acwing.com/problem/content/424/)

#### 相关题目

给出一组区间，请合并所有重叠的区间。

请保证合并后的区间按区间起点升序排列。

#### 解题思路

```cpp
#include <vector>
class Solution {
public:
    static bool cmp(Interval& a, Interval& b) {
        return a.start < b.start;
    }
    vector<Interval> merge(vector<Interval> &intervals) {
        vector<Interval> res;
        if(intervals.size() == 0) return res;
        sort(intervals.begin(), intervals.end(), cmp);
        res.push_back(intervals[0]);
        for(int i = 1; i < intervals.size(); i++) {
            if(intervals[i].start <= res.back().end) {
                res.back().end = max(res.back().end, intervals[i].end);
            } else res.push_back(intervals[i]);
        }
        return res;
    }
};
```

y总模板

```cpp
#include<bits/stdc++.h>
using namespace std;
typedef pair<int,int> PII;
vector<PII> segs;

void merge(vector<PII> &segs){
	vector <PII> res;
	sort(segs.begin(),segs.end());
	int st=-2e9,ed=-2e9;
	for(int i=0;i<segs.size();i++){
		if(ed<segs[i].first){		   //没有任何交集的情况
			if(st!=-2e9) res.push_back({st,ed});	
			st=segs[i].first,ed=segs[i].second; 
		} 
		else ed=max(segs[i].second,ed);//求两个集合的并集
	}
	if(st!=-2e9) res.push_back({st,ed});//st1=-2e9 是防空数组，res把最后一个放进去 
	segs=res;
}

int main(){
	int n;cin>>n;
	for(int i=0;i<n;i++){
		int l,r;
		cin>>l>>r;
		segs.push_back({l,r});
	}	
	merge(segs);
	cout<<segs.size()<<endl;
	return 0;
}
```

[422. 校门外的树 - AcWing题库](https://www.acwing.com/problem/content/424/)

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=110;
struct Segment{
	int l,r;
	bool operator< (const Segment& t) const
	{
		return l<t.l;
	}
}seg[N];
int main(){
	int n,m;cin>>m>>n;
	for(int i=0;i<n;i++) cin>>seg[i].l>>seg[i].r;
	sort(seg,seg+n);
	int sum=0;
	int L=seg[0].l,R=seg[0].r;
	for(int i=1;i<n;i++){
		if(seg[i].l<=R) R=max(R,seg[i].r);
		else{
			sum+=R-L+1;
			L=seg[i].l,R=seg[i].r;
		}
	}
	sum+=R-L+1; 
	cout<<m+1-sum<<endl;
	return 0;
}
```

# 二分查找

### 二分查找

#### 相关链接

+ [35. 搜索插入位置](https://leetcode.cn/problems/search-insert-position/description/)

+ [704. 二分查找 ](https://leetcode.cn/problems/binary-search/description/)

#### 相关题目

给定一个 `n` 个元素有序的（升序）整型数组 `nums` 和一个目标值 `target` ，写一个函数搜索 `nums` 中的 `target`，如果目标值存在返回下标，否则返回 `-1`。


**示例 1:**

```
输入: nums = [-1,0,3,5,9,12], target = 9
输出: 4
解释: 9 出现在 nums 中并且下标为 4
```

**示例 2:**

```
输入: nums = [-1,0,3,5,9,12], target = 2
输出: -1
解释: 2 不存在 nums 中因此返回 -1
```

#### 解题思路

二分法的前提条件

+ 数组为有序数组
+ 无重复元素

二分查找涉及的很多的边界条件，逻辑比较简单，但就是写不好。例如到底是 `while(left < right)` 还是 `while(left <= right)`，到底是`right = middle`呢，还是要`right = middle - 1`呢？

大家写二分法经常写乱，主要是因为**对区间的定义没有想清楚，区间的定义就是不变量**。要在二分查找的过程中，保持不变量，就是在while寻找中每一次边界的处理都要坚持根据区间的定义来操作，这就是**循环不变量**规则。

写二分法，区间的定义一般为两种，左闭右闭即[left, right]，或者左闭右开即[left, right)。

下面我用这两种区间的定义分别讲解两种不同的二分写法。

**二分法第一种写法**

第一种写法，我们定义 target 是在一个在左闭右闭的区间里，**也就是[left, right] （这个很重要非常重要）**。

区间的定义这就决定了二分法的代码应该如何写，**因为定义target在[left, right]区间，所以有如下两点：**

+ while (left <= right) 要使用 <= ，因为left == right是有意义的，所以使用 <=
+ if (nums[middle] > target) right 要赋值为 middle - 1，因为当前这个nums[middle]一定不是target，那么接下来要查找的左区间结束下标位置就是 middle - 1

例如在数组：1,2,3,4,7,9,10中查找元素2，如图所示：

<img src="https://img-blog.csdnimg.cn/20210311153055723.jpg" alt="第一种 二分查找" style="zoom: 80%;box-shadow:rgba(0,0,0,0) 0 0px 0px 0px;" />

代码如下：（详细注释）

```cpp
// 版本一
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int left = 0;
        int right = nums.size() - 1; // 定义target在左闭右闭的区间里，[left, right]
        while (left <= right) { // 当left==right，区间[left, right]依然有效，所以用 <=
            int middle = left + (right - left) / 2;// 防止溢出 等同于(left + right)/2
            if (nums[middle] > target) {
                right = middle - 1; // target 在左区间，所以[left, middle - 1]
            } else if (nums[middle] < target) {
                left = middle + 1; // target 在右区间，所以[middle + 1, right]
            } else { // nums[middle] == target
                return middle; // 数组中找到目标值，直接返回下标
            }
        }
        // 未找到目标值
        return -1;
    }
};
```

**二分法第二种写法**

如果说定义 target 是在一个在左闭右开的区间里，也就是[left, right) ，那么二分法的边界处理方式则截然不同。

有如下两点：

+ while (left < right)，这里使用 < ,因为left == right在区间[left, right)是没有意义的
+ if (nums[middle] > target) right 更新为 middle，因为当前nums[middle]不等于target，去左区间继续寻找，而寻找区间是左闭右开区间，所以right更新为middle，即：下一个查询区间不会去比较nums[middle]

在数组：1,2,3,4,7,9,10中查找元素2，如图所示：（**注意和方法一的区别**）

<img src="https://img-blog.csdnimg.cn/20210311153123632.jpg" alt="第二种 二分查找" style="zoom:80%;box-shadow:rgba(0,0,0,0) 0 0px 0px 0px;" />

代码如下：（详细注释）

```cpp
// 版本二
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int left = 0;
        int right = nums.size(); // 定义target在左闭右开的区间里，即：[left, right)
        while (left < right) { // 因为left == right的时候，在[left, right)是无效的空间，所以使用 <
            int middle = left + ((right - left) >> 1);
            if (nums[middle] > target) {
                right = middle; // target 在左区间，在[left, middle)中
            } else if (nums[middle] < target) {
                left = middle + 1; // target 在右区间，在[middle + 1, right)中
            } else { // nums[middle] == target
                return middle; // 数组中找到目标值，直接返回下标
            }
        }
        // 未找到目标值
        return -1;
    }
};
```

**总结**

需要注意三个地方

+ [left, right] : `r = num.size() - 1`，[left, right) : `r = num.size() `
+ [left, right] : `while(l <= r) `，[left, right) : `while(l < r) `
+ [left, right] : `r = mid - 1`，[left, right) : `r = mid `

### 排序数组查找首尾元素位置

#### 相关链接

+ [34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/description/)
+ [789. 数的范围 - AcWing题库](https://www.acwing.com/problem/content/791/)

#### 相关题目

给你一个按照非递减顺序排列的整数数组 `nums`，和一个目标值 `target`。请你找出给定目标值在数组中的开始位置和结束位置。

如果数组中不存在目标值 `target`，返回 `[-1, -1]`。

你必须设计并实现时间复杂度为 `O(log n)` 的算法解决此问题。

**示例 1：**

```
输入：nums = [5,7,7,8,8,10], target = 8
输出：[3,4]
```

**示例 2：**

```
输入：nums = [5,7,7,8,8,10], target = 6
输出：[-1,-1]
```

**示例 3：**

```
输入：nums = [], target = 0
输出：[-1,-1]
```

#### 解题思路

下面我来把所有情况都讨论一下。

寻找target在数组里的左右边界，有如下三种情况：

+ 情况一：target 在数组范围的右边或者左边，例如数组{3, 4, 5}，target为2或者数组{3, 4, 5},target为6，此时应该返回{-1, -1}
+ 情况二：target 在数组范围中，且数组中不存在target，例如数组{3,6,7},target为5，此时应该返回{-1, -1}
+ 情况三：target 在数组范围中，且数组中存在target，例如数组{3,6,7},target为6，此时应该返回{1, 1}

这三种情况都考虑到，说明就想的很清楚了。

接下来，在去寻找左边界，和右边界了。

采用二分法来去寻找左右边界，为了让代码清晰，我分别写两个二分来寻找左边界和右边界。

**刚刚接触二分搜索的同学不建议上来就想用一个二分来查找左右边界，很容易把自己绕进去，建议扎扎实实的写两个二分分别找左边界和右边界**

寻找右边界

先来寻找右边界，至于二分查找，如果看过 [704. 二分查找 ](https://leetcode.cn/problems/binary-search/description/) 就会知道，二分查找中什么时候用while (left <= right)，有什么时候用while (left < right)，其实只要清楚**循环不变量**，很容易区分两种写法。

那么这里我采用while (left <= right)的写法，区间定义为[left, right]，即左闭右闭的区间确定好：计算出来的右边界是不包含target的右边界，左边界同理。可以写出右边界如下代码

```cpp
// 二分查找，寻找target的右边界（不包括target）
// 如果rightBorder为没有被赋值（即target在数组范围的左边，例如数组[3,3]，target为2），为了处理情况一
int getRightBorder(vector<int>& nums, int target) {
    int left = 0;
    int right = nums.size() - 1; // 定义target在左闭右闭的区间里，[left, right]
    int rightBorder = -2; // 记录一下rightBorder没有被赋值的情况
    while (left <= right) { // 当left==right，区间[left, right]依然有效
        int middle = left + ((right - left) / 2);// 防止溢出 等同于(left + right)/2
        if (nums[middle] > target) {
            right = middle - 1; // target 在左区间，所以[left, middle - 1]
        } else { // 当nums[middle] == target的时候，更新left，这样才能得到target的右边界
            left = middle + 1;
            rightBorder = left;
        }
    }
    return rightBorder;
}
```

寻找左边界

```cpp
// 二分查找，寻找target的左边界leftBorder（不包括target）
// 如果leftBorder没有被赋值（即target在数组范围的右边，例如数组[3,3],target为4），为了处理情况一
int getLeftBorder(vector<int>& nums, int target) {
    int left = 0;
    int right = nums.size() - 1; // 定义target在左闭右闭的区间里，[left, right]
    int leftBorder = -2; // 记录一下leftBorder没有被赋值的情况
    while (left <= right) {
        int middle = left + ((right - left) / 2);
        if (nums[middle] >= target) { // 寻找左边界，就要在nums[middle] == target的时候更新right
            right = middle - 1;
            leftBorder = right;
        } else {
            left = middle + 1;
        }
    }
    return leftBorder;
}
```

左右边界计算完之后，看一下主体代码，这里把上面讨论的三种情况，都覆盖了

```cpp
class Solution {
public:
    vector<int> searchRange(vector<int>& nums, int target) {
        int leftBorder = getLeftBorder(nums, target);
        int rightBorder = getRightBorder(nums, target);
        // 情况一
        if (leftBorder == -2 || rightBorder == -2) return {-1, -1};
        // 情况三
        if (rightBorder - leftBorder > 1) return {leftBorder + 1, rightBorder - 1};
        // 情况二
        return {-1, -1};
    }
private:
     int getRightBorder(vector<int>& nums, int target) {
        int left = 0;
        int right = nums.size() - 1;
        int rightBorder = -2; // 记录一下rightBorder没有被赋值的情况
        while (left <= right) {
            int middle = left + ((right - left) / 2);
            if (nums[middle] > target) {
                right = middle - 1;
            } else { // 寻找右边界，nums[middle] == target的时候更新left
                left = middle + 1;
                rightBorder = left;
            }
        }
        return rightBorder;
    }
    int getLeftBorder(vector<int>& nums, int target) {
        int left = 0;
        int right = nums.size() - 1;
        int leftBorder = -2; // 记录一下leftBorder没有被赋值的情况
        while (left <= right) {
            int middle = left + ((right - left) / 2);
            if (nums[middle] >= target) { // 寻找左边界，nums[middle] == target的时候更新right
                right = middle - 1;
                leftBorder = right;
            } else {
                left = middle + 1;
            }
        }
        return leftBorder;
    }
};
```

**自己的模板--重点！！！**

```cpp
class Solution {
private:
    int search_left(vector<int>& nums, int l, int r, int x){ 
        while (l <= r) {
            int mid = l + ((r - l) / 2);
            if (nums[mid] >= x) r = mid - 1; 
            else l = mid + 1;
        }
        return l;
    }
    int search_right(vector<int>& nums, int l, int r, int x){ 
        while (l <= r){
            int mid = l + ((r - l) / 2);
            if(nums[mid] > x) r = mid - 1; 
            else l = mid + 1;
        }
        return r;
    }
public:
    vector<int> searchRange(vector<int>& nums, int target) {
        if(nums.size() == 0) return {-1, -1};
        int l = 0, r = nums.size() - 1;
		int l1 = search_left(nums, l, r, target);
		if (l1 >= nums.size() || nums[l1] != target){
            return {-1, -1};
		}
		int l2 = search_right(nums, l, r, target);
		return {l1, l2};
    }
};
```

[789. 数的范围 - AcWing题库](https://www.acwing.com/problem/content/791/)

Y总的模板

```cpp
bool check(int x) {/* ... */} // 检查x是否满足某种性质

// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：
int bsearch_1(int l, int r)
{
    while (l < r)
    {
        int mid = l + r >> 1;
        if (check(mid)) r = mid;    // check()判断mid是否满足性质
        else l = mid + 1;
    }
    return l;
}
// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：
int bsearch_2(int l, int r)
{
    while (l < r)
    {
        int mid = l + r + 1 >> 1;
        if (check(mid)) l = mid;
        else r = mid - 1;
    }
    return l;
}

```

完整代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int q[100100];
int l, r;
int search_left(int l, int r, int x){ 
	while (l < r){
		int mid = (l + r ) >> 1;
		if (q[mid] >= x) r = mid; 
		else l = mid + 1;
	}
	return l;
}
int search_right(int l, int r, int x){ 
	while (l < r){
		int mid = (l + r + 1) >> 1;
		if(q[mid] > x) r = mid - 1; 
		else l = mid;
	}
	return l;
}
int main(){
	int n, m;
	cin >> n >> m;
	for (int i = 0; i < n; i++) cin >> q[i];
	while (m--){
		int x;
        cin >> x;
		l = 0, r = n - 1;
		int l1 = search_left(l, r, x);
		if (q[l1] != x){
		    cout<<"-1 -1"<<endl;
		    continue;
		} else {
		    cout<<l1<<" ";
		}
		l = 0, r = n - 1;
		int l2 = search_right(l, r, x);		
		cout << l2 << endl;
	}
	return 0;
}
```

**自己总结的模板**

[34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/description/)

```cpp
//力扣需要注意vector数组越界的问题，acwing是因为数组开到了 100100
class Solution {
private:
    int search_left(vector<int>& nums, int l, int r, int x) { 
        while (l <= r) {
            int mid = l + ((r - l) / 2);
            if (nums[mid] >= x) r = mid - 1; 
            else l = mid + 1;
        }
        return l;
    }
    int search_right(vector<int>& nums, int l, int r, int x) { 
        while (l <= r) {
            int mid = l + ((r - l) / 2);
            if(nums[mid] > x) r = mid - 1; 
            else l = mid + 1;
        }
        return r;
    }
public:
    vector<int> searchRange(vector<int>& nums, int target) {
        if(nums.size() == 0) return {-1, -1};
        int l = 0, r = nums.size() - 1;
		int l1 = search_left(nums, l, r, target);
		if (l1 >= nums.size() || nums[l1] != target){
            return {-1, -1};
		}
		int l2 = search_right(nums, l, r, target);
		return {l1, l2};
    }
};
```

[789. 数的范围 - AcWing题库](https://www.acwing.com/problem/content/791/)

```cpp
#include<bits/stdc++.h>
using namespace std;
int q[100100];
int l, r;
int search_left(int l, int r, int x){ 
	while (l <= r){
		int mid = l + ((r - l) / 2);
		if (q[mid] >= x) r = mid - 1; 
		else l = mid + 1;
	}
	return l;//r + 1;
}
int search_right(int l, int r, int x){ 
	while (l <= r){
		int mid = l + ((r - l) / 2);
		if(q[mid] > x) r = mid - 1; 
		else l = mid + 1;
	}
	return r;//l - 1;
}
int main(){
	int n, m;
	cin >> n >> m;
	for (int i = 0; i < n; i++) cin >> q[i];
	while (m--){
		int x;
        cin>>x;
		l = 0, r = n - 1;
		int l1 = search_left(l, r, x);
		if (q[l1] != x){
		    cout<<"-1 -1"<<endl;
		    continue;
		} else {
		    cout<<l1<<" ";
		}
		l = 0, r = n - 1;
		int l2 = search_right(l, r, x);		
		cout << l2 << endl;
	}
	return 0;
}
```

# 排序

### 数组中的逆序对

#### 相关链接

+ [数组中的逆序对_牛客题霸](https://www.nowcoder.com/practice/96bd6684e04a44eb80e6a68efc0ec6c5?tpId=295&tqId=23260&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26tab%3D%E7%AE%97%E6%B3%95%E7%AF%87%26topicId%3D295%26fromPut%3Dpc_kol_aaaxiu)

#### 相关题目

在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P mod 1000000007

#### 解题思路

前言-归并排序的实现

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e6+10;
int n;
int q[N]; 
int tmp[N];

void merge_sort(int q[],int l,int r){
     if(l>=r) return ;
     int mid=l + r >>1;
     
     merge_sort(q,l,mid);
     merge_sort(q,mid+1,r);
     
     int i=l,k=0,j=mid+1;
     while(i<=mid&&j<=r){
         if(q[i]<=q[j]) tmp[k++]=q[i++];
         else tmp[k++]=q[j++];
     } 
     while(i<=mid)  tmp[k++]=q[i++];
     while(j<=r)  tmp[k++]=q[j++];
     
     for(i=l,k=0;i<=r;i++,k++) q[i]=tmp[k];
}
int main(){
	cin>>n;
	for(int i=0;i<n;i++) scanf("%d",&q[i]);
	merge_sort(q,0,n-1);
	for(int i=0;i<n;i++) printf("%d ",q[i]); 
	return 0;
}
```

本题做法

```cpp
class Solution {
  private:
    const int mod = 1000000007;
  public:
    int InversePairs(vector<int> data) {
        vector<int> tmp(data.size());
        return mergeSort(0, data.size() - 1, data, tmp);;
    }
    int mergeSort(int l, int r, vector<int>& data, vector<int>& tmp) { //一定要加引用
        if (l >= r) return 0;
        int mid = l + ((r - l) >> 1);

        int res = mergeSort(l, mid, data, tmp) + mergeSort(mid + 1, r, data, tmp);
        res %= mod;
        int i = l, j = mid + 1;
        for (int k = l; k <= r; k++)    tmp[k] = data[k];
        for (int k = l; k <= r; k++) {
            if (i == mid + 1) data[k] = tmp[j++]; // 说明没有遍历完，继续将tmp复制到data
            else if (j == r + 1 || tmp[i] <= tmp[j]) // 说明没有遍历完，继续将tmp复制到data
                data[k] = tmp[i++];
            else {
                data[k] = tmp[j++];
                res += mid - i + 1;
            }
        }
        return res % mod;
    }
};
```

### 数据流中的中位数

#### 相关链接

+ [数据流中的中位数_牛客题霸](https://www.nowcoder.com/practice/9be0172896bd43948f8a32fb954e1be1?tpId=295&tqId=23457&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26tab%3D%E7%AE%97%E6%B3%95%E7%AF%87%26topicId%3D295%26fromPut%3Dpc_kol_aaaxiu)

#### 相关题目

如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。

#### 解题思路

插入排序

```cpp
class Solution {
public:
    vector<int> val;
    void Insert(int num) {
        if(val.empty()) val.push_back(num);
        else {
            int i = 0;
            for(; i < val.size(); i++) 
                if(num <= val[i]) break;
            val.insert(val.begin() + i, num);
        }
    }

    double GetMedian() { 
        int n = val.size();
        if( n % 2 == 1) {
            return double(val[n / 2]);
        } else {
            // 需要注意，前面不能省略a，b直接+，结果会错误
            double a = val[n / 2];
            double b = val[n / 2 - 1];
            return (a + b) / 2;
        }
    }
};
```

### 寻找第K大

#### 相关链接

+ [寻找第K大_牛客题霸](https://www.nowcoder.com/practice/e016ad9b7f0b45048c58a9f27ba618bf?tpId=295&tqId=44581&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26tab%3D%E7%AE%97%E6%B3%95%E7%AF%87%26topicId%3D295%26fromPut%3Dpc_kol_aaaxiu)

#### 相关思路

有一个整数数组，请你根据快速排序的思路，找出数组中第 k 大的数。

给定一个整数数组 a ,同时给定它的大小n和要找的 k ，请返回第 k 大的数(包括重复的元素，不用去重)，保证答案存在。

#### 解题思路

```cpp
class Solution {
  public:
    int partition(vector<int>& a, int low, int high, int k) {
        swap(a[low], a[rand() % (high - low + 1) + low]); //随机快排划分
        int v = a[low], i = low + 1,j = high;
        while (true) {
            while (j >= low + 1 && a[j] < v) j--; //小于标杆的在右
            while (i <= high && a[i] > v) i++;//大于标杆的在左
            if (i > j) break;
            swap(a[i], a[j]);
            i++, j--;
        }
        swap(a[low], a[j]);
        if (j + 1 == k) return a[j]; //从0开始，所以为第j+1大
        //继续划分
        else if (j + 1 < k) return partition(a, j + 1, high, k);
        else return partition(a, low, j - 1, k);
    }
    int findKth(vector<int> a, int n, int K) {
        return partition(a, 0, n - 1, K);
    }
};
```

