---
date: 2021-11-01 14:54:44
author: WangXinYi
img: /images/homePage/设计模式.webp
top: false
summary: 设计模式
categories:
  - 设计模式
tags:
  - 设计模式
typora-root-url: ..
---

# 设计模式

## 单例模式

单例模式就是确保一个类在**任何情况下**都**只有一个实例**，并**提供一个全局访问点**。

### 一、单例模式的实现

**单例的实现主要是通过以下两个步骤**：

1. 将该类的构造方法定义为私有方法，这样其他处的代码就无法通过调用该类的构造方法来实例化该类的对象，只有通过该类提供的静态方法来得到该类的唯一实例；
2. 在该类内提供一个静态方法，当我们调用这个方法时，如果类持有的引用不为空就返回这个引用，如果类保持的引用为空就创建该类的实例并将实例的引用赋予该类保持的引用。

### 二、单例模式的应用场景

例如：windows桌面打开一个回收站，当我们试图再次打开一个新的回收站时，Windows系统并不会为你弹出一个新的回收站窗口。也就是说在整个系统运行的过程中，系统只维护一个回收站的实例。这就是一个典型的单例模式运用。我们在实际使用中并不存在需要同时打开两个回收站窗口的必要性。假如我每次创建回收站时都需要消耗大量的资源，而每个回收站之间资源是共享的，那么在没有必要多次重复创建该实例的情况下，创建了多个实例，这样做就会给系统造成不必要的负担，造成资源浪费。

例如：网站的计数器，一般也是采用单例模式实现，如果你存在多个计数器，每一个用户的访问都刷新计数器的值，这样的话你的实计数的值是难以同步的。但是如果采用单例模式实现就不会存在这样的问题，而且还可以避免线程安全问题。同样多线程的线程池的设计一般也是采用单例模式，这是由于线程池需要方便对池中的线程进行控制

  **适用场景：**

+ **1.需要生成唯一序列的环境**
+ **2.需要频繁实例化然后销毁的对象。**
+ **3.创建对象时耗时过多或者耗资源过多，但又经常用到的对象。** 
+ **4.方便资源相互通信的环境**

#### **1、饿汉式**

```c#
// 饿汉式单例
public class Singleton1 {
 
    // 指向自己实例的私有静态引用，主动创建
    private static Singleton1 singleton1 = new Singleton1();
 
    // 私有的构造方法
    private Singleton1(){}
 
    // 以自己实例为返回值的静态的公有方法，静态工厂方法
    public static Singleton1 getSingleton1(){
        return singleton1;
    }
}
```

我们知道，**类加载的方式是按需加载，且加载一次**。。因此，在上述单例类被加载时，就会实例化一个对象并交给自己的引用，供系统使用；而且，由于这个类在整个生命周期中只会被加载一次，因此只会创建一个实例，即能够充分保证单例。

优点：这种写法比较简单，就是在类装载的时候就完成实例化。避免了线程同步问题。

缺点：在类装载的时候就完成实例化，没有达到Lazy Loading的效果。如果从始至终从未使用过这个实例，则会造成内存的浪费。

Java实现

<img src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20230319095148458.png" alt="" style="zoom: 80%;" />

问题1：防止子类重写破坏单例

问题2：就是加入最下面的方法

```java
public Object readResovle() {
	return INSTANCE
}
```

#### **2、懒汉式**

```c#
// 懒汉式单例
public class Singleton2 {
 
    // 指向自己实例的私有静态引用
    private static Singleton2 singleton2;
 
    // 私有的构造方法
    private Singleton2(){}
 
    // 以自己实例为返回值的静态的公有方法，静态工厂方法
    public static Singleton2 getSingleton2(){
        // 被动创建，在真正需要使用时才去创建
        if (singleton2 == null) {
            singleton2 = new Singleton2();
        }
        return singleton2;
    }
}
```

我们从懒汉式单例可以看到，单例实例被**延迟加载**，即只有在真正使用的时候才会实例化一个对象并交给自己的引用。

这种写法起到了Lazy Loading的效果，但是只能在单线程下使用。如果在多线程下，一个线程进入了if (singleton == null)判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句，这时便会产生多个实例。所以在多线程环境下不可使用这种方式。

#### **3、双重加锁机制**

```c#
public class Singleton {
    private static Singleton instance;
    //程序运行时创建一个静态只读的进程辅助对象
    private static readonly object syncRoot = new object();
    private Singleton() { }
    public static Singleton GetInstance()
    {
        //先判断是否存在，不存在再加锁处理
        if (instance == null)
        {
            //在同一个时刻加了锁的那部分程序只有一个线程可以进入
            lock (syncRoot)
            {
                if (instance == null)
                {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```

Double-Check概念对于多线程开发者来说不会陌生，如代码中所示，我们进行了两次if (singleton == null)检查，这样就可以保证线程安全了。这样，实例化代码只用执行一次，后面再次访问时，判断if (singleton == null)，直接return实例化对象。

使用双重检测同步延迟加载去创建单例的做法是一个非常优秀的做法，**其不但保证了单例，而且切实提高了程序运行效率**

优点：线程安全；延迟加载；效率较高。

java实现

<img src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20230319100230399.png" alt="" style="zoom: 67%;" />

### 三、单例模式的优缺点

**优点**：

+ 在内存中只有一个对象，节省内存空间；
+ 避免频繁的创建销毁对象，可以提高性能；
+ 避免对共享资源的多重占用，简化访问；
+ 为整个系统提供一个全局访问点。

**缺点**：

+  不适用于变化频繁的对象；
+ 滥用单例将带来一些负面问题，如为了节省资源将数据库连接池对象设计为的单例类，可能会导致共享连接池对象的程序过多而出现连接池溢出；
+ 如果实例化的对象长时间不被利用，系统会认为该对象是垃圾而被回收，这可能会导致对象状态的丢失

## 建造者模式

### 一、为什么要有建造者模式

**建造者模式就是用来方便我们创建一个对象的**。

在软件开发过程中，经常需要新建对象并给对象的属性赋值。当对象的属性比较多时，创建对象的过程会变得比较烦琐。

先建造空对象，然后在不断调用set方法为对象属性赋值是一种常见的建造对象的方式，如下面代码所示。

```java
User user01 = new User();
user01.setName("Candy");
user01.setEmail("candy@sunnyschool.com");
user01.setAge(7);
user01.setSex(1);
user01.setSchoolName("Sunny School");
```

这种方式需要了解对象的所有属性细节，是和对象的属性耦合的，而且这个过程中可能会导致属性的遗忘。

使用具有多个入参的构造方法直接建造对象也是一种常见的建造对象的方式，如下所示。

```text
User user02 = new User("Candy", "candy@sunnyschool.com", 7, 1, "Sunny School");
```

这种情况下，为了能适应多种入参组合，通常需要重载出大量的构造方法。

### 二、建造者模式的实现

建造者模式给我们提供了另一种建造对象的思路。

使用建造者模式，对象的建造细节均交给建造者来完成，调用者只需要掌控总体流程即可，而不需要了解被建造对象的细节。

建造者类一般包含两类方法：

+ 一类是属性设置方法。这类方法一般有多个，可以接受不同类型参数来设置建造者的属性。
+ 一类是目标对象生成方法。该类方法一般只有一个，即根据目前建造者中的属性创建出一个目标对象。

建造者模式给我们提供了另一种建造对象的思路。使用建造者模式，对象的建造细节均交给建造者来完成，调用者只需要掌控总体流程即可，而不需要了解被建造对象的细节。

例如，我们编写一个UserBuilder接口作为建造User对象的接口，如下所示。

```java
public interface UserBuilder {

    public UserBuilder setEmail(String email);

    public UserBuilder setAge(Integer age);

    public UserBuilder setSex(Integer sex);

    public User build();
}
```

然后我们继承UserBuilder接口编写一个SunnySchoolUserBuilder类，它用来建造Sunny School的用户，如下所示。

```java
public class SunnySchoolUserBuilder implements UserBuilder {
    private String name;
    private String email;
    private Integer age;
    private Integer sex;
    private String schoolName;

    public SunnySchoolUserBuilder(String name) {
        this.name = name;
    }

    public SunnySchoolUserBuilder setEmail(String email) {
        this.email = email;
        return this;
    }

    public SunnySchoolUserBuilder setAge(Integer age) {
        this.age = age;
        return this;
    }

    public SunnySchoolUserBuilder setSex(Integer sex) {
        this.sex = sex;
        return this;
    }

    public User build() {
        if (this.name != null && this.email == null) {
            this.email = this.name.toLowerCase().replace(" ", "").concat("@sunnyschool.com");
        }
        if (this.age == null) {
            this.age = 7;
        }
        if (this.sex == null) {
            this.sex = 0;
        }
        this.schoolName = "Sunny School";
        return new User(name, email, age, sex, schoolName);
    }
}
```

这样一来，我们可以灵活地建造对象。

```java
// 用匿名建造者建造一个对象
User user03 = new SunnySchoolUserBuilder("Candy").setSex(1).build();

// 分步设置建造者属性，建造一个对象
UserBuilder userBuilder04 = new SunnySchoolUserBuilder("Eric");
userBuilder04.setEmail("supereric@abc.com").build();
User user04 = userBuilder04.build();
```

### 三、建造者模式的优点

基于建造者创建对象时，有以下几个优点：

+ 使用建造者时十分灵活，**可以一次也可以分多次地设置被被建造对象的属性**。
+ 调用者只需要调用建造者的主要流程而**不需要关心建造对象**的细节。
+ **可以很方便地修改建造者的行为**，从而建造出不同的对象。

## 适配器模式

### 一、适配器模式的原理和角色

**将一个类的接口转换成客户希望的另一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的哪些类可以一起工作。**

**角色**

+ 目标抽象类：Target，该角色把其他类转换为我们期望的接口，可以是一个抽象类或接口，也可以是具体类。
+ 被适配者: Adaptee ，原有的接口，也是希望被适配的接口。
+ 适配器： Adapter, 将被适配者和目标抽象类组合到一起的类。

### 二、适配器模式的实现

**被适配类：Adaptee**

```java
public class Adaptee {
    public void adapterRequest(){
        System.out.println("被适配者的方法");
    }
}
```

**目标抽象：Target接口**

```java
public interface Target {
    void request();
}
```

怎么才可以在目标接口中的 request() 调用 Adaptee 的 adapteeRequest() 方法呢？

通过一个适配器类，实现 Target 接口，同时继承了 Adaptee 类，然后在实现的 request() 方法中调用父类的 adapteeRequest() 即可实现

**Adapter**类继承了Adaptee类，所以称为**类适配器**（通过继承来实现）

```java
public class Adapter extends Adaptee implements Target {
	@Override
    public void request() {
        super.adapterRequest();
    }
}
```

### **三、示例**

我们平时用充电器给手机充电，充电器可能需要将220v的电压转换成5v的电压，我们才能给手机正常充电。

**AC220类（Adaptee），被适配者类，原有220v的电压。**

```java
public class AC220 {
    public int outputAC220V(){
        int output = 220;
        System.out.println("输出交流电"+output+"V");
        return output;
    }
}
```


**DC5类（Target接口），目标接口，需要转换成5v的电压。**

```java
public interface DC5 {
    int outputDC5V();
}
```

**PowerAdapter类（Adapter类），适配器类，将220v的电压转换成5v的电压。**

```java
public class PowerAdapter implements DC5 {
    private AC220 ac220 = new AC220();
	public int outputDC5V() {
        int adapterInput = ac220.outputAC220V();

        //变压器...
        int adapterOutput = adapterInput/44;

        System.out.println("使用PowerAdapter输入AC"+adapterInput+"V"+"输出DC"+adapterOutput+"V");
        return adapterInput;
	}
}
```
应用层代码：

```java
public class Test {
    public static void main(String[] args) {
        DC5 dc5 = new PowerAdapter();
        dc5.outputDC5V();
    }
}
```



终止模式之两阶段终止模式

同步模式之保护性暂停

Balking（犹豫模式）

