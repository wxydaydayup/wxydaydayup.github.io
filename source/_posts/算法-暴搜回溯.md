---
img: /images/homePage/暴搜回溯.webp
summary: 算法-暴搜回溯
categories:
  - 算法
  - C++
  - 暴搜回溯
tags:
  - 算法
  - C++
  - 暴搜回溯
typora-root-url: ..
date: 2021-10-20 12:06:57
---

## 暴搜回溯

### 概述

回溯法，一般可以解决如下几种问题：

+ 组合问题：N个数里面按一定规则找出k个数的集合
+ 排列问题：N个数按一定规则全排列，有几种排列方式
+ 切割问题：一个字符串按一定规则有几种切割方式
+ 子集问题：一个N个数的集合里有多少符合条件的子集
+ 棋盘问题：N皇后，解数独等等

**组合是不强调元素顺序的，排列是强调元素顺序**。

分析完过程，回溯算法模板框架如下：

```cpp
void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}
```

回溯法抽象为树形结构后，其遍历过程就是：**for循环横向遍历，递归纵向遍历，回溯不断调整结果集**。

**组合问题**

一、先看是否是多个集合，再看是否重复

+ 是一个集合来求组合的话，并且不能重复就需要`startIndex`，例如：组合总和(无重复元素-无限制选取)**，**组合总和(无重复元素-有限制选取)，**startIndex 就是防止出现重复的组合，`for`循环从`startIndex`开始 。**
+ 如果是多个集合取组合，各个集合之间相互不影响，那么就不用startIndex，例如：电话号码的字母组合

二、是否有限制(一个元素不能选多次)

+ 有限制(一个元素不能选多次)，递归时则 i + 1；
+ 无限制(一个元素不能选多次)，递归时则 i 保持不变；

三、**树层去重--**树层上是否需要去重复

+ 树层上需要去重复则`if (i > 0 && candidates[i] == candidates[i - 1] && used[i - 1] == false) continue;`

**排列问题**

一、与组合问题的区分点

+ 每层都是从 0 开始搜索而不是 startIndex
+ 需要 used 数组记录 path 里都放了哪些元素了

二、树层上是否需要去重复

+ 树层上需要去重复则`if (i > 0 && nums[i] == nums[i - 1] && used[i - 1] == false) continue;`

## 组合问题

### 组合理论

#### 相关链接

+ [77. 组合](https://leetcode.cn/problems/combinations/description/)

#### 相关题目

给定两个整数 `n` 和 `k`，返回范围 `[1, n]` 中所有可能的 `k` 个数的组合。

你可以按 **任何顺序** 返回答案。

**示例 1：**

```
输入：n = 4, k = 2
输出：
[
  [2,4],
  [3,4],
  [2,3],
  [1,2],
  [1,3],
  [1,4],
]
```

#### 解题思路

把组合问题抽象为如下树形结构：

<img src="/images/%E7%AE%97%E6%B3%95-%E6%9A%B4%E6%90%9C%E5%9B%9E%E6%BA%AF/image-20221224113508729.png" alt="解题思路" style="zoom:70%;box-shadow:rgba(0,0,0,0) 0 0px 0px 0px;" />

**每次从集合中选取元素，可选择的范围随着选择的进行而收缩，调整可选择的范围**。

**图中可以发现n相当于树的宽度，k相当于树的深度，图中每次搜索到了叶子节点，我们就找到了一个结果**。

相当于只需要把达到叶子节点的结果收集起来，就可以求得 n个数中k个数的组合集合。

1. 递归函数的返回值以及参数

在这里要定义两个全局变量，一个用来存放符合条件单一结果，一个用来存放符合条件结果的集合。

```
vector<vector<int>> result; // 存放符合条件结果的集合
vector<int> path; // 用来存放符合条件结果
```

既然是集合n里面取k个数，那么n和k是两个int型的参数, 然后还需要一个参数，为int型变量startIndex，**startIndex 就是防止出现重复的组合**。

2. 回溯函数终止条件

path这个数组的大小如果达到k，说明我们找到了一个子集大小为k的组合了，在图中path存的就是根节点到叶子节点的路径。

所以终止条件代码如下：

```cpp
if (path.size() == k) {
    result.push_back(path);
    return;
}
```

3. 单层搜索的过程

回溯法的搜索过程就是一个树型结构的遍历过程，在如下图中，可以看出for循环用来横向遍历，递归的过程是纵向遍历。

<img src="/images/%E7%AE%97%E6%B3%95-%E6%9A%B4%E6%90%9C%E5%9B%9E%E6%BA%AF/image-20221224114715345.png" alt="树型结构" style="zoom:70%;box-shadow:rgba(0,0,0,0) 0 0px 0px 0px;" />

如此我们才遍历完图中的这棵树。

for循环每次从startIndex开始遍历，然后用path保存取到的节点i。

代码如下：

```cpp
for (int i = startIndex; i <= n; i++) { // 控制树的横向遍历
    path.push_back(i); // 处理节点 
    backtracking(n, k, i + 1); // 递归：控制树的纵向遍历，注意下一层搜索要从i+1开始
    path.pop_back(); // 回溯，撤销处理的节点
}
```

完整代码如下：

```cpp
class Solution {
private:
    vector<vector<int>> res;
    vector<int> path;
    void dfs(int n, int k, int startIndex){
        if(path.size() == k){
            res.push_back(path);
            return;
        }
        for(int i = startIndex; i <= n; i++){
            path.push_back(i);
            dfs(n, k, i + 1);
            path.pop_back();
        }
    }
public:
    vector<vector<int>> combine(int n, int k) {
        dfs(n, k, 1);
        return res;
    }
};
```

剪枝优化：

举一个例子，n = 4，k = 4的话，那么第一层for循环的时候，从元素2开始的遍历都没有意义了。 在第二层for循环，从元素3开始的遍历都没有意义了。

<img src="/images/%E7%AE%97%E6%B3%95-%E6%9A%B4%E6%90%9C%E5%9B%9E%E6%BA%AF/image-20221224115955108.png" alt="剪枝优化" style="zoom:67%;box-shadow:rgba(0,0,0,0) 0 0px 0px 0px;" />

**如果for循环选择的起始位置之后的元素个数 已经不足 我们需要的元素个数了，那么就没有必要搜索了**。

1. 已经选择的元素个数：path.size();
2. 所需需要的元素个数为: k - path.size();
3. 列表中剩余元素（n-i） >= 所需需要的元素个数（k - path.size()）
4. 在集合n中至多要从该起始位置 : i <= n - (k - path.size()) + 1，开始遍历

为什么有个+1呢，因为包括起始位置，我们要是一个左闭的集合。

只需要将for循环进行调整

```cpp
for (int i = startIndex; i <= n - (k - path.size()) + 1; i++) { // 优化的地方
```

### 组合总和(无重复元素-有限制选取)

#### 相关链接

+ [216. 组合总和 III ](https://leetcode.cn/problems/combination-sum-iii/description/)

#### 相关题目

找出所有相加之和为 `n` 的 `k` 个数的组合，且满足下列条件：

+ 只使用数字1到9
+ 每个数字 **最多使用一次** 

返回 所有可能的有效组合的列表 。该列表不能包含相同的组合两次，组合可以以任何顺序返回。

**示例 1:**

```
输入: k = 3, n = 7
输出: [[1,2,4]]
解释:
1 + 2 + 4 = 7
没有其他符合的组合了。
```

#### 解题思路

1. 确定递归函数参数

依然定义path 和 result为全局变量。

```cpp
vector<vector<int>> result; // 存放结果集
vector<int> path; // 符合条件的结果
```

接下来还需要如下参数：

+ targetSum（int）目标和，也就是题目中的n。
+ k（int）就是题目中要求k个数的集合。
+ sum（int）为已经收集的元素的总和，也就是path里元素的总和。
+ startIndex（int）为下一层for循环搜索的起始位置。

2. 确定终止条件

k其实就已经限制树的深度，因为就取k个元素，树再往下深了没有意义。

所以如果path.size() 和 k相等了，就终止。

如果此时path里收集到的元素和（sum） 和targetSum（就是题目描述的n）相同了，就用result收集当前的结果。

```cpp
if (path.size() == k) {
    if (sum == targetSum) result.push_back(path);
    return; // 如果path.size() == k 但sum != targetSum 直接返回
}
```

3. 单层搜索过程

处理过程就是 path收集每次选取的元素，相当于树型结构里的边，sum来统计path里元素的总和。

完整代码如下：

```cpp
class Solution {
private:
    vector<vector<int>> res;
    vector<int> path;
    void dfs(int target,int sum,int k, int startIndex){
        if(path.size() == k){
            if(sum == target) res.push_back(path);
            return;
        }
        for(int i = startIndex; i <= 9; i++){
            path.push_back(i);
            dfs(target, sum + i, k, i + 1);
            path.pop_back();
        }
    }
public:
    vector<vector<int>> combinationSum3(int k, int n) {
        dfs(n, 0, k, 1);
        return res;
    }
};
```

### 电话号码的字母组合

#### 相关链接

+ [17. 电话号码的字母组合](https://leetcode.cn/problems/letter-combinations-of-a-phone-number/)

#### 相关题目

给定一个仅包含数字 `2-9` 的字符串，返回所有它能表示的字母组合。答案可以按 **任意顺序** 返回。

给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。

<img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/11/09/200px-telephone-keypad2svg.png" alt="电话对应图" style="zoom:150%;box-shadow:rgba(0,0,0,0) 0 0px 0px 0px;" />

**示例 1：**

```
输入：digits = "23"
输出：["ad","ae","af","bd","be","bf","cd","ce","cf"]
```

#### 解题思路

+ 是一个集合来求组合的话，就需要startIndex，例如：**组合总和(无重复元素-无限制选取)**，**组合总和(无重复元素-有限制选取)**

+ 如果是多个集合取组合，各个集合之间相互不影响，那么就不用startIndex，例如：**电话号码的字母组合**


<img src="/images/%E7%AE%97%E6%B3%95-%E6%9A%B4%E6%90%9C%E5%9B%9E%E6%BA%AF/image-20221224172326044.png" alt="解题思路" style="zoom:67%;box-shadow:rgba(0,0,0,0) 0 0px 0px 0px;" />

1. 确定递归函数参数

首先需要一个字符串s来收集叶子节点的结果，然后用一个字符串数组result保存起来，这两个变量我依然定义为全局。

再来看参数，参数指定是有题目中给的string digits，然后还要有一个参数就是int型的index。

这个index是记录遍历第几个数字了，就是用来遍历digits的（题目中给出数字字符串），同时index也表示树的深度。

2. 确定终止条件

例如输入用例"23"，两个数字，那么根节点往下递归两层就可以了，叶子节点就是要收集的结果集。

那么终止条件就是如果index 等于 输入的数字个数（digits.size）了（本来index就是用来遍历digits的）。

然后收集结果，结束本层递归。

代码如下：

```cpp
if (index == digits.size()) {
    result.push_back(s);
    return;
}
```

3. 确定单层遍历逻辑

首先要取index指向的数字，并找到对应的字符集（手机键盘的字符集）。

然后for循环来处理这个字符集，代码如下：

```cpp
int digit = digits[index] - '0';        // 将index指向的数字转为int
string letters = letterMap[digit];      // 取数字对应的字符集
for (int i = 0; i < letters.size(); i++) {
    s.push_back(letters[i]);            // 处理
    backtracking(digits, index + 1);    // 递归，注意index+1，一下层要处理下一个数字了
    s.pop_back();                       // 回溯
}
```

完整代码如下：

```cpp
class Solution {
private:
    const string letterMap[10] = {
        "", // 0
        "", // 1
        "abc", // 2
        "def", // 3
        "ghi", // 4
        "jkl", // 5
        "mno", // 6
        "pqrs", // 7
        "tuv", // 8
        "wxyz", // 9
    };
public:
    vector<string> result;
    string s;
    void getCombinations(string digits, int index) { 
        if (index == digits.size()) {
            result.push_back(s);
            return;
        }

        int digit = digits[index] - '0';
        string letters = letterMap[digit];
        for (int i = 0; i < letters.size(); i++) {
            s.push_back(letters[i]);
            getCombinations(digits, index + 1); 
            s.pop_back();
        }
    }
    vector<string> letterCombinations(string digits) {
        if (digits.size() == 0) {
            return result;
        }
        getCombinations(digits, 0);
        return result;
    }
};
```

省略回溯版本

```cpp
class Solution {
private:
    const string letterMap[10] = {
        "", // 0
        "", // 1
        "abc", // 2
        "def", // 3
        "ghi", // 4
        "jkl", // 5
        "mno", // 6
        "pqrs", // 7
        "tuv", // 8
        "wxyz", // 9
    };
public:
    vector<string> result;
    void getCombinations(string digits, int index, string s) { 
        if (index == digits.size()) {
            result.push_back(s);
            return;
        }

        int digit = digits[index] - '0';
        string letters = letterMap[digit];
        for (int i = 0; i < letters.size(); i++) {
            getCombinations(digits, index + 1, s + letters[i]); 
        }
    }
    vector<string> letterCombinations(string digits) {
        if (digits.size() == 0) {
            return result;
        }
        getCombinations(digits, 0, "");
        return result;
    }
};
```

### 组合总和(无重复元素-无限制选取)

#### 相关链接

+ [39. 组合总和 ](https://leetcode.cn/problems/combination-sum/description/)

#### 相关题目

给你一个 **无重复元素** 的整数数组 `candidates` 和一个目标整数 `target` ，找出 `candidates` 中可以使数字和为目标数 `target` 的 所有 **不同组合** ，并以列表形式返回。你可以按 **任意顺序** 返回这些组合。

`candidates` 中的 **同一个** 数字可以 **无限制重复被选取** 。如果至少一个数字的被选数量不同，则两种组合是不同的。 

对于给定的输入，保证和为 `target` 的不同组合数少于 `150` 个。

**示例 1：**

```
输入：candidates = [2,3,6,7], target = 7
输出：[[2,2,3],[7]]
解释：
2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。
7 也是一个候选， 7 = 7 。
仅有这两种组合。
```

#### 解题思路

如果是一个集合来求组合的话，就需要startIndex，例如：77.组合，216.组合总和III 。

如果是多个集合取组合，各个集合之间相互不影响，那么就不用startIndex，例如：17.电话号码的字母组合。

1. 确定递归函数参数

这里依然是定义两个全局变量，二维数组result存放结果集，数组path存放符合条件的结果。（这两个变量可以作为函数参数传入）

首先是题目中给出的参数，集合candidates, 和目标值target。

此外我还定义了int型的sum变量来统计单一结果path里的总和，其实这个sum也可以不用，用target做相应的减法就可以了，最后如何target==0就说明找到符合的结果了，但为了代码逻辑清晰，这里依然用了sum，整体代码不使用sum。

代码如下：

```cpp
vector<vector<int>> result;
vector<int> path;
void backtracking(vector<int>& candidates, int target, int sum, int startIndex)
```

2. 确定终止条件

从叶子节点可以清晰看到，终止只有两种情况，sum大于target和sum等于target。

sum等于target的时候，需要收集结果，代码如下：

```cpp
if (sum > target) {
    return;
}
if (sum == target) {
    result.push_back(path);
    return;
}
```

3. 确定单层遍历逻辑

```cpp
for (int i = startIndex; i < candidates.size(); i++) {
    sum += candidates[i];
    path.push_back(candidates[i]);
    backtracking(candidates, target, sum, i); // 关键点:不用i+1了，表示可以重复读取当前的数
    sum -= candidates[i];   // 回溯
    path.pop_back();        // 回溯
}
```

完整代码如下：

```cpp
class Solution {
private:
    vector<vector<int>> res;
    vector<int> path;
    void dfs(vector<int>& candidates, int target,int startIndex){
        if(target < 0) return;
        if(target == 0){
            res.push_back(path);
            return;
        }
        for(int i = startIndex; i < candidates.size(); i++){
            path.push_back(candidates[i]);
            dfs(candidates, target - candidates[i], i);
            path.pop_back();
        }
    }
public:
    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        dfs(candidates, target, 0);
        return res;
    }
};
```

#### 剪植优化

以及上面的版本一的代码大家可以看到，对于sum已经大于target的情况，其实是依然进入了下一层递归，只是下一层递归结束判断的时候，会判断sum > target的话就返回。

其实如果已经知道下一层的sum会大于target，就没有必要进入下一层递归了。

那么可以在for循环的搜索范围上做做文章了。

**对总集合排序之后，如果下一层的sum（就是本层的 sum + candidates[i]）已经大于target，就可以结束本轮for循环的遍历**。

```cpp
class Solution {
private:
    vector<vector<int>> result;
    vector<int> path;
    void backtracking(vector<int>& candidates, int target, int sum, int startIndex) {
        if (sum == target) {
            result.push_back(path);
            return;
        }

        // 如果 sum + candidates[i] > target 就终止遍历
        for (int i = startIndex; i < candidates.size() && sum + candidates[i] <= target; i++) {
            sum += candidates[i];
            path.push_back(candidates[i]);
            backtracking(candidates, target, sum, i);
            sum -= candidates[i];
            path.pop_back();

        }
    }
public:
    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        sort(candidates.begin(), candidates.end()); // 需要排序
        backtracking(candidates, target, 0, 0);
        return result;
    }
};
```

### 组合总和(有重复元素-无重复组合)

#### 相关链接

+ [40. 组合总和 II ](https://leetcode.cn/problems/combination-sum-ii/)

#### 相关题目

给定一个候选人编号的集合 `candidates` 和一个目标数 `target` ，找出 `candidates` 中所有可以使数字和为 `target` 的组合。

`candidates` 中的每个数字在每个组合中只能使用 **一次** 。

**注意：**解集不能包含重复的组合。 

**示例 1:**

```
输入: candidates = [10,1,2,7,6,1,5], target = 8,
输出:
[
    [1,1,6],
    [1,2,5],
    [1,7],
    [2,6]
]
```

#### 解题思路

这道题目和 39.组合总和 如下区别：

1. 本题candidates 中的每个数字在每个组合中只能使用一次。
2. 本题数组candidates的元素是有重复的，而 39.组合总和 是无重复元素的数组candidates

最后本题和 39.组合总和 要求一样，解集不能包含重复的组合。

**本题的难点在于区别2中：集合（数组candidates）有重复元素，但还不能有重复的组合**。

一些同学可能想了：我把所有组合求出来，再用set或者map去重，这么做很容易超时！所以要在搜索的过程中就去掉重复组合。

都知道组合问题可以抽象为树形结构，那么“使用过”在这个树形结构上是有两个维度的，一个维度是同一树枝上使用过，一个维度是同一树层上使用过。**没有理解这两个层面上的“使用过” 是造成大家没有彻底理解去重的根本原因。**

那么问题来了，我们是要同一树层上使用过，还是同一树枝上使用过呢？

回看一下题目，元素在同一个组合内是可以重复的，怎么重复都没事，但两个组合不能相同。

**所以我们要去重的是同一树层上的“使用过”，同一树枝上的都是一个组合里的元素，不用去重**。

为了理解去重我们来举一个例子，candidates = [1, 1, 2], target = 3，（方便起见candidates已经排序了）

**强调一下，树层去重的话，需要对数组排序！**选择过程树形结构如图所示：

<img src="/images/%E7%AE%97%E6%B3%95-%E6%9A%B4%E6%90%9C%E5%9B%9E%E6%BA%AF/image-20230414184812237.png" alt="树形结构" style="zoom: 67%;box-shadow: rgba(0, 0, 0, 0) 0px 0px 0px 0px;" />

可以看到图中，每个节点相对于 39.组合总和 多加了used数组，这个used数组下面会重点介绍。

1. 确定递归函数参数

此题还需要加一个bool型数组used，用来记录同一树枝上的元素是否使用过。

这个集合去重的重任就是used来完成的。

代码如下：

```cpp
vector<vector<int>> result; // 存放组合集合
vector<int> path;           // 符合条件的组合
void backtracking(vector<int>& candidates, int target, int sum, int startIndex, vector<bool>& used) {
```

2. 确定终止条件

终止条件为 `sum > target` 和 `sum == target`。

代码如下：

```cpp
if (sum > target) { // 这个条件其实可以省略
    return;
}
if (sum == target) {
    result.push_back(path);
    return;
}
```

`sum > target` 这个条件其实可以省略，因为在递归单层遍历的时候，会有剪枝的操作，下面会介绍到。

3. 确定单层遍历逻辑

前面我们提到：要去重的是“同一树层上的使用过”，如何判断同一树层上元素（相同的元素）是否使用过了呢。

**如果`candidates[i] == candidates[i - 1]` 并且 `used[i - 1] == false`，就说明：前一个树枝，使用了candidates[i - 1]，也就是说同一树层使用过candidates[i - 1]**。此时for循环里就应该做continue的操作。

我在图中将used的变化用橘黄色标注上，可以看出在candidates[i] == candidates[i - 1]相同的情况下：

+ used[i - 1] == true，说明同一树枝candidates[i - 1]使用过
+ used[i - 1] == false，说明同一树层candidates[i - 1]使用过

为什么 used[i - 1] == false 就是同一树层呢？

+ 因为同一树层，used[i - 1] == false 才能表示，当前取的 candidates[i] 是从 candidates[i - 1] 回溯而来的。
+ 而 used[i - 1] == true，说明是进入下一层递归，去下一个数，所以是树枝上

如图所示：

<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20221021163812.png" alt="" style="zoom: 40%; box-shadow: rgba(0, 0, 0, 0) 0px 0px 0px 0px;" />

完整代码如下，已经剪枝了：

```cpp
class Solution {
private:
    vector<vector<int>> result;
    vector<int> path;
    void backtracking(vector<int>& candidates, int target, int startIndex, vector<bool>& used) {
        if (target == 0) {
            result.push_back(path);
            return;
        }
        for (int i = startIndex; i < candidates.size() && target - candidates[i] >= 0; i++) {
            if (i > 0 && candidates[i] == candidates[i - 1] && used[i - 1] == false) continue;
            path.push_back(candidates[i]);
            used[i] = true;
            backtracking(candidates, target - candidates[i] , i + 1, used); 
            used[i] = false;
            path.pop_back();
        }
    }

public:
    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {
        vector<bool> used(candidates.size(), false);
        sort(candidates.begin(), candidates.end());
        backtracking(candidates, target, 0,  used);
        return result;
    }
};
```

+ 组合问题用startIndex来去重也是可以的， 就不用used数组了，因为递归的时候下一个startIndex是i+1而不是0。
+ 排列问题，每次要从0开始遍历，为了跳过已入栈的元素，需要使用used。

```cpp
class Solution {
private:
    vector<vector<int>> result;
    vector<int> path;
    void backtracking(vector<int>& candidates, int target, int startIndex) {
        if (target == 0) {
            result.push_back(path);
            return;
        }
        for (int i = startIndex; i < candidates.size() && target - candidates[i] >= 0; i++) {
            if (i > startIndex && candidates[i] == candidates[i - 1] ) continue;
            path.push_back(candidates[i]);
            backtracking(candidates, target - candidates[i] , i + 1); 
            path.pop_back();
        }
    }
public:
    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {
        vector<bool> used(candidates.size(), false);
        sort(candidates.begin(), candidates.end());
        backtracking(candidates, target, 0);
        return result;
    }
};
```

## 排列问题

### 全排列(无重复元素)

#### 相关链接

+ [46. 全排列](https://leetcode.cn/problems/permutations/)

#### 相关思路

给定一个不含重复数字的数组 `nums` ，返回其 所有可能的全排列 。你可以 **按任意顺序** 返回答案。

**示例 1：**

```
输入：nums = [1,2,3]
输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
```

#### 解题思路

排列问题的不同：

+ 每层都是从0开始搜索而不是startIndex
+ 需要used数组记录path里都放了哪些元素了

递归思路：

1. 递归函数参数

**首先排列是有序的，也就是说 [1,2] 和 [2,1] 是两个集合，这和之前分析的子集以及组合所不同的地方**。

可以看出元素1在[1,2]中已经使用过了，但是在[2,1]中还要在使用一次1，所以处理排列问题就不用使用startIndex了。

但排列问题需要一个used数组，标记已经选择的元素。

代码如下：

```cpp
vector<vector<int>> result;
vector<int> path;
void backtracking (vector<int>& nums, vector<bool>& used)
```

2. 递归终止条件

可以看出叶子节点，就是收割结果的地方。

当收集元素的数组path的大小达到和nums数组一样大的时候，说明找到了一个全排列，也表示到达了叶子节点。代码如下：

```cpp
// 此时说明找到了一组
if (path.size() == nums.size()) {
    result.push_back(path);
    return;
}
```

3. 单层搜索的逻辑

因为排列问题，每次都要从头开始搜索，例如元素1在[1,2]中已经使用过了，但是在[2,1]中还要再使用一次1。

**而used数组，其实就是记录此时path里都有哪些元素使用了，一个排列里一个元素只能使用一次**。

代码如下：

```cpp
for (int i = 0; i < nums.size(); i++) {
    if (used[i] == true) continue; // path里已经收录的元素，直接跳过
    used[i] = true;
    path.push_back(nums[i]);
    backtracking(nums, used);
    path.pop_back();
    used[i] = false;
}
```

完整代码如下：

```cpp
class Solution {
public:
    vector<vector<int>> result;
    vector<int> path;
    void dfs(vector<int>& nums, vector<int>& used){
        if(path.size() == nums.size()){
            result.push_back(path);
            return;
        }
        for(int i = 0; i < nums.size(); i++){
            if(used[i] == true) continue;
            used[i] = true;
            path.push_back(nums[i]);
            dfs(nums, used);
            path.pop_back();
            used[i] = false;
        }
    }
    vector<vector<int>> permute(vector<int>& nums) {
        result.clear();
        path.clear();
        vector<int> used(nums.size(), false);
        dfs(nums, used);
        return result;
    }
};
```

使用next_permutation函数

```cpp
class Solution {
public:
    vector<vector<int>> permute(vector<int>& nums) {
        vector<vector<int>> res;
        sort(nums.begin(),nums.end());
        do{
            res.push_back(nums);
        }while(next_permutation(nums.begin(),nums.end()));
        return res;
    }
};
```

### 全排列(有重复元素)

#### 相关链接

+ [47. 全排列 II](https://leetcode.cn/problems/permutations-ii/)

#### 相关思路

给定一个可包含重复数字的序列 `nums` ，**按任意顺序** 返回所有不重复的全排列。

**示例 1：**

```
输入：nums = [1,1,2]
输出：
[[1,1,2],
 [1,2,1],
 [2,1,1]]
```

#### 解题思路

1. 递归函数参数

**需要强调的是去重一定要对元素进行排序，这样我们才方便通过相邻的节点来判断是否重复使用了**

<img src="/images/%E7%AE%97%E6%B3%95-%E6%9A%B4%E6%90%9C%E5%9B%9E%E6%BA%AF/image-20221228110645271.png"  style="zoom: 80%;box-shadow: rgba(0, 0, 0, 0) 0px 0px 0px 0px;" />



2. 递归终止条件

可以看出叶子节点，就是收割结果的地方。

当收集元素的数组path的大小达到和nums数组一样大的时候，说明找到了一个全排列，也表示到达了叶子节点。代码如下：

3. 单层搜索的逻辑

思路是 **组合总和(有重复元素-无重复组合)** 与 **全排列(无重复元素)** 的结合

```cpp
class Solution {
private:
    vector<vector<int>> result;
    vector<int> path;
    void backtracking (vector<int>& nums, vector<bool>& used) {
        if (path.size() == nums.size()) {
            result.push_back(path);
            return;
        }
        for (int i = 0; i < nums.size(); i++) {
            // used[i - 1] == true，说明同一树枝nums[i - 1]使用过
            // used[i - 1] == false，说明同一树层nums[i - 1]使用过 
            // 如果同一树层nums[i - 1]使用过则直接跳过
            if (i > 0 && nums[i] == nums[i - 1] && used[i - 1] == false) continue;
            if (used[i] == false) {
                used[i] = true;
                path.push_back(nums[i]);
                backtracking(nums, used);
                path.pop_back();
                used[i] = false;
            }
        }
    }
public:
    vector<vector<int>> permuteUnique(vector<int>& nums) {
        result.clear();
        path.clear();
        sort(nums.begin(), nums.end()); // 排序
        vector<bool> used(nums.size(), false);
        backtracking(nums, used);
        return result;
    }
};
```

使用next_permutation函数，代码与 **全排列(无重复元素)** 完全一致

```cpp
class Solution {
public:
    vector<vector<int>> permuteUnique(vector<int>& nums) {
        vector<vector<int>> res;
        sort(nums.begin(),nums.end());
        do{
            res.push_back(nums);
        }while(next_permutation(nums.begin(),nums.end()));
        return res;        
    }
};
```



## 切割问题

### 分割回文串

#### 相关链接

+ [131. 分割回文串 ](https://leetcode.cn/problems/palindrome-partitioning/description/)

#### 相关题目

给你一个字符串 `s`，请你将 `s` 分割成一些子串，使每个子串都是 **回文串** 。返回 `s` 所有可能的分割方案。

**回文串** 是正着读和反着读都一样的字符串。

**示例 1：**

```
输入：s = "aab"
输出：[["a","a","b"],["aa","b"]]
```

#### 解题思路

1. 递归函数参数

全局变量数组path存放切割后回文的子串，二维数组result存放结果集。 （这两个参数可以放到函数参数里）

本题递归函数参数还需要startIndex，因为切割过的地方，不能重复切割，和组合问题也是保持一致的。

代码如下：

```cpp
vector<vector<string>> result;
vector<string> path; // 放已经回文的子串
void backtracking (const string& s, int startIndex) {
```

2. 递归函数终止条件

从树形结构的图中可以看出：切割线切到了字符串最后面，说明找到了一种切割方法，此时就是本层递归的终止条件。

在处理组合问题的时候，递归参数需要传入startIndex，表示下一轮递归遍历的起始位置，这个startIndex就是切割线。

所以终止条件代码如下：

```cpp
void backtracking (const string& s, int startIndex) {
    // 如果起始位置已经大于s的大小，说明已经找到了一组分割方案了
    if (startIndex >= s.size()) {
        result.push_back(path);
        return;
    }
}
```

3. 单层搜索的逻辑

**来看看在递归循环中如何截取子串呢？**

在`for (int i = startIndex; i < s.size(); i++)`循环中，我们 定义了起始位置startIndex，那么 [startIndex, i] 就是要截取的子串。首先判断这个子串是不是回文，如果是回文，就加入在`vector<string> path`中，path用来记录切割过的回文子串。代码如下：

```cpp
for (int i = startIndex; i < s.size(); i++) {
    if (isPalindrome(s, startIndex, i)) { // 是回文子串
        // 获取[startIndex,i]在s中的子串
        string str = s.substr(startIndex, i - startIndex + 1);
        path.push_back(str);
    } else {                // 如果不是则直接跳过
        continue;
    }
    backtracking(s, i + 1); // 寻找i+1为起始位置的子串
    path.pop_back();        // 回溯过程，弹出本次已经填在的子串
}
```

**注意切割过的位置，不能重复切割，所以，backtracking(s, i + 1); 传入下一层的起始位置为i + 1**。

完整代码如下：

```cpp
class Solution {
private:
    vector<vector<string>> res;
    vector<string> path;
    bool isPanlidrome(string s, int start, int end){
        for(int i = start, j = end; i < j; i++,j--){
            if(s[i] != s[j]) return false;
        }
        return true;
    }
    void dfs(string s, int startIndex){
        if(startIndex >= s.size()){
            res.push_back(path);
            return;
        }
        for(int i = startIndex; i < s.size(); i++){
            if(isPanlidrome(s, startIndex, i)){
                string str = s.substr(startIndex, i - startIndex + 1);
                path.push_back(str);
            }else{
                continue;
            }
            dfs(s, i + 1);
            path.pop_back();
        }
    }

public:
    vector<vector<string>> partition(string s) {
        dfs(s, 0);
        return res;
    }
};
```

### 复原 IP 地址

#### 相关链接

+ [93. 复原 IP 地址 ](https://leetcode.cn/problems/restore-ip-addresses/)

#### 相关题目

**有效 IP 地址** 正好由四个整数（每个整数位于 `0` 到 `255` 之间组成，且不能含有前导 `0`），整数之间用 `'.'` 分隔。

+ 例如：`"0.1.2.201"` 和` "192.168.1.1"` 是 **有效** IP 地址，但是 `"0.011.255.245"`、`"192.168.1.312"` 和 `"192.168@1.1"` 是 **无效** IP 地址。

给定一个只包含数字的字符串 `s` ，用以表示一个 IP 地址，返回所有可能的**有效 IP 地址**，这些地址可以通过在 `s` 中插入 `'.'` 来形成。你 **不能** 重新排序或删除 `s` 中的任何数字。你可以按 **任何** 顺序返回答案。

**示例 1：**

```
输入：s = "25525511135"
输出：["255.255.11.135","255.255.111.35"]
```

#### 解题思路

1. 确定递归的函数及参数

startIndex一定是需要的，因为不能重复分割，记录下一层递归分割的起始位置。

本题我们还需要一个变量pointNum，记录添加逗点的数量。所以代码如下：

```cpp
vector<string> result;// 记录结果
// startIndex: 搜索的起始位置，pointNum:添加逗点的数量
void backtracking(string& s, int startIndex, int pointNum) {
```

2. 确定递归的终止条件

本题明确要求只会分成4段，所以不能用切割线切到最后作为终止条件，而是分割的段数作为终止条件。

pointNum表示逗点数量，pointNum为3说明字符串分成了4段了。然后验证一下第四段是否合法，如果合法就加入到结果集里，

代码如下：

```cpp
if (pointNum == 3) { // 逗点数量为3时，分隔结束
    // 判断第四段子字符串是否合法，如果合法就放进result中
    if (isValid(s, startIndex, s.size() - 1)) {
        result.push_back(s);
    }
    return;
}
```

3. 确定单层搜索逻辑

在`for (int i = startIndex; i < s.size(); i++)`循环中 [startIndex, i] 这个区间就是截取的子串，需要判断这个子串是否合法。

+ 如果合法就在字符串后面加上符号`.`表示已经分割。
+ 如果不合法就结束本层循环。

然后就是递归和回溯的过程：

递归调用时，下一层递归的startIndex要从i+2开始（因为需要在字符串中加入了分隔符`.`），同时记录分割符的数量pointNum 要 +1。

回溯的时候，就将刚刚加入的分隔符`.` 删掉就可以了，pointNum也要-1。代码如下：

```cpp
for (int i = startIndex; i < s.size(); i++) {
    if (isValid(s, startIndex, i)) { // 判断 [startIndex,i] 这个区间的子串是否合法
        s.insert(s.begin() + i + 1 , '.');  // 在i的后面插入一个逗点
        pointNum++;
        backtracking(s, i + 2, pointNum);   // 插入逗点之后下一个子串的起始位置为i+2
        pointNum--;                         // 回溯
        s.erase(s.begin() + i + 1);         // 回溯删掉逗点
    } else break; // 不合法，直接结束本层循环
}
```

完整代码如下：

```cpp
class Solution {
private:
    vector<string> res;
    bool check(string s, int start, int end){
        if(start > end) return false;
        if(s[start] == '0' && start != end) return false;//start != end 目的是为了判定是否是一个数0
        int num = 0;
        for(int i = start; i <= end; i++){
            if(s[i] > '9' || s[i] < '0') return false;
            num = num * 10 + (s[i] - '0');
            if(num > 255) return false;
        }
        return true;
    }
    void dfs(string s, int startIndex, int pointNum){
        if(pointNum == 3){
            if(check(s, startIndex, s.size() - 1)) res.push_back(s);
            return;
        }
        for(int i = startIndex; i < s.size(); i++){
            if(check(s, startIndex, i)){
                s.insert(s.begin() + i + 1, '.');
                dfs(s, i + 2, pointNum + 1);
                s.erase(s.begin() + i + 1);
            }else break;
        }
    }
public:
    vector<string> restoreIpAddresses(string s) {
        if(s.size() < 4 || s.size() > 12) return res;
        dfs(s, 0, 0);
        return res;
    }
};
```

## 子集问题

### 子集-无重复

#### 相关链接

+ [78. 子集](https://leetcode.cn/problems/subsets/)

#### 相关题目

给你一个整数数组 `nums` ，数组中的元素 **互不相同** 。返回该数组所有可能的子集（幂集）。

解集 **不能** 包含重复的子集。你可以按 **任意顺序** 返回解集。

**示例 1：**

```
输入：nums = [1,2,3]
输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
```

#### 解题思路

如果把 子集问题、组合问题、分割问题都抽象为一棵树的话，**那么组合问题和分割问题都是收集树的叶子节点，而子集问题是找树的所有节点！**，其实子集也是一种组合问题，因为它的集合是无序的，**那么既然是无序，取过的元素不会重复取，写回溯算法的时候，for就要从startIndex开始，而不是从0开始！**

以示例中nums = [1,2,3]为例把求子集抽象为树型结构，如下：

<img src="https://img-blog.csdnimg.cn/202011232041348.png"  style="zoom:50%;box-shadow: rgba(0, 0, 0, 0) 0px 0px 0px 0px;"/>

从图中红线部分，可以看出**遍历这个树的时候，把所有节点都记录下来，就是要求的子集集合**。

1. 递归函数及参数

全局变量数组path为子集收集元素，二维数组result存放子集组合。（也可以放到递归函数参数里）

递归函数参数在上面讲到了，需要`startIndex`。

代码如下：

```cpp
vector<vector<int>> result;
vector<int> path;
void backtracking(vector<int>& nums, int startIndex) {
```

2. 确定递归的终止条件

从图中可以看出：

<img src="/images/%E7%AE%97%E6%B3%95-%E6%9A%B4%E6%90%9C%E5%9B%9E%E6%BA%AF/image-20230414185237969.png" style="zoom: 80%; box-shadow: rgba(0, 0, 0, 0) 0px 0px 0px 0px;" />

剩余集合为空的时候，就是叶子节点。那么什么时候剩余集合为空呢？

就是startIndex已经大于数组的长度了，就终止了，因为没有元素可取了，代码如下:

```cpp
if (startIndex >= nums.size()) {
    return;
}
```

**其实可以不需要加终止条件，因为startIndex >= nums.size()，本层for循环本来也结束了**。

3. 单层搜索逻辑

**求取子集问题，不需要任何剪枝！因为子集就是要遍历整棵树**。

那么单层递归逻辑代码如下：

```cpp
for (int i = startIndex; i < nums.size(); i++) {
    path.push_back(nums[i]);    // 子集收集元素
    backtracking(nums, i + 1);  // 注意从i+1开始，元素不重复取
    path.pop_back();            // 回溯
}
```

完整代码如下：

```cpp
class Solution {
private:
    vector<vector<int>> result;
    vector<int> path;
    void dfs(vector<int>& nums, int startIndex){
        result.push_back(path);     // 收集子集，要放在终止添加的上面，否则会漏掉自己
        if(startIndex >= nums.size()) return;
        for(int i = startIndex; i < nums.size(); i++){
            path.push_back(nums[i]);
            dfs(nums, i + 1);
            path.pop_back();
        }
    }
public:
    vector<vector<int>> subsets(vector<int>& nums) {
        result.clear();
        path.clear();
        dfs(nums, 0);
        return result;    
    }
};
```

### 子集-有重复

#### 相关链接

+ [90. 子集 II ](https://leetcode.cn/problems/subsets-ii/description/)

#### 相关题目

给你一个整数数组 `nums` ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。

解集 **不能** 包含重复的子集。返回的解集中，子集可以按 **任意顺序** 排列。

**示例 1：**

```
输入：nums = [1,2,2]
输出：[[],[1],[1,2],[1,2,2],[2],[2,2]]
```

#### 解题思路

**树层去重**

```cpp
class Solution {
private:
    vector<vector<int>> result;
    vector<int> path;
    void dfs(vector<int>& nums, int startIndex, vector<bool> & used){
        result.push_back(path);
        for(int i = startIndex; i < nums.size();i++){
            if(i > 0 && nums[i] == nums[i - 1] && used[i - 1] == false) continue;
            path.push_back(nums[i]);
            used[i] = true;
            dfs(nums, i + 1, used);
            used[i] = false;
            path.pop_back();
        }
    }
public:
    vector<vector<int>> subsetsWithDup(vector<int>& nums) {
        result.clear();
        path.clear();
        vector<bool> used(nums.size(), false);
        sort(nums.begin(), nums.end());
        dfs(nums, 0 , used);
        return result;
    }
};
```

组合问题使用startIndex去重也可以

```cpp
class Solution {
private:
    vector<vector<int>> result;
    vector<int> path;
    void dfs(vector<int>& nums, int startIndex){
        result.push_back(path);
        for(int i = startIndex; i < nums.size();i++){
            if(i > startIndex && nums[i] == nums[i - 1]) continue;
            path.push_back(nums[i]);
            dfs(nums, i + 1);
            path.pop_back();
        }
    }
public:
    vector<vector<int>> subsetsWithDup(vector<int>& nums) {
        result.clear();
        path.clear();
        sort(nums.begin(), nums.end());
        dfs(nums, 0);
        return result;
    }
};
```

### 递增子序列

#### 相关链接

+ [491. 递增子序列 ](https://leetcode.cn/problems/non-decreasing-subsequences/)

#### 相关题目

给你一个整数数组 `nums` ，找出并返回所有该数组中不同的递增子序列，递增子序列中 **至少有两个元素** 。你可以按 **任意顺序** 返回答案。

数组中可能含有重复元素，如出现两个整数相等，也可以视作递增序列的一种特殊情况。

**示例 1：**

```
输入：nums = [4,6,7,7]
输出：[[4,6],[4,6,7],[4,6,7,7],[4,7],[4,7,7],[6,7],[6,7,7],[7,7]]
```

说明:

+ 给定数组的长度不会超过15。
+ 数组中的整数范围是 [-100,100]。
+ 给定数组中可能包含重复数字，相等的数字应该被视为递增的一种情况。

#### 解答思路

这个递增子序列比较像是取有序的子集。而且本题也要求不能有相同的递增子序列。

这又是子集，又是去重，是不是不由自主的想起了刚刚讲过的子集-有重复。

就是因为太像了，更要注意差别所在，要不就掉坑里了！

在子集-有重复中我们是通过排序，再加一个标记数组来达到去重的目的。

而本题求自增子序列，**是不能对原数组进行排序的**，排完序的数组都是自增子序列了。

**所以不能使用之前的去重逻辑！**

1. 递归函数参数

本题求子序列，很明显一个元素不能重复使用，所以需要startIndex，调整下一层递归的起始位置。代码如下：

```cpp
vector<vector<int>> result;
vector<int> path;
void dfs(vector<int>& nums, int startIndex)
```

2. 终止条件

本题其实类似求子集问题，也是要遍历树形结构找每一个节点，可以不加终止条件，startIndex每次都会加1，并不会无限递归。

但本题收集结果有所不同，题目要求递增子序列大小至少为2，所以代码如下：

```cpp
if (path.size() > 1) {
    result.push_back(path);
    // 注意这里不要加return，因为要取树上的所有节点
}
```

3. 单层搜索逻辑 

   <img src="/images/%E7%AE%97%E6%B3%95-%E6%9A%B4%E6%90%9C%E5%9B%9E%E6%BA%AF/image-20230414185337352.png" alt="" style="zoom: 80%; box-shadow: rgba(0, 0, 0, 0) 0px 0px 0px 0px;" />

   在图中可以看出，**同一父节点下的同层上使用过的元素就不能再使用了**
   
   那么单层搜索代码如下：

```cpp
unordered_set<int> uset; // 使用set来对本层元素进行去重
for (int i = startIndex; i < nums.size(); i++) {
    if ((!path.empty() && nums[i] < path.back())
            || uset.find(nums[i]) != uset.end()) {
            continue;
    }
    uset.insert(nums[i]); // 记录这个元素在本层用过了，本层后面不能再用了
    path.push_back(nums[i]);
    backtracking(nums, i + 1);
    path.pop_back();
}
```

**对于已经习惯写回溯的同学，看到递归函数上面的`uset.insert(nums[i]);`，下面却没有对应的pop之类的操作，应该很不习惯吧，**这也是需要注意的点，`unordered_set<int> uset;` 是记录本层元素是否重复使用，新的一层uset都会重新定义（清空），所以要知道uset只负责本层！

最后整体C++代码如下：

```cpp
class Solution {
private:
    vector<vector<int>> res;
    vector<int> path;
    void dfs(vector<int> & nums, int startIndex){
        if(path.size() > 1) res.push_back(path);
        unordered_set<int> uset;
        for(int i = startIndex; i < nums.size(); i++){
            if((path.size() > 0 && nums[i] < path.back()) || uset.find(nums[i]) != uset.end()) continue;
            uset.insert(nums[i]);
            path.push_back(nums[i]);
            dfs(nums, i + 1);
            path.pop_back();
        }
    }
public:
    vector<vector<int>> findSubsequences(vector<int>& nums) {
        dfs(nums, 0);
        return res;
    }
};
```

## 棋盘问题

### N 皇后

#### 相关链接

+ [51. N 皇后 ](https://leetcode.cn/problems/n-queens/description/)

#### 相关题目

按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。

**n 皇后问题** 研究的是如何将 `n` 个皇后放置在 `n×n` 的棋盘上，并且使皇后彼此之间不能相互攻击。

给你一个整数 `n` ，返回所有不同的 **n 皇后问题** 的解决方案。

每一种解法包含一个不同的 **n 皇后问题** 的棋子放置方案，该方案中 `'Q'` 和 `'.'` 分别代表了皇后和空位。

**示例 1：**

<img src="https://assets.leetcode.com/uploads/2020/11/13/queens.jpg" alt="示例1" style="zoom:50%;box-shadow: rgba(0, 0, 0, 0) 0px 0px 0px 0px;" />

```
输入：n = 4
输出：[[".Q..","...Q","Q...","..Q."],["..Q.","Q...","...Q",".Q.."]]
解释：如上图所示，4 皇后问题存在两个不同的解法。
```

#### 解题思路

首先来看一下皇后们的约束条件：

1. 不能同行
2. 不能同列
3. 不能同斜线

确定完约束条件，来看看究竟要怎么去搜索皇后们的位置，其实搜索皇后的位置，可以抽象为一棵树。

下面我用一个 3 * 3 的棋盘，将搜索过程抽象为一棵树，如图：

<img src="/images/%E7%AE%97%E6%B3%95-%E6%9A%B4%E6%90%9C%E5%9B%9E%E6%BA%AF/image-20230414185508792.png" alt="N皇后" style="zoom:50%;box-shadow: rgba(0, 0, 0, 0) 0px 0px 0px 0px;" />



从图中，可以看出，二维矩阵中矩阵的高就是这棵树的高度，矩阵的宽就是树形结构中每一个节点的宽度。

那么我们用皇后们的约束条件，来回溯搜索这棵树，**只要搜索到了树的叶子节点，说明就找到了皇后们的合理位置了**。

1. 递归函数参数

我依然是定义全局变量二维数组result来记录最终结果。

参数n是棋盘的大小，然后用row来记录当前遍历到棋盘的第几层了。

代码如下：

```cpp
vector<vector<string>> result;
void backtracking(int n, int row, vector<string>& chessboard) {
```

2. 递归终止条件

当递归到棋盘最底层（也就是叶子节点）的时候，就可以收集结果并返回了。

代码如下：

```cpp
if (row == n) {
    result.push_back(chessboard);
    return;
}
```

3. 单层搜索的逻辑

递归深度就是row控制棋盘的行，每一层里for循环的col控制棋盘的列，一行一列，确定了放置皇后的位置。

每次都是要从新的一行的起始位置开始搜，所以都是从0开始。

代码如下：

```cpp
for (int col = 0; col < n; col++) {
    if (isValid(row, col, chessboard, n)) { // 验证合法就可以放
        chessboard[row][col] = 'Q'; // 放置皇后
        backtracking(n, row + 1, chessboard);
        chessboard[row][col] = '.'; // 回溯，撤销皇后
    }
}
```

**验证棋盘是否合法**

按照如下标准去重：

1. 不能同行
2. 不能同列
3. 不能同斜线 （45度和135度角）

代码如下：

```cpp
bool isValid(int row, int col, vector<string>& chessboard, int n) {
    // 检查列
    for (int i = 0; i < row; i++) { // 这是一个剪枝
        if (chessboard[i][col] == 'Q') return false;
    }
    // 检查 45度角是否有皇后
    for (int i = row - 1, j = col - 1; i >=0 && j >= 0; i--, j--) {
        if (chessboard[i][j] == 'Q') return false;
    }
    // 检查 135度角是否有皇后
    for(int i = row - 1, j = col + 1; i >= 0 && j < n; i--, j++) {
        if (chessboard[i][j] == 'Q') return false;
    }
    return true;
}
```

完整代码如下：

```cpp
class Solution {
private:
    vector<vector<string>> result;
    void dfs(int n, int row, vector<string>& chessboard){
        if(row == n){
            result.push_back(chessboard);
            return;
        }
        for(int col = 0; col < n; col++){
            if(check(row, col,chessboard, n)){
                chessboard[row][col] = 'Q';
                dfs(n, row + 1, chessboard);
                chessboard[row][col] = '.';
            }
        }
    }
    bool check(int row, int col, vector<string>& chessboard, int n){
        // 检查列
        for (int i = 0; i < row; i++) { // 这是一个剪枝
            if (chessboard[i][col] == 'Q') return false;
        }
        // 检查 45度角是否有皇后
        for (int i = row - 1, j = col - 1; i >=0 && j >= 0; i--, j--) {
            if (chessboard[i][j] == 'Q') return false;
        }
        // 检查 135度角是否有皇后
        for(int i = row - 1, j = col + 1; i >= 0 && j < n; i--, j++) {
            if (chessboard[i][j] == 'Q') return false;
        }
        return true;
    }
public:
    vector<vector<string>> solveNQueens(int n) {
        result.clear();
        vector<string> chessboard(n, string(n, '.'));
        dfs(n, 0, chessboard);
        return result;
    }
};
```

另一种写法：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N = 20;
char g[N][N];
bool col[N], dj[N], udj[N];
int n;
void dfs(int idx){
    if(idx == n){
        for(int i = 0; i < n; i++) puts(g[i]);
        puts("");
        return;
    }
    for(int i = 0;i < n;i++){
        if(!col[i] && !dj[idx + i] && !udj[n - idx + i]){
            g[idx][i] = 'Q';
            col[i] = dj[idx+i] = udj[n-idx+i] = true;
            dfs(r+1);
            col[i] = dj[idx+i] = udj[n-idx+i] =false;
            g[idx][i] = '.';
        }
    }
}
int main(){
    cin>>n;
    for(int i = 0; i < n; i++)
        for(int j = 0; j < n; j++)
            g[i][j] = '.';
    dfs(0);
    return 0;
}

```

### 解数独

#### 相关链接

+ [37. 解数独](https://leetcode.cn/problems/sudoku-solver/)

#### 相关题目

编写一个程序，通过填充空格来解决数独问题。

数独的解法需 **遵循如下规则**：

1. 数字 `1-9` 在每一行只能出现一次。
2. 数字 `1-9` 在每一列只能出现一次。
3. 数字 `1-9` 在每一个以粗实线分隔的 `3x3` 宫内只能出现一次。（请参考示例图）

数独部分空格内已填入了数字，空白格用 `'.'` 表示。

**示例 1：**

<img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/04/12/250px-sudoku-by-l2g-20050714svg.png" alt="示例1" style="zoom:67%;" />

```
输入：board = [["5","3",".",".","7",".",".",".","."],["6",".",".","1","9","5",".",".","."],[".","9","8",".",".",".",".","6","."],["8",".",".",".","6",".",".",".","3"],["4",".",".","8",".","3",".",".","1"],["7",".",".",".","2",".",".",".","6"],[".","6",".",".",".",".","2","8","."],[".",".",".","4","1","9",".",".","5"],[".",".",".",".","8",".",".","7","9"]]
输出：[["5","3","4","6","7","8","9","1","2"],["6","7","2","1","9","5","3","4","8"],["1","9","8","3","4","2","5","6","7"],["8","5","9","7","6","1","4","2","3"],["4","2","6","8","5","3","7","9","1"],["7","1","3","9","2","4","8","5","6"],["9","6","1","5","3","7","2","8","4"],["2","8","7","4","1","9","6","3","5"],["3","4","5","2","8","6","1","7","9"]]
```

#### 解题思路

1. 递归函数以及参数

**递归函数的返回值需要是bool类型，为什么呢？**

因为解数独找到一个符合的条件（就在树的叶子节点上）立刻就返回，相当于找从根节点到叶子节点一条唯一路径，所以需要使用bool返回值。代码如下：

```cpp
bool backtracking(vector<vector<char>>& board)
```

2. 递归终止条件

本题递归不用终止条件，解数独是要遍历整个树形结构寻找可能的叶子节点就立刻返回。

**不用终止条件会不会死循环？**递归的下一层的棋盘一定比上一层的棋盘多一个数，等数填满了棋盘自然就终止（填满当然好了，说明找到结果了），所以不需要终止条件！

3. 递归单层搜索逻辑

在树形图中可以看出我们需要的是一个二维的递归（也就是两个for循环嵌套着递归）

**一个for循环遍历棋盘的行，一个for循环遍历棋盘的列，一行一列确定下来之后，递归遍历这个位置放9个数字的可能性！**

代码如下：

```cpp
bool backtracking(vector<vector<char>>& board) {
    for (int i = 0; i < board.size(); i++) {        // 遍历行
        for (int j = 0; j < board[0].size(); j++) { // 遍历列
            if (board[i][j] != '.') continue;
            for (char k = '1'; k <= '9'; k++) {     // (i, j) 这个位置放k是否合适
                if (isValid(i, j, k, board)) {
                    board[i][j] = k;                // 放置k
                    if (backtracking(board)) return true; // 如果找到合适一组立刻返回
                    board[i][j] = '.';              // 回溯，撤销k
                }
            }
            return false;                           // 9个数都试完了，都不行，那么就返回false
        }
    }
    return true; // 遍历完没有返回false，说明找到了合适棋盘位置了
}
```

**注意这里return false的地方，这里放return false 是有讲究的**。

因为如果一行一列确定下来了，这里尝试了9个数都不行，说明这个棋盘找不到解决数独问题的解！

那么会直接返回， **这也就是为什么没有终止条件也不会永远填不满棋盘而无限递归下去！**

**判断棋盘是否合法**

判断棋盘是否合法有如下三个维度：

+ 同行是否重复
+ 同列是否重复
+ 9宫格里是否重复

代码如下：

```cpp
bool isValid(int row, int col, char val, vector<vector<char>>& board) {
    for (int i = 0; i < 9; i++) { // 判断行里是否重复
        if (board[row][i] == val) {
            return false;
        }
    }
    for (int j = 0; j < 9; j++) { // 判断列里是否重复
        if (board[j][col] == val) {
            return false;
        }
    }
    int startRow = (row / 3) * 3;
    int startCol = (col / 3) * 3;
    for (int i = startRow; i < startRow + 3; i++) { // 判断9方格里是否重复
        for (int j = startCol; j < startCol + 3; j++) {
            if (board[i][j] == val ) {
                return false;
            }
        }
    }
    return true;
}
```

完整代码如下：

```cpp
class Solution {
private:
    bool dfs(vector<vector<char>> & board){
        for(int i = 0; i < board.size(); i++){
            for(int j = 0; j < board[0].size(); j++){
                if (board[i][j] == '.') {
                    for (char k = '1'; k <= '9'; k++) {     
                        if (check(i, j, k, board)) {
                            board[i][j] = k;                
                            if (dfs(board)) return true; 
                            board[i][j] = '.';              
                        }
                    }
                    return false;       
                }
            }
        }
        return true;
    }
    bool check(int row, int col, char val, vector<vector<char>> & board){
        for(int i = 0; i < 9; i++){
            if(board[row][i] == val) return false;
        }
        for(int j = 0; j < 9; j++){
            if(board[j][col] == val) return false;
        }
        int startRow = (row / 3) * 3;
        int startCol = (col / 3) * 3;
        for(int i = startRow; i < startRow + 3; i++){
            for(int j = startCol; j < startCol + 3; j++){
                if(board[i][j] == val) return false;
            }
        }
        return true;
    }
public:
    void solveSudoku(vector<vector<char>>& board) {
        dfs(board);
    }
};
```

### 重新安排行程

#### 相关链接

+ [332. 重新安排行程 ](https://leetcode.cn/problems/reconstruct-itinerary/)

#### 相关题目

给你一份航线列表 `tickets` ，其中 `tickets[i] = [fromi, toi]` 表示飞机出发和降落的机场地点。请你对该行程进行重新规划排序。

所有这些机票都属于一个从 `JFK`（肯尼迪国际机场）出发的先生，所以该行程必须从 `JFK` 开始。如果存在多种有效的行程，请你按字典排序返回最小的行程组合。

+ 例如，行程 `["JFK", "LGA"]` 与 `["JFK", "LGB"]` 相比就更小，排序更靠前。

假定所有机票至少存在一种合理的行程。且所有的机票 必须都用一次 且 只能用一次。

**示例 1：**

<img src="https://assets.leetcode.com/uploads/2021/03/14/itinerary1-graph.jpg" alt="示例1" style="zoom:67%;box-shadow: rgba(0, 0, 0, 0) 0px 0px 0px 0px;" />

```
输入：tickets = [["MUC","LHR"],["JFK","MUC"],["SFO","SJC"],["LHR","SFO"]]
输出：["JFK","MUC","LHR","SFO","SJC"]
```

#### 解题思路

**这道题目有几个难点：**

1. 一个行程中，如果航班处理不好容易变成一个圈，成为死循环
2. 有多种解法，字母序靠前排在前面，让很多同学望而退步，如何该记录映射关系呢 ？
3. 使用回溯法（也可以说深搜） 的话，那么终止条件是什么呢？
4. 搜索的过程中，如何遍历一个机场所对应的所有机场。

递归的思路

1. 递归函数参数

使用`unordered_map<string, map<string, int>> targets;` 来记录航班的映射关系，我定义为全局变量。

当然把参数放进函数里传进去也是可以的，我是尽量控制函数里参数的长度。

参数里还需要ticketNum，表示有多少个航班（终止条件会用上）。代码如下：

```cpp
// unordered_map<出发机场, map<到达机场, 航班次数>> targets
unordered_map<string, map<string, int>> targets;
bool backtracking(int ticketNum, vector<string>& result) {
```

**注意函数返回值我用的是bool！**

我们之前讲解回溯算法的时候，一般函数返回值都是void，这次为什么是bool呢？

因为我们只需要找到一个行程，就是在树形结构中唯一的一条通向叶子节点的路线，如图：

<img src="/images/%E7%AE%97%E6%B3%95-%E6%9A%B4%E6%90%9C%E5%9B%9E%E6%BA%AF/image-20230414185555926.png" alt="" style="zoom: 67%;box-shadow: rgba(0, 0, 0, 0) 0px 0px 0px 0px;" />

所以找到了这个叶子节点了直接返回，当然本题的targets和result都需要初始化，代码如下：

```cpp
for (const vector<string>& vec : tickets) {
    targets[vec[0]][vec[1]]++; // 记录映射关系
}
result.push_back("JFK"); // 起始机场
```

2. 递归终止条件

拿题目中的示例为例，输入: [["MUC", "LHR"], ["JFK", "MUC"], ["SFO", "SJC"], ["LHR", "SFO"]] ，这是有4个航班，那么只要找出一种行程，行程里的机场个数是5就可以了。所以终止条件是：我们回溯遍历的过程中，遇到的机场个数，如果达到了（航班数量+1），那么我们就找到了一个行程，把所有航班串在一起了。

代码如下：

```cpp
if (result.size() == ticketNum + 1) {
    return true;
}
```

已经看习惯回溯法代码的同学，到叶子节点了习惯性的想要收集结果，但发现并不需要，也就是本题的result就是记录路径的（就一条），在如下单层搜索的逻辑中result就添加元素了。

3. 单层搜索的逻辑

回溯的过程中，如何遍历一个机场所对应的所有机场呢？

这里刚刚说过，在选择映射函数的时候，不能选择`unordered_map<string, multiset<string>> targets`， 因为一旦有元素增删multiset的迭代器就会失效，当然可能有牛逼的容器删除元素迭代器不会失效，这里就不在讨论了。

**可以说本题既要找到一个对数据进行排序的容器，而且还要容易增删元素，迭代器还不能失效**。所以我选择了`unordered_map<string, map<string, int>> targets` 来做机场之间的映射。遍历过程如下：

```cpp
for (pair<const string, int>& target : targets[result[result.size() - 1]]) {
    if (target.second > 0 ) { // 记录到达机场是否飞过了
        result.push_back(target.first);
        target.second--;
        if (backtracking(ticketNum, result)) return true;
        result.pop_back();
        target.second++;
    }
}
```

可以看出 通过`unordered_map<string, map<string, int>> targets`里的int字段来判断 这个集合里的机场是否使用过，这样避免了直接去删元素。

分析完毕，此时完整C++代码如下：

```cpp
class Solution {
private:
    // unordered_map<出发机场, map<到达机场, 航班次数>> targets
    unordered_map<string, map<string, int>> targets;
    bool backtracking(int ticketNum, vector<string>& result) {
        if (result.size() == ticketNum + 1) {
            return true;
        }
        for (pair<const string, int>& target : targets[result[result.size() - 1]]) {
            if (target.second > 0 ) { // 记录到达机场是否飞过了
                result.push_back(target.first);
                target.second--;
                if (backtracking(ticketNum, result)) return true;
                result.pop_back();
                target.second++;
            }
        }
        return false;
    }
public:
    vector<string> findItinerary(vector<vector<string>>& tickets) {
        targets.clear();
        vector<string> result;
        for (const vector<string>& vec : tickets) {
            targets[vec[0]][vec[1]]++; // 记录映射关系
        }
        result.push_back("JFK"); // 起始机场
        backtracking(tickets.size(), result);
        return result;
    }
};
```

一波分析之后，可以看出我就是按照回溯算法的模板来的。代码中

```cpp
for (pair<const string, int>& target : targets[result[result.size() - 1]])
```

pair里要有const，因为map中的key是不可修改的，所以是`pair<const string, int>`。

如果不加const，也可以复制一份pair，例如这么写：

```cpp
for (pair<string, int>target : targets[result[result.size() - 1]])
```









[面试算法总结系列——和为K的算法_数组中找和为k的组合_好大的小飞虫的博客-CSDN博客](https://blog.csdn.net/qq_33277870/article/details/104966253?spm=1001.2101.3001.6650.2&utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-2-104966253-blog-113773507.pc_relevant_multi_platform_whitelistv3&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-2-104966253-blog-113773507.pc_relevant_multi_platform_whitelistv3&utm_relevant_index=3)