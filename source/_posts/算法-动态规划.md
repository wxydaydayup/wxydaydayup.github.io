---
rauthor: WangXinYi
img: /images/homePage/动态规划.webp
summary: 算法-动态规划
categories:
  - 算法
  - C++
  - 动态规划
tags:
  - 算法
  - C++
  - 动态规划
typora-root-url: ..
date: 2021-10-20 12:06:57
---

## 动态规划做题顺序

+ 状态表示---确定dp数组以及下标的含义
+ 状态集合---确定递推公式
+ dp数组如何初始化
+ 确定遍历顺序
+ 举例推导dp数组

## 背包问题

<img src="/images/%E7%AE%97%E6%B3%95-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/image-20230414183503407.png" style="zoom: 80%;box-shadow:rgba(0,0,0,0) 0 0px 0px 0px;" />

## 01背包

### 01背包理论

#### 相关链接

+ [0 1 背包问题 - AcWing](https://www.acwing.com/problem/content/2/)

#### 相关题目

有 N 件物品和一个容量是 V 的背包。每件物品只能使用一次。第 i 件物品的体积是 vi，价值是 wi。求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。输出最大价值。

**输入格式**

第一行两个整数，N，V 用空格隔开，分别表示物品数量和背包容积。

接下来有 N 行，每行两个整数 vi,wi 用空格隔开，分别表示第 i 件物品的体积和价值。

**输出格式**

输出一个整数，表示最大价值。

**数据范围**

+ 0 < N, V ≤ 1000
+ 0< vi, wi ≤ 1000

**输入样例**

```
4 5
1 2
2 4
3 4
4 5
```

**输出样例**

```
8
```

#### 解题思路

1. 确定dp数组以及下标的含义

   **`dp[i][j]` 表示从下标为[0-i]的物品里任意取，放进容量为 j 的背包，价值总和最大是多少**。

2. 确定递推公式

   + **不放物品 i**：由 `dp[i - 1][j]` 推出，即背包容量为 j，里面不放物品 i 的最大价值，此时`dp[i][j]`就是`dp[i - 1][j]`。(其实就是当物品 i 的重量大于背包 j 的重量时，物品 i 无法放进背包中，所以被背包内的价值依然和前面相同。)
   + **放物品 i**：由`dp[i - 1][j - weight[i]]`推出，`dp[i - 1][j - weight[i]]` 为背包容量为`j - weight[i]`的时候不放物品 i 的最大价值，那么`dp[i - 1][j - weight[i]] + value[i]` （物品i的价值），就是背包放物品 i 得到的最大价值

   所以递归公式： `dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i])`;

3. dp数组如何初始化

   首先从`dp[i][j]`的定义出发，如果背包容量 j 为0的话，即`dp[i][0]`，无论是选取哪些物品，背包价值总和一定为0。

   `dp[0][j]`，即：i 为 0，存放编号 0 的物品的时候，各个容量的背包所能存放的最大价值。那么很明显当 j < weight[0]的时候，`dp[0][j]` 应该是 0，因为背包容量比编号0的物品重量还小。当 j >= weight[0]时，`dp[0][j]` 应该是value[0]，因为背包容量放足够放编号0物品。

4. 确定遍历顺序

   先遍历物品还是先遍历背包重量呢？都可以，但是先遍历物品更好理解。

5. 举例推导dp数组

题目中体积和价值是反的，自己根据题意修改以下代码即可，完整代码如下：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1005;
int f[N][N];
int v[N];
int w[N];
int main(){
    int n,m; cin>>n>>m;
    for(int i = 1; i <= n; i++) cin>>w[i]>>v[i];
    for(int i = 1; i <= n; i++){
        for(int j = 0; j <= m; j++){
            if(j < w[i]) f[i][j] = f[i-1][j];
            else f[i][j] = max(f[i-1][j], f[i-1][j-w[i]] + v[i]);
        }
    }
    cout<<f[n][m]<<endl;
    return 0;
}
```

**滚动数组的优化**

1. 确定dp数组的定义

   在一维dp数组中，dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]。

2. 一维dp数组的递推公式

   dp[j]为 容量为j的背包所背的最大价值，那么如何推导dp[j]呢？

   dp[j]可以通过dp[j - weight[i]]推导出来，dp[j - weight[i]]表示容量为j - weight[i]的背包所背的最大价值。

   dp[j - weight[i]] + value[i] 表示 容量为 j - 物品 i 重量 的背包 加上 物品 i 的价值。（也就是容量为j的背包，放入物品i了之后的价值即：dp[j]）

   此时dp[j]有两个选择，一个是取自己dp[j] 相当于 二维dp数组中的`dp[i-1][j]`，即不放物品i，一个是取dp[j - weight[i]] + value[i]，即放物品 i，指定是取最大的，毕竟是求最大价值，

   所以递归公式为：

	```text
dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
	```

​	可以看出相对于二维dp数组的写法，就是把dp[i][j]中i的维度去掉了。

3. 一维dp数组如何初始化

   dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]，那么dp[0]就应该是0，因为背包容量为0所背的物品的最大价值就是0。

   那么dp数组除了下标0的位置，初始为0，其他下标应该初始化多少呢？

   看一下递归公式：dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);

   dp数组在推导的时候一定是取价值最大的数，如果题目给的价值都是正整数那么非0下标都初始化为0就可以了。

4. 一维dp数组遍历顺序

   **这里大家发现和二维dp的写法中，遍历背包的顺序是不一样的！**

   二维dp遍历的时候，背包容量是从小到大，而一维dp遍历的时候，背包是从大到小。

   为什么呢？

   **倒序遍历是为了保证物品 i 只被放入一次！**。但如果一旦正序遍历了，那么物品0就会被重复加入多次！

   举一个例子：物品0的重量weight[0] = 1，价值value[0] = 15

   如果正序遍历

   dp[1] = dp[1 - weight[0]] + value[0] = 15

   dp[2] = dp[2 - weight[0]] + value[0] = 30

   此时dp[2]就已经是30了，意味着物品0，被放入了两次，所以不能正序遍历。

   为什么倒序遍历，就可以保证物品只放入一次呢？

   倒序就是先算dp[2]

   dp[2] = dp[2 - weight[0]] + value[0] = 15 （dp数组已经都初始化为0）

   dp[1] = dp[1 - weight[0]] + value[0] = 15

   所以从后往前循环，每次取得状态不会和之前取得状态重合，这样每种物品就只取一次了。

   **那么问题又来了，为什么二维dp数组历的时候不用倒序呢？**

   因为对于二维dp，`dp[i][j]`都是通过上一层即`dp[i - 1][j]`计算而来，本层的`dp[i][j]`并不会被覆盖！

   （如何这里读不懂，大家就要动手试一试了，空想还是不靠谱的，实践出真知！）

   **再来看看两个嵌套for循环的顺序，代码中是先遍历物品嵌套遍历背包容量，那可不可以先遍历背包容量嵌套遍历物品呢？**

   不可以！

   因为一维dp的写法，背包容量一定是要倒序遍历（原因上面已经讲了），如果遍历背包容量放在上一层，那么每个dp[j]就只会放入一个物品，即：背包里只放入了一个物品。

   倒序遍历的原因是，本质上还是一个对二维数组的遍历，并且右下角的值依赖上一层左上角的值，因此需要保证左边的值仍然是上一层的，从右向左覆盖。

   （这里如果读不懂，就在回想一下dp[j]的定义，或者就把两个for循环顺序颠倒一下试试！）

   **所以一维dp数组的背包在遍历顺序上和二维其实是有很大差异的！**，这一点大家一定要注意。

5. 举例推导dp数组

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1010;
int f[N];
int n,m;
int v[N],w[N];
int main(){	
	cin>>n>>m;
	for(int i = 1; i <= n;i++) cin >> w[i] >> v[i];
	for(int i = 1; i <= n;i++)
		for(int j = m; j >= w[i]; j--)
			f[j] = max(f[j], f[j - w[i]] + v[i]);
	cout << f[m] << endl;
	return 0;	
}
```

### 分割等和子集

#### 相关链接

+ [416. 分割等和子集 ](https://leetcode.cn/problems/partition-equal-subset-sum/)
+ [剑指 Offer II 101. 分割等和子集 ](https://leetcode.cn/problems/NUPfPr/description/)
+ [473. 火柴拼正方形 ](https://leetcode.cn/problems/matchsticks-to-square/)
+ [698. 划分为k个相等的子集 ](https://leetcode.cn/problems/partition-to-k-equal-sum-subsets/)
+ [1723. 完成所有工作的最短时间 ](https://leetcode.cn/problems/find-minimum-time-to-finish-all-jobs/)
+ [2305. 公平分发饼干](https://leetcode.cn/problems/fair-distribution-of-cookies/)

#### 相关题目

给你一个 **只包含正整数** 的 **非空** 数组 `nums` 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。

**示例 1：**

```
输入：nums = [1,5,11,5]
输出：true
解释：数组可以分割成 [1, 5, 5] 和 [11] 。
```

#### 解题思路

1. 确定dp数组以及下标的含义

   **dp[j]表示 背包总容量（所能装的总重量）是j，放进物品后，背的最大重量为dp[j]。**

2. 确定递推公式

   01背包的递推公式为：dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);

   本题，相当于背包里放入数值，那么物品i的重量是nums[i]，其价值也是nums[i]。

   所以递推公式：dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]);

3. dp数组如何初始化

   ```cpp
   // 题目中说：每个数组中的元素不会超过 100，数组的大小不会超过 200
   // 总和不会大于20000，背包最大只需要其中一半，所以10001大小就可以了
   vector<int> dp(10001, 0);
   ```

4. 确定遍历顺序

   如果使用一维dp数组，物品遍历的for循环放在外层，遍历背包的for循环放在内层，且内层for循环倒序遍历！代码如下：

   ```cpp
   // 开始 01背包
   for(int i = 0; i < nums.size(); i++) {
       for(int j = target; j >= nums[i]; j--) { // 每一个元素一定是不可重复放入，所以从大到小遍历
           dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]);
       }
   }
   ```

5. 举例推导dp数组

完整代码如下：

```cpp
class Solution {
public:
    bool canPartition(vector<int>& nums) {
        int sum = 0, n = nums.size();
        for(int i = 0; i < n; i++) sum += nums[i];
        if(sum % 2) return false;
        int target = sum / 2;

        vector<int> dp(10001, 0);
        for(int i = 0; i < n; i++)
            for(int j = target; j >= nums[i]; j--)
                dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]);
        if(dp[target] == target) return true;
        return false;
    }
};
```

#### 相关链接的其他题目

**回溯法：**

[698. 划分为k个相等的子集 ](https://leetcode.cn/problems/partition-to-k-equal-sum-subsets/)

```cpp
class Solution {
public:
    bool dfs(vector<int>& nums,int target,int index,vector<int>& t,int k){
        if(index == nums.size()){
            for(int i = 0; i < k; i++)
                if(t[i] != target) return false;
            return true;
        }
        for(int i = 0; i < k; i++){
            if(t[i] + nums[index] > target) continue;
            t[i] += nums[index];
            if(dfs(nums, target, index + 1, t, k)) return true;
            t[i] -= nums[index];
            //如果第一个球，在第一个桶里面装不了，那么因为所有桶都是一样的，
            //其他桶肯定也装不了，提前结束
            if(t[i] == 0) break;
        }
        return false;
    }
    bool canPartitionKSubsets(vector<int>& nums, int k) {
        int sum = 0, n = nums.size();
        for(int i = 0; i < n; i++) sum += nums[i];
        if(sum % k) return false;
        int target = sum / k;
        vector<int> t(k);
        return dfs(nums, target, 0, t, k);
    }
};

```

[473. 火柴拼正方形](https://leetcode.cn/problems/matchsticks-to-square/description/)

```cpp
class Solution {
private:
    int k = 4;
public:
    bool dfs(vector<int>& matchsticks,int target,int index,vector<int>& t){
        if(index == matchsticks.size()){
            for(int i = 0; i < k; i++)
                if(t[i] != target) return false;
            return true;
        }
        for(int i = 0; i < k; i++){
            if(t[i] + matchsticks[index] > target) continue;
            t[i] += matchsticks[index];
            if(dfs(matchsticks, target, index + 1, t)) return true;
            t[i] -= matchsticks[index];
            //如果第一个球，在第一个桶里面装不了，那么因为所有桶都是一样的，
            //其他桶肯定也装不了，提前结束
            if(t[i] == 0) break;
        }
        return false;
    }   
    bool makesquare(vector<int>& matchsticks) {
        int sum = 0, n = matchsticks.size();
        for(int i = 0; i < n; i++) sum += matchsticks[i];
        if(sum % k) return false;
        int target = sum / k;
        vector<int> t(k);
        return dfs(matchsticks, target, 0, t);
    }
};
```

[2305. 公平分发饼干](https://leetcode.cn/problems/fair-distribution-of-cookies/solutions/)

```cpp
class Solution {
private:
    int ans = INT_MAX;
public:
    void dfs(vector<int>& cookies,int index, vector<int>& t, int k){
        if(index == cookies.size()){
            int cur = 0;
            for(int i = 0; i < k; i++) cur = max(cur, t[i]);
            ans = min(ans, cur);    
            return;
        }
        //剪枝1：如果剩余的饼干包不够空手的小朋友分了，直接返回。
        int zeroCount = 0;
        for (int i = 0; i < k; i++)
            if (t[i] == 0) zeroCount++;
        if (zeroCount > (cookies.size() - index)) return;
        //剪枝2：如果某位小朋友的饼干数量比当前的答案还多，显然继续回溯下去也无法成为最优答案，直接返回。
        for(int i = 0; i < k; i++) 
            if(t[i] > ans) return;
        for(int i = 0; i < k; i++){
            //剪枝3：第一个零食包不管给哪个小朋友，所开启的回溯树都一样，只要给第一个小朋友就行了，会少了很多。
            if(index == 0 && i > 0) return;
            t[i] += cookies[index];
            dfs(cookies, index + 1, t, k);
            t[i] -= cookies[index];
            //剪枝4
            if(t[i] == 0) break;
        }
    }

    int distributeCookies(vector<int>& cookies, int k) {
        sort(cookies.begin(), cookies.end());
        vector<int> t(k);
        dfs(cookies, 0, t, k);
        return ans;
    }
};
```

[1723. 完成所有工作的最短时间](https://leetcode.cn/problems/find-minimum-time-to-finish-all-jobs/)

```cpp
class Solution {
private:
    int ans = INT_MAX;
public:
    void dfs(vector<int>& jobs ,int index, vector<int>& t, int k){
        if(index == jobs.size()){
            int cur = 0;
            for(int i = 0; i < k; i++) cur = max(cur, t[i]);
            ans = min(ans, cur);    
            return;
        }
        //剪枝1
        int zeroCount = 0;
        for (int i = 0; i < k; i++)
            if (t[i] == 0) zeroCount++;
        if (zeroCount > (jobs.size() - index)) return;
        //剪枝2
        for(int i = 0; i < k; i++) 
            if(t[i] > ans) return;
        for(int i = 0; i < k; i++){
            //剪枝3
            if(index == 0 && i > 0) return;
            t[i] += jobs[index];
            dfs(jobs, index + 1, t, k);
            t[i] -= jobs[index];
            //剪枝4
            if(t[i] == 0) break;
        }
    }
    int minimumTimeRequired(vector<int>& jobs, int k) {
        sort(jobs.begin(), jobs.end());
        vector<int> t(k);
        dfs(jobs, 0, t, k);
        return ans;
    }
};
```

### 最后一块石头的重量 II 

#### 相关链接

+ [1046. 最后一块石头的重量](https://leetcode.cn/problems/last-stone-weight/description/)
+ [1049. 最后一块石头的重量 II ](https://leetcode.cn/problems/last-stone-weight-ii/description/)

#### 相关题目

有一堆石头，用整数数组 `stones` 表示。其中 `stones[i]` 表示第 `i` 块石头的重量。

每一回合，从中选出**任意两块石头**，然后将它们一起粉碎。假设石头的重量分别为 `x` 和 `y`，且 `x <= y`。那么粉碎的可能结果如下：

+ 如果 `x == y`，那么两块石头都会被完全粉碎；
+ 如果 `x != y`，那么重量为 `x` 的石头将会完全粉碎，而重量为 `y` 的石头新重量为 `y-x`。

最后，**最多只会剩下一块** 石头。返回此石头 **最小的可能重量** 。如果没有石头剩下，就返回 `0`。

**示例 1：**

```
输入：stones = [2,7,4,1,8,1]
输出：1
解释：
组合 2 和 4，得到 2，所以数组转化为 [2,7,1,8,1]，
组合 7 和 8，得到 1，所以数组转化为 [2,1,1,1]，
组合 2 和 1，得到 1，所以数组转化为 [1,1,1]，
组合 1 和 1，得到 0，所以数组转化为 [1]，这就是最优值。
```

#### 解题思路

**[1046. 最后一块石头的重量](https://leetcode.cn/problems/last-stone-weight/description/)**	直接用堆就可以了

```cpp
class Solution {
public:
    int lastStoneWeight(vector<int>& stones) {
        priority_queue<int> q;
        for(int s : stones) q.push(s);
        while(q.size() > 1){
            int a = q.top(); q.pop();
            int b = q.top(); q.pop();
            if(a > b) q.push(a - b);
        }
        return q.empty() ? 0 : q.top();
    }
};
```

[1049. 最后一块石头的重量 II ](https://leetcode.cn/problems/last-stone-weight-ii/description/)

本题其实就是尽量让石头分成重量相同的两堆，相撞之后剩下的石头最小，**这样就化解成01背包问题了**。

1. 确定dp数组以及下标的含义

   **dp[j]表示容量（这里说容量更形象，其实就是重量）为j的背包，最多可以背最大重量为dp[j]**。

2. 确定递推公式

   本题则是：**dp[j] = max(dp[j], dp[j - stones[i]] + stones[i]);**

3. dp数组如何初始化

   既然 dp[j]中的j表示容量，那么最大容量（重量）是多少呢，就是所有石头的重量和。

   因为提示中给出1 <= stones.length <= 30，1 <= stones[i] <= 1000，所以最大重量就是30 * 1000 。

   而我们要求的target其实只是最大重量的一半，所以dp数组开到15000大小就可以了。

   当然也可以把石头遍历一遍，计算出石头总重量 然后除2，得到dp数组的大小。我这里就直接用15000了。

   接下来就是如何初始化dp[j]呢，因为重量都不会是负数，所以dp[j]都初始化为0就可以了，这样在递归公式dp[j] = max(dp[j], dp[j - stones[i]] + stones[i]);中dp[j]才不会初始值所覆盖。

   代码为：

```text
vector<int> dp(15001, 0);
```

4. 确定遍历顺序

   如果使用一维dp数组，物品遍历的for循环放在外层，遍历背包的for循环放在内层，且内层for循环倒序遍历！

   代码如下：

```cpp
for (int i = 0; i < stones.size(); i++) { // 遍历物品
    for (int j = target; j >= stones[i]; j--) { // 遍历背包
        dp[j] = max(dp[j], dp[j - stones[i]] + stones[i]);
    }
}
```

5. 举例推导dp数组

```cpp
class Solution {
public:
    int lastStoneWeightII(vector<int>& stones) {
        vector<int> dp(15001, 0);
        int sum = 0;
        for (int i = 0; i < stones.size(); i++) sum += stones[i];
        int target = sum / 2;
        for (int i = 0; i < stones.size(); i++) { // 遍历物品
            for (int j = target; j >= stones[i]; j--) { // 遍历背包
                dp[j] = max(dp[j], dp[j - stones[i]] + stones[i]);
            }
        }
        return sum - dp[target] - dp[target];
    }
};

```

### 目标和

#### 相关链接

+ [494. 目标和 ](https://leetcode.cn/problems/target-sum/)

#### 相关题目

给你一个整数数组 `nums` 和一个整数 `target` 。

向数组中的每个整数前添加 `'+'` 或 `'-'` ，然后串联起所有整数，可以构造一个 **表达式** ：

例如，`nums = [2, 1]` ，可以在 `2` 之前添加 `'+'` ，在 `1` 之前添加 `'-'` ，然后串联起来得到表达式 `"+2-1"` 。

返回可以通过上述方法构造的、运算结果等于 `target` 的不同 **表达式** 的数目。

**示例 1：**

```
输入：nums = [1,1,1,1,1], target = 3
输出：5
解释：一共有 5 种方法让最终目标和为 3 。
-1 + 1 + 1 + 1 + 1 = 3
+1 - 1 + 1 + 1 + 1 = 3
+1 + 1 - 1 + 1 + 1 = 3
+1 + 1 + 1 - 1 + 1 = 3
+1 + 1 + 1 + 1 - 1 = 3
```

#### 解题思路

本题要如何使表达式结果为target，

既然为target，那么就一定有 left组合 - right组合 = target。

left + right = sum，而sum是固定的。right = sum - left

公式来了， left - (sum - left) = target 推导出 left = (target + sum)/2 。

target是固定的，sum是固定的，left就可以求出来。

此时问题就是在集合nums中找出和为left的组合。

如何转化为01背包问题呢。

假设加法的总和为x，那么减法对应的总和就是sum - x。

所以我们要求的是 x - (sum - x) = target

x = (target + sum) / 2

**此时问题就转化为，装满容量为x背包有几种方法**。

这里的x，就是bagSize，也就是我们后面要求的背包容量。

大家看到(target + sum) / 2 应该担心计算的过程中向下取整有没有影响。

这么担心就对了，例如sum 是 5，target 是 2 的话其实就是无解的，所以：

```cpp
if ((target + sum) % 2 == 1) return 0; // 此时没有方案
```

同时如果 target的绝对值已经大于sum，那么也是没有方案的。

```cpp
if (abs(target) > sum) return 0; // 此时没有方案
```

**动态规划的步骤**

1. 确定dp数组以及下标的含义

   **dp[j] 表示：填满 j（包括j）这么大容积的包，有dp[j]种方法**

   其实也可以使用二维dp数组来求解本题，`dp[i][j]`：使用 下标为 [0, i] 的nums[i]能够凑满j（包括j）这么大容量的包，有`dp[i][j]`种方法。

2. 确定递推公式

   有哪些来源可以推出dp[j]呢？只要搞到nums[i]，凑成dp[j]就有dp[j - nums[i]] 种方法。

   例如：dp[j]，j 为5，

+ 已经有一个1（nums[i]） 的话，有 dp[4]种方法 凑成 容量为5的背包。

+ 已经有一个2（nums[i]） 的话，有 dp[3]种方法 凑成 容量为5的背包。

+ 已经有一个3（nums[i]） 的话，有 dp[2]中方法 凑成 容量为5的背包

+ 已经有一个4（nums[i]） 的话，有 dp[1]中方法 凑成 容量为5的背包

+ 已经有一个5 （nums[i]）的话，有 dp[0]中方法 凑成 容量为5的背包

  那么凑整dp[5]有多少方法呢，也就是把 所有的 dp[j - nums[i]] 累加起来。

  所以求组合类问题的公式，都是类似这种：

```cpp
dp[j] += dp[j - nums[i]]
```

**这个公式在后面在讲解背包解决排列组合问题的时候还会用到！**

3. dp数组如何初始化

   在初始化的时候dp[0] 一定要初始化为1，因为dp[0]是在公式中一切递推结果的起源，如果dp[0]是0的话，递归结果将都是0。

4. 确定遍历顺序

   我们讲过对于01背包问题一维dp的遍历，nums放在外循环，target在内循环，且内循环倒序。

5. 举例推导dp数组

完整代码如下：

```cpp
class Solution {
public:
    int findTargetSumWays(vector<int>& nums, int target) {
        int sum = 0;
        for (int i = 0; i < nums.size(); i++) sum += nums[i];
        if (abs(target) > sum) return 0; 	   // 此时没有方案
        if ((target + sum) % 2 == 1) return 0; // 此时没有方案
        int bagSize = (target + sum) / 2;
        vector<int> dp(bagSize + 1, 0);
        dp[0] = 1;
        for (int i = 0; i < nums.size(); i++) {
            for (int j = bagSize; j >= nums[i]; j--) {
                dp[j] += dp[j - nums[i]];
            }
        }
        return dp[bagSize];
    }
};
```

### 一和零

#### 相关链接

+ [474. 一和零 ](https://leetcode.cn/problems/ones-and-zeroes/)

#### 相关题目

给你一个二进制字符串数组 `strs` 和两个整数 `m` 和 `n` 。

请你找出并返回 `strs` 的最大子集的长度，该子集中 **最多** 有 `m` 个 `0` 和 `n` 个 `1` 。

如果 `x` 的所有元素也是 `y` 的元素，集合 `x` 是集合 `y` 的 **子集** 。

**示例 1：**

```
输入：strs = ["10", "0001", "111001", "1", "0"], m = 5, n = 3
输出：4
解释：最多有 5 个 0 和 3 个 1 的最大子集是 {"10","0001","1","0"} ，因此答案是 4 。
其他满足题意但较小的子集包括 {"0001","1"} 和 {"10","1","0"} 。{"111001"} 不满足题意，
因为它含 4 个 1 ，大于 n 的值 3 。
```

#### 解题思路

1. 确定dp数组（dp table）以及下标的含义

   **`dp[i][j]`：最多有 i 个 0 和 j 个 1 的strs的最大子集的大小为`dp[i][j]`**。

2. 确定递推公式

   `dp[i][j]` 可以由前一个strs里的字符串推导出来，strs里的字符串有zeroNum个0，oneNum个1。

   `dp[i][j]` 就可以是 `dp[i - zeroNum][j - oneNum] + 1`。

   然后我们在遍历的过程中，取`dp[i][j]`的最大值。

   所以递推公式：`dp[i][j] = max(dp[i][j], dp[i - zeroNum][j - oneNum] + 1);`

   此时大家可以回想一下01背包的递推公式：`dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);`

   对比一下就会发现，字符串的zeroNum 和 oneNum相当于物品的重量（weight[i]），字符串本身的个数相当于物品的价值（value[i]）。

   **这就是一个典型的01背包！** 只不过物品的重量有了两个维度而已。

3. dp数组如何初始化

   0 1 背包的dp数组初始化为0就可以。因为物品价值不会是负数，初始为0，保证递推的时候`dp[i][j]`不会被初始值覆盖。

4. 确定遍历顺序

   外层for循环遍历物品，内层for循环遍历背包容量，都需要从后向前遍历！

   物品就是strs里的字符串，背包容量就是题目描述中的m和n。

5. 举例推导dp数组

```cpp
class Solution {
public:
    int findMaxForm(vector<string>& strs, int m, int n) {
        vector<vector<int>> dp(m + 1, vector<int> (n + 1, 0)); // 默认初始化0
        for (string str : strs) { // 遍历物品
            int oneNum = 0, zeroNum = 0;
            for (char c : str) {
                if (c == '0') zeroNum++;
                else oneNum++;
            }
            for (int i = m; i >= zeroNum; i--)  // 遍历背包容量且从后向前遍历！
                for (int j = n; j >= oneNum; j--) 
                    dp[i][j] = max(dp[i][j], dp[i - zeroNum][j - oneNum] + 1);
        }
        return dp[m][n];
    }
};
```

## 完全背包

### 完全背包理论

#### 相关链接

+ [完全背包问题 - AcWing](https://www.acwing.com/problem/content/3/)

#### 相关题目

有 N 种物品和一个容量是 V的背包，每种物品都有无限件可用。第 i 种物品的体积是 vi，价值是 wi。求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。输出最大价值。

**输入格式**

第一行两个整数，N，V 用空格隔开，分别表示物品种数和背包容积。

接下来有 N 行，每行两个整数 vi,wi 用空格隔开，分别表示第 i 种物品的体积和价值。

**输出格式**

输出一个整数，表示最大价值。

**数据范围**

0<N,V≤1000

0<vi,wi≤1000

**输入样例**

```
4 5
1 2
2 4
3 4
4 5
```

**输出样例**

```
10
```

#### 解题思路

+ 01背包中二维dp数组的两个for遍历的先后循序是可以颠倒了
+ 01背包中一维dp数组的两个for循环先后循序一定是先遍历物品，再遍历背包容量。
+ 在完全背包中，对于一维dp数组来说，其实两个for循环嵌套顺序是无所谓的！

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1010;
int f[N];
int n,m;
int v[N],w[N];
int main()
{	
	cin>>n>>m;
	for(int i = 1; i <= n;i++) cin >> w[i] >> v[i];
	for(int i = 1; i <= n;i++)
		for(int j = w[i]; j <= m; j++)
			f[j] = max(f[j], f[j-w[i]] + v[i]);
	cout << f[m] << endl;
	return 0;	
}
```

### 零钱兑换

#### 相关链接

+ [322. 零钱兑换 ](https://leetcode.cn/problems/coin-change/)

+ [518. 零钱兑换 II ](https://leetcode.cn/problems/coin-change-ii/)

#### 相关题目

[322. 零钱兑换 ](https://leetcode.cn/problems/coin-change/)

给你一个整数数组 `coins` ，表示不同面额的硬币；以及一个整数 `amount` ，表示总金额。

计算并返回可以凑成总金额所需的 **最少的硬币个数** 。如果没有任何一种硬币组合能组成总金额，返回 `-1` 。

你可以认为每种硬币的数量是无限的。

**示例 1：**

```
输入：coins = [1, 2, 5], amount = 11
输出：3 
解释：11 = 5 + 5 + 1
```

[518. 零钱兑换 II ](https://leetcode.cn/problems/coin-change-ii/)

给你一个整数数组 `coins` 表示不同面额的硬币，另给一个整数 `amount` 表示总金额。

请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 `0` 。

假设每一种面额的硬币有无限个。 题目数据保证结果符合 32 位带符号整数。

**示例 1：**

```
输入：amount = 5, coins = [1, 2, 5]
输出：4
解释：有四种方式可以凑成总金额：
5=5
5=2+2+1
5=2+1+1+1
5=1+1+1+1+1
```

#### 解题思路

[322. 零钱兑换 ](https://leetcode.cn/problems/coin-change/)

1. 确定dp数组以及下标的含义

   **dp[j]：凑足总额为j所需钱币的最少个数为dp[j]**

2. 确定递推公式

   凑足总额为j - coins[i]的最少个数为dp[j - coins[i]]，那么只需要加上一个钱币coins[i]即dp[j - coins[i]] + 1就是dp[j]（考虑coins[i]）

   所以dp[j] 要取所有 dp[j - coins[i]] + 1 中最小的。

   递推公式：dp[j] = min(dp[j - coins[i]] + 1, dp[j]);

3. dp数组如何初始化

   首先凑足总金额为0所需钱币的个数一定是0，那么dp[0] = 0;其他下标对应的数值呢？

   考虑到递推公式的特性，dp[j]必须初始化为一个最大的数，否则就会在min(dp[j - coins[i]] + 1, dp[j])比较的过程中被初始值覆盖。

   所以下标非0的元素都是应该是最大值。代码如下：

```text
vector<int> dp(amount + 1, INT_MAX);
dp[0] = 0;
```

4. 确定遍历顺序

   本题求钱币最小个数，**那么钱币有顺序和没有顺序都可以，都不影响钱币的最小个数**。

   所以本题并不强调集合是组合还是排列。

5. 举例推导dp数组

以上分析完毕，C++代码如下：

```cpp
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        vector<int> dp(amount + 1, INT_MAX);
        dp[0] = 0;
        for (int i = 0; i < coins.size(); i++) { // 遍历物品
            for (int j = coins[i]; j <= amount; j++) { // 遍历背包
                if (dp[j - coins[i]] != INT_MAX) { // 如果dp[j - coins[i]]是初始值则跳过
                    dp[j] = min(dp[j - coins[i]] + 1, dp[j]);
                }
            }
        }
        if (dp[amount] == INT_MAX) return -1;
        return dp[amount];
    }
};
```

[518. 零钱兑换 II ](https://leetcode.cn/problems/coin-change-ii/)

1. 确定dp数组以及下标的含义

   dp[j]：凑成总金额j的货币组合数为dp[j]

2. 确定递推公式

   dp[j] 就是所有的dp[j - coins[i]]（考虑coins[i]的情况）相加。所以递推公式：dp[j] += dp[j - coins[i]];

3. dp数组如何初始化

   首先dp[0]一定要为1，dp[0] = 1是 递归公式的基础。

4. 确定遍历顺序

   因为纯完全背包求得装满背包的最大价值是多少，和凑成总和的元素有没有顺序没关系，即：有顺序也行，没有顺序也行！

   本题是求凑出来的方案个数，且每个方案个数是为组合数。那么本题，两个for循环的先后顺序可就有说法了。

   **！！！如果求组合数就是外层for循环遍历物品，内层for遍历背包！！！**

   **！！！如果求排列数就是外层for遍历背包，内层for循环遍历物品！！！**

   外层for循环遍历物品（钱币），内层for遍历背包（金钱总额）的情况。代码如下：

   ```cpp
   for (int i = 0; i < coins.size(); i++) { // 遍历物品
       for (int j = coins[i]; j <= amount; j++) { // 遍历背包容量
           dp[j] += dp[j - coins[i]];
       }
   }
   ```

   假设：coins[0] = 1，coins[1] = 5。

   那么就是先把1加入计算，然后再把5加入计算，得到的方法数量只有{1, 5}这种情况。而不会出现{5, 1}的情况。

   **所以这种遍历顺序中dp[j]里计算的是组合数！**

以上分析完毕，C++代码如下：

```cpp
class Solution {
public:
    int change(int amount, vector<int>& coins) {
        vector<int> dp(amount + 1, 0);
        dp[0] = 1;
        for (int i = 0; i < coins.size(); i++) { // 遍历物品
            for (int j = coins[i]; j <= amount; j++) { // 遍历背包
                dp[j] += dp[j - coins[i]];
            }
        }
        return dp[amount];
    }
};
```

### 组合总和

#### 相关链接

+ [39. 组合总和 ](https://leetcode.cn/problems/combination-sum/)
+ [40. 组合总和 II ](https://leetcode.cn/problems/combination-sum-ii/)
+ [216. 组合总和 III ](https://leetcode.cn/problems/combination-sum-iii/)

+ [377. 组合总和 Ⅳ ](https://leetcode.cn/problems/combination-sum-iv/)

#### 相关题目

[377. 组合总和 Ⅳ ](https://leetcode.cn/problems/combination-sum-iv/)

给你一个由 **不同** 整数组成的数组 `nums` ，和一个目标整数 `target` 。请你从 `nums` 中找出并返回总和为 `target` 的元素组合的个数。

题目数据保证答案符合 32 位整数范围。

**示例 1：**

```
输入：nums = [1,2,3], target = 4
输出：7
解释：
所有可能的组合为：
(1, 1, 1, 1)
(1, 1, 2)
(1, 2, 1)
(1, 3)
(2, 1, 1)
(2, 2)
(3, 1)
请注意，顺序不同的序列被视作不同的组合。
```

#### 解题思路

弄清什么是组合，什么是排列很重要。

组合不强调顺序，(1,5)和(5,1)是同一个组合。

排列强调顺序，(1,5)和(5,1)是两个不同的排列。

但其本质是本题求的是排列总和，而且仅仅是求排列总和的个数，并不是把所有的排列都列出来。

1. 确定dp数组以及下标的含义

   **dp[i]: 凑成目标正整数为i的排列个数为dp[i]**

2. 确定递推公式

   dp[i]（考虑nums[j]）可以由 dp[i - nums[j]]（不考虑nums[j]） 推导出来。

   因为只要得到nums[j]，排列个数dp[i - nums[j]]，就是dp[i]的一部分。

3. dp数组如何初始化

   因为递推公式dp[i] += dp[i - nums[j]]的缘故，dp[0]要初始化为1，这样递归其他dp[i]的时候才会有数值基础。

   至于dp[0] = 1 有没有意义呢？其实没有意义，所以我也不去强行解释它的意义了，因为题目中也说了：给定目标值是正整数！ 所以dp[0] = 1是没有意义的，仅仅是为了推导递推公式。

   至于非0下标的dp[i]应该初始为多少呢？初始化为0，这样才不会影响dp[i]累加所有的dp[i - nums[j]]。

4. 确定遍历顺序
   
   个数可以不限使用，说明这是一个完全背包。得到的集合是排列，说明需要考虑元素之间的顺序。本题要求的是排列，那么这个for循环嵌套的顺序可以有说法了。
   在518.零钱兑换II 中就已经讲过了。

   **！！！如果求组合数就是外层for循环遍历物品，内层for遍历背包！！！**
   

**！！！如果求排列数就是外层for遍历背包，内层for循环遍历物品！！！**

如果把遍历nums（物品）放在外循环，遍历target的作为内循环的话，举一个例子：计算dp[4]的时候，结果集只有 {1,3} 这样的集合，不会有{3,1}这样的集合，因为nums遍历放在外层，3只能出现在1后面！

   所以本题遍历顺序最终遍历顺序：**target（背包）放在外循环，将nums（物品）放在内循环，内循环从前到后遍历**。

5. 举例来推导dp数组

以上分析完毕，C++代码如下：

```cpp
class Solution {
public:
    int combinationSum4(vector<int>& nums, int target) {
        vector<int> dp(target + 1, 0);
        dp[0] = 1;
        for (int i = 0; i <= target; i++) { // 遍历背包
            for (int j = 0; j < nums.size(); j++) { // 遍历物品
                if (i - nums[j] >= 0 && dp[i] < INT_MAX - dp[i - nums[j]]) {
                    dp[i] += dp[i - nums[j]];
                }
            }
        }
        return dp[target];
    }
};
```

C++测试用例有两个数相加超过int的数据，所以需要在if里加上`dp[i] < INT_MAX - dp[i - num]`。

### 完全平方数

#### 相关链接

+ [279. 完全平方数 ](https://leetcode.cn/problems/perfect-squares/)

#### 相关题目

给你一个整数 `n` ，返回 *和为 `n` 的完全平方数的最少数量* 。

**完全平方数** 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，`1`、`4`、`9` 和 `16` 都是完全平方数，而 `3` 和 `11` 不是。

**示例 1：**

```
输入：n = 12
输出：3 
解释：12 = 4 + 4 + 4
```

#### 解题思路

动规五部曲分析如下：

1. 确定dp数组（dp table）以及下标的含义

   **dp[j]：和为j的完全平方数的最少数量为dp[j]**

2. 确定递推公式

   dp[j] 可以由dp[j - i * i]推出， dp[j - i * i] + 1 便可以凑成dp[j]。

   此时我们要选择最小的dp[j]，所以递推公式：dp[j] = min(dp[j - i * i] + 1, dp[j]);

3. dp数组如何初始化

   dp[0]表示 和为0的完全平方数的最小数量，那么dp[0]一定是0。

   有同学问题，那0 * 0 也算是一种啊，为啥dp[0] 就是 0呢？

   看题目描述，找到若干个完全平方数（比如 1, 4, 9, 16, ...），题目描述中可没说要从0开始，dp[0]=0完全是为了递推公式。

   非0下标的dp[j]应该是多少呢？

   从递归公式dp[j] = min(dp[j - i * i] + 1, dp[j]);中可以看出每次dp[j]都要选最小的，**所以非0下标的dp[j]一定要初始为最大值，这样dp[j]在递推的时候才不会被初始值覆盖**。

4. 确定遍历顺序

   我们知道这是完全背包，

   如果求组合数就是外层for循环遍历物品，内层for遍历背包。

   如果求排列数就是外层for遍历背包，内层for循环遍历物品。

   **所以本题外层for遍历背包，内层for遍历物品，还是外层for遍历物品，内层for遍历背包，都是可以的！**

   我这里先给出外层遍历背包，内层遍历物品的代码：

```cpp
vector<int> dp(n + 1, INT_MAX);
dp[0] = 0;
for (int i = 0; i <= n; i++) { // 遍历背包
    for (int j = 1; j * j <= i; j++) { // 遍历物品
        dp[i] = min(dp[i - j * j] + 1, dp[i]);
    }
}
```

5. 举例推导dp数组

完整代码如下：

```cpp
class Solution {
public:
    int numSquares(int n) {
        vector<int> dp(n + 1, INT_MAX);
        dp[0] = 0;
        for (int i = 0; i <= n; i++) { // 遍历背包
            for (int j = 1; j * j <= i; j++) { // 遍历物品
                if(dp[i - j * j] != INT_MAX)    // 这步最好还是加上
                    dp[i] = min(dp[i - j * j] + 1, dp[i]);
            }
        }
        return dp[n];
    }
};
```



### 单词拆分

#### 相关链接

+ [139. 单词拆分](https://leetcode.cn/problems/word-break/description/)

#### 相关题目

给你一个字符串 `s` 和一个字符串列表 `wordDict` 作为字典。请你判断是否可以利用字典中出现的单词拼接出 `s` 

**注意：**不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。

**示例 1：**

```
输入: s = "leetcode", wordDict = ["leet", "code"]
输出: true
解释: 返回 true 因为 "leetcode" 可以由 "leet" 和 "code" 拼接成。
```

#### 解题思路

1. 确定dp数组以及下标的含义

   **dp[i] : 字符串长度为i的话，dp[i]为true，表示可以拆分为一个或多个在字典中出现的单词**。

2. 确定递推公式

   如果确定dp[j] 是true，且 [j, i] 这个区间的子串出现在字典里，那么dp[i]一定是true。（j < i ）。

   所以递推公式是 

   `if([j, i] 这个区间的子串出现在字典里` &&  `dp[j]是true `那么 `dp[i] = true`。

3. dp数组如何初始化

   从递归公式中可以看出，dp[i] 的状态依靠 dp[j]是否为true，那么dp[0]就是递归的根基，dp[0]一定要为true，否则递归下去后面都都是false了。

   那么dp[0]有没有意义呢？dp[0]表示如果字符串为空的话，说明出现在字典里。

   但题目中说了“给定一个非空字符串 s” 所以测试数据中不会出现i为0的情况，那么dp[0]初始为true完全就是为了推导公式。

   下标非0的dp[i]初始化为false，只要没有被覆盖说明都是不可拆分为一个或多个在字典中出现的单词。

4. 确定遍历顺序

   题目中说是拆分为一个或多个在字典中出现的单词，所以这是完全背包。

   还要讨论两层for循环的前后循序。

   **如果求组合数就是外层for循环遍历物品，内层for遍历背包**。

   **如果求排列数就是外层for遍历背包，内层for循环遍历物品**。

   而本题其实我们求的是排列数，为什么呢。 拿 s = "applepenapple", wordDict = ["apple", "pen"] 举例。

   "apple", "pen" 是物品，那么我们要求 物品的组合一定是 "apple" + "pen" + "apple" 才能组成 "applepenapple"。

   "apple" + "apple" + "pen" 或者 "pen" + "apple" + "apple" 是不可以的，那么我们就是强调物品之间顺序。

   所以说，本题一定是 先遍历 背包，在遍历物品。

5. 举例推导dp[i]

完整代码如下：

```cpp
class Solution {
public:
    bool wordBreak(string s, vector<string>& wordDict) {
        unordered_set<string> wordSet(wordDict.begin(), wordDict.end());
        vector<bool> dp(s.size() + 1, false);
        dp[0] = true;
        for (int i = 1; i <= s.size(); i++) {   // 遍历背包
            for (int j = 0; j < i; j++) {       // 遍历物品
                string word = s.substr(j, i - j); //substr(起始位置，截取的个数)
                if (wordSet.find(word) != wordSet.end() && dp[j]) {
                    dp[i] = true;
                }
            }
        }
        return dp[s.size()];
    }
};
```

## 多重背包

### 多重背包理论

#### 相关链接

+ [多重背包问题 I - AcWing](https://www.acwing.com/problem/content/4/)
+ [多重背包问题 II - AcWing](https://www.acwing.com/problem/content/5/)
+ [多重背包问题 III - AcWing](https://www.acwing.com/problem/content/6/)

#### 相关题目

有 N 种物品和一个容量是 V 的背包。

第 i 种物品最多有 si 件，每件体积是 vi，价值是 wi。

求解将哪些物品装入背包，可使物品体积总和不超过背包容量，且价值总和最大。
输出最大价值。

**输入格式**

第一行两个整数，N，V 用空格隔开，分别表示物品种数和背包容积。

接下来有 N行，每行三个整数 vi,wi,si 用空格隔开，分别表示第 i 种物品的体积、价值和数量。

**输出格式**

输出一个整数，表示最大价值。

**数据范围**

+ 0 < N ≤ 1000
+ 0 < V ≤ 2000
+ 0 < vi,wi,si ≤ 2000

##### 提示

多重背包问题 I 为普通多重背包

多重背包问题 II 为多重背包的二进制优化方法

多重背包问题 III 为多重背包的单调队列优化方法。

#### 输入样例

```
4 5
1 2 3
2 4 1
3 4 3
4 5 2
```

#### 输出样例：

```
10
```

#### 解题思路

普通版本

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=110;
int f[N][N];
int v[N];
int w[N];
int s[N];
int main(){
    int n,m; 
    cin>>n>>m;
    for(int i=1;i<=n;i++) cin>>v[i]>>w[i]>>s[i];
    for(int i=1;i<=n;i++)
        for(int j=0;j<=m;j++)
            for(int k=0;k*v[i]<=j&&k<=s[i];k++)
                f[i][j]=max(f[i][j],f[i-1][j-k*v[i]]+w[i]*k);
    
    cout<<f[n][m]<<endl;
    return 0;
}

```

二进制优化版本

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=25000,M=2010;
int n,m;
int v[N],w[N];
int f[N];
int main(){
	cin>>n>>m;
	int cnt=0;//第几组背包 
	for(int i = 1; i <= n;i++){
		int a,b,s;
		cin>>a>>b>>s;
		int k = 1;//乘2的跳板 
		while(k <= s){
			cnt++;
			v[cnt]=a * k;
			w[cnt]=b * k;
			s -= k;
			k *= 2; 
		}
		if(s > 0){
			cnt++;
			v[cnt] = a * s;
			w[cnt] = b * s;
		} 
	}
	n = cnt;
    
	//01背包问题
	for(int i = 1;i <= n;i++)
		for(int j = m;j >= v[i];j--)
			f[j] = max(f[j],f[j - v[i]] + w[i]);
    
	cout<<f[m]<<endl;
	return 0;	
}
```



## 分组背包

### 分组背包理论

#### 相关链接

#### 相关题目

#### 解题思路



## 线性DP

## 基础DP问题

### 数字三角形

#### 相关链接

+ [898. 数字三角形 - AcWing](https://www.acwing.com/problem/content/900/)

+ [3304. 数字三角形 - AcWing](https://www.acwing.com/problem/content/3307/)

+ [118. 杨辉三角 ](https://leetcode.cn/problems/pascals-triangle/submissions/226629364/)
+ [119. 杨辉三角 II](https://leetcode.cn/problems/pascals-triangle-ii/description/)
+ [剑指 Offer II  三角形中最小路径之和](https://leetcode.cn/problems/IlPe0q/?favorite=e8X3pBZi)

#### 相关题目



#### 解题思路



```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=510,INF=1e9;
int n;
int a[N][N];
int f[N][N];
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++)
		for(int j=1;j<=i;j++)
			scanf("%d",&a[i][j]);
	for(int i=0;i<=n;i++)
		for(int j=0;j<=i+1;j++)
			f[i][j]=-INF;
	f[1][1]=a[1][1];
	for(int i=2;i<=n;i++)
		for(int j=1;j<=i;j++)
			f[i][j]=max(f[i-1][j-1]+a[i][j],f[i-1][j]+a[i][j]);
	int res=-INF;
	for(int i=0;i<=n;i++) res=max(f[n][i],res);
	cout<<res<<endl;
	return 0;
}

```



### 斐波那契数

#### 相关链接

+ [509. 斐波那契数 ](https://leetcode.cn/problems/fibonacci-number/description/)

#### 相关题目

**斐波那契数** （通常用 `F(n)` 表示）形成的序列称为 **斐波那契数列** 。该数列由 `0` 和 `1` 开始，后面的每一项数字都是前面两项数字的和。也就是：

```
F(0) = 0，F(1) = 1
F(n) = F(n - 1) + F(n - 2)，其中 n > 1
```

给定 `n` ，请计算 `F(n)` 。

**示例 1：**

```
输入：n = 2
输出：1
解释：F(2) = F(1) + F(0) = 1 + 0 = 1
```

#### 解题思路

1. 确定dp数组以及下标的含义

   **`dp[i]` 的定义为：第 i 个数的斐波那契数值是`dp[i]`**

2. 确定递推公式

   **题目已经把递推公式直接给我们了：状态转移方程 `dp[i] = dp[i - 1] + dp[i - 2];`**

3. dp数组如何初始化

   **题目中把如何初始化也直接给我们了，如下：**

	```text
dp[0] = 0;
dp[1] = 1;
	```

4. 确定遍历顺序

   从递归公式`dp[i] = dp[i - 1] + dp[i - 2]`中可以看出，`dp[i]`是依赖 `dp[i - 1] 和 dp[i - 2]`，那么遍历的顺序一定是从前到后遍历的

5. 举例推导dp数组

   按照这个递推公式`dp[i] = dp[i - 1] + dp[i - 2]`，我们来推导一下，当 n 为10的时候，dp数组应该是如下的数列：`0 1 1 2 3 5 8 13 21 34 55`，如果代码写出来，发现结果不对，就把dp数组打印出来看看和我们推导的数列是不是一致的。以上我们用动规的方法分析完了，C++代码如下：

	```cpp
class Solution {
public:
    int fib(int n) {
        if (n <= 1) return n;
        vector<int> dp(n + 1);
        dp[0] = 0;
        dp[1] = 1;
        for (int i = 2; i <= n; i++) {
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        return dp[n];
    }
};
	```

当然可以发现，我们只需要维护两个数值就可以了，不需要记录整个序列。代码如下：

```cpp
class Solution {
public:
    int fib(int n) {
        if (n <= 1) return n;
        int dp[2];
        dp[0] = 0;
        dp[1] = 1;
        for (int i = 2; i <= n; i++) {
            int sum = dp[0] + dp[1];
            dp[0] = dp[1];
            dp[1] = sum;
        }
        return dp[1];
    }
};
```

### 爬楼梯

#### 相关链接

+ [70. 爬楼梯](https://leetcode.cn/problems/climbing-stairs/description/)

#### 相关题目

假设你正在爬楼梯。需要 `n` 阶你才能到达楼顶。

每次你可以爬 `1` 或 `2` 个台阶。你有多少种不同的方法可以爬到楼顶呢？

**示例 1：**

```
输入：n = 2
输出：2
解释：有两种方法可以爬到楼顶。
1. 1 阶 + 1 阶
2. 2 阶
```

#### 解题思路

1. 确定dp数组以及下标的含义

   `dp[i]`： 爬到第i层楼梯，有`dp[i]`种方法

2. 确定递推公式

   如果可以推出`dp[i]`呢？从`dp[i]`的定义可以看出，`dp[i]` 可以有两个方向推出来。

+ 首先是`dp[i - 1]`，上`i - 1`层楼梯，有`dp[i - 1`]种方法，那么再一步跳一个台阶就是`dp[i]`。
+ 然后就是`dp[i - 2]`，上`i - 2` 层楼梯，有`dp[i - 2]`种方法，那么再一步跳两个台阶就是`dp[i]`。
+ 那么`dp[i]`就是 `dp[i - 1]`  与 `dp[i - 2]`之和！所以`dp[i] = dp[i - 1] + dp[i - 2]` 。

3. dp数组如何初始化

   大部分解释说 `dp[0]` 应该为 1 的理由其实是因为`dp[0] = 1`的话在递推的过程中 i 从 2 开始遍历本题就能过，然后就往结果上靠去解释`dp[0] = 1`。需要注意的是：题目中说了n是一个正整数，题目根本就没说 n 有为 0 的情况。所以本题其实就不应该讨论dp[0]的初始化！

   `dp[1] = 1，dp[2] = 2`  这个初始化大家应该都没有争议的。所以：不考虑dp[0]如果初始化，只初始化`dp[1] = 1，dp[2] = 2`，然后从`i = 3`开始递推，这样才符合dp[i]的定义。

4. 确定遍历顺序

   从递推公式`dp[i] = dp[i - 1] + dp[i - 2]`中可以看出，遍历顺序一定是从前向后遍历的

5. 举例推导dp数组

   **此时大家应该发现了，这不就是斐波那契数列么！**唯一的区别是，没有讨论`dp[0]`应该是什么，因为`dp[0]`在本题没有意义！

以上五部分析完之后，C++代码如下：

```cpp
class Solution {
public:
    int climbStairs(int n) {
        if (n <= 1) return n; // 因为下面直接对dp[2]操作了，防止空指针
        vector<int> dp(n + 1);
        dp[1] = 1;
        dp[2] = 2;
        for (int i = 3; i <= n; i++) { // 注意i是从3开始的
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        return dp[n];
    }
};
```

当然依然也可以，优化一下空间复杂度，代码如下：

```cpp
class Solution {
public:
    int climbStairs(int n) {
        if (n <= 1) return n;
        int dp[3];
        dp[1] = 1;
        dp[2] = 2;
        for (int i = 3; i <= n; i++) {
            int sum = dp[1] + dp[2];
            dp[1] = dp[2];
            dp[2] = sum;
        }
        return dp[2];
    }
};
```

**爬楼梯进阶版**

**面试题改为：一步可以一个台阶，两个台阶，三个台阶，.......，最多到 m个台阶。问有多少种不同的方法可以爬到楼顶呢？**

1. 确定dp数组以及下标的含义

   **dp[i]：爬到有i个台阶的楼顶，有dp[i]种方法**。

2. 确定递推公式

   求装满背包有几种方法，递推公式一般都是dp[i] += dp[i - nums[j]];

   本题呢，dp[i]有几种来源，dp[i - 1]，dp[i - 2]，dp[i - 3] 等等，即：dp[i - j]

   那么递推公式为：dp[i] += dp[i - j]

3. dp数组如何初始化

   既然递归公式是 dp[i] += dp[i - j]，那么dp[0] 一定为1，dp[0]是递归中一切数值的基础所在，如果dp[0]是0的话，其他数值都是0了。

   下标非0的dp[i]初始化为0，因为dp[i]是靠dp[i-j]累计上来的，dp[i]本身为0这样才不会影响结果

4. 确定遍历顺序

   这是背包里求排列问题，即：**1、2 步 和 2、1 步都是上三个台阶，但是这两种方法不一样！**

   所以需将target放在外循环，将nums放在内循环。

   每一步可以走多次，这是完全背包，内循环需要从前向后遍历。

5. 举例来推导dp数组

以上分析完毕，代码中m表示最多可以爬m个台阶，普通爬楼梯题目为2，C++代码如下：

```cpp
class Solution {
public:
    int climbStairs(int n) {
        vector<int> dp(n + 1, 0);
        dp[0] = 1;
        for (int i = 1; i <= n; i++) { // 遍历背包
            for (int j = 1; j <= m; j++) { // 遍历物品
                if (i - j >= 0) dp[i] += dp[i - j];
            }
        }
        return dp[n];
    }
};
```

### 使用最小花费爬楼梯

#### 相关链接

+ [746. 使用最小花费爬楼梯 ](https://leetcode.cn/problems/min-cost-climbing-stairs/)

#### 相关题目

给你一个整数数组 `cost` ，其中 `cost[i]` 是从楼梯第 `i` 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。你可以选择从下标为 `0` 或下标为 `1` 的台阶开始爬楼梯。请你计算并返回达到楼梯顶部的最低花费。

**示例 1：**

```
输入：cost = [10,15,20]
输出：15
解释：你将从下标为 1 的台阶开始。
- 支付 15 ，向上爬两个台阶，到达楼梯顶部。
总花费为 15 。
```

#### 解题思路

1. 确定dp数组以及下标的含义

   **dp[i]的定义：到达第i台阶所花费的最少体力为dp[i]。**

2. 确定递推公式

   可以有两个途径得到dp[i]，一个是dp[i-1] 一个是dp[i-2]。

   dp[i - 1] 跳到 dp[i] 需要花费 dp[i - 1] + cost[i - 1]。

   dp[i - 2] 跳到 dp[i] 需要花费 dp[i - 2] + cost[i - 2]。

   一定是选最小的，所以dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);

3. dp数组如何初始化

   看一下递归公式，dp[i]由dp[i - 1]，dp[i - 2]推出，既然初始化所有的dp[i]是不可能的，那么只初始化dp[0]和dp[1]就够了，其他的最终都是dp[0]dp[1]推出。

   那么 dp[0] 应该是多少呢？ 根据dp数组的定义，到达第0台阶所花费的最小体力为dp[0]，那么有同学可能想，那dp[0] 应该是 cost[0]，例如 cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1] 的话，dp[0] 就是 cost[0] 应该是1。其实题目描述中明确说了 “你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯。” 也就是说 从 到达 第 0 个台阶是不花费的，但从 第0 个台阶 往上跳的话，需要花费 cost[0]。**所以初始化 dp[0] = 0，dp[1] = 0;**

4. 确定遍历顺序

   从前到后遍历cost数组就可以了。

5. 举例推导dp数组

完整代码

```cpp
class Solution {
public:
    int minCostClimbingStairs(vector<int>& cost) {
        vector<int> dp(cost.size() + 1);
        dp[0] = 0;
        dp[1] = 0;
        for(int i = 2; i <= cost.size(); i++){
            dp[i] = min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);
        }
        return dp[cost.size()];
    }
};
```

### 不同路径

#### 相关链接

+ [62. 不同路径 ](https://leetcode.cn/problems/unique-paths/)

#### 相关题目

一个机器人位于一个 `m x n` 网格的左上角 （起始点在下图中标记为 “Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。

问总共有多少条不同的路径？

**示例 1：**

<img src="https://assets.leetcode.com/uploads/2018/10/22/robot_maze.png" alt="示例1" style="zoom:80%;box-shadow:rgba(0,0,0,0) 0 0px 0px 0px;" />

```
输入：m = 3, n = 7
输出：28
```

#### 解题思路

机器人从(0 , 0) 位置出发，到(m - 1, n - 1)终点。

1. 确定dp数组（dp table）以及下标的含义

   `dp[i][j]` ：表示从(0 ,0)出发，到(i, j) 有 `dp[i][j]` 条不同的路径。

2. 确定递推公式

   想要求`dp[i][j]`，只能有两个方向来推导出来，即`dp[i - 1][j]` 和 `dp[i][j - 1]`。

   此时在回顾一下 `dp[i - 1][j]` 表示啥，是从(0, 0)的位置到(i - 1, j)有几条路径，`dp[i][j - 1]`同理。

   那么很自然，`dp[i][j]` = `dp[i - 1][j]` + `dp[i][j - 1]`，因为`dp[i][j]`只有这两个方向过来。

3. dp数组的初始化

   如何初始化呢，首先`dp[i][0]`一定都是1，因为从(0, 0)的位置到(i, 0)的路径只有一条，那么`dp[0][j]`也同理。所以初始化代码为：

```cpp
for (int i = 0; i < m; i++) dp[i][0] = 1;
for (int j = 0; j < n; j++) dp[0][j] = 1;
```

4. 确定遍历顺序

   这里要看一下递推公式`dp[i][j] = dp[i - 1][j] + dp[i][j - 1]`，`dp[i][j]`都是从其上方和左方推导而来，那么从左到右一层一层遍历就可以了。

   这样就可以保证推导`dp[i][j]`的时候，`dp[i - 1][j]` 和 `dp[i][j - 1]`一定是有数值的。

5. 举例推导dp数组

完整代码

```cpp
class Solution {
public:
    int uniquePaths(int m, int n) {
        vector<vector<int>> dp(m, vector<int>(n, 0));
        for (int i = 0; i < m; i++) dp[i][0] = 1;
        for (int j = 0; j < n; j++) dp[0][j] = 1;
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
            }
        }
        return dp[m - 1][n - 1];
    }
};
```

### 不同路径 II

#### 相关链接

+ [63. 不同路径 II ](https://leetcode.cn/problems/unique-paths-ii/)

#### 相关题目

一个机器人位于一个 `m x n` 网格的左上角 （起始点在下图中标记为 “Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。

现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？

网格中的障碍物和空位置分别用 `1` 和 `0` 来表示。

**示例 1：**

<img src="https://assets.leetcode.com/uploads/2020/11/04/robot1.jpg" alt="示例1" style="zoom:80%;box-shadow:rgba(0,0,0,0) 0 0px 0px 0px;" />

```
输入：obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]
输出：2
解释：3x3 网格的正中间有一个障碍物。
从左上角到右下角一共有 2 条不同的路径：
1. 向右 -> 向右 -> 向下 -> 向下
2. 向下 -> 向下 -> 向右 -> 向右
```

#### 解题思路

1. 确定dp数组（dp table）以及下标的含义

`dp[i][j]` ：表示从（0 ，0）出发，到(i, j) 有`dp[i][j]`条不同的路径。

2. 确定递推公式

递推公式和[62. 不同路径 ](https://leetcode.cn/problems/unique-paths/)一样，`dp[i][j] = dp[i - 1][j] + dp[i][j - 1]`。

但这里需要注意一点，因为有了障碍，(i, j) 如果就是障碍的话应该就保持初始状态（初始状态为0）。

所以代码为：

```cpp
if (obstacleGrid[i][j] == 0) { // 当(i, j)没有障碍的时候，再推导dp[i][j]
    dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
}
```

3. dp数组如何初始化

因为从(0, 0)的位置到(i, 0)的路径只有一条，所以这条路上有阻碍后面都将不可到达！所以本题初始化代码为：

```cpp
vector<vector<int>> dp(m, vector<int>(n, 0));
for (int i = 0; i < m && obstacleGrid[i][0] == 0; i++) dp[i][0] = 1;
for (int j = 0; j < n && obstacleGrid[0][j] == 0; j++) dp[0][j] = 1;
```

4. 确定遍历顺序

从递归公式`dp[i][j] = dp[i - 1][j] + dp[i][j - 1]` 中可以看出，一定是从左到右一层一层遍历，这样保证推导`dp[i][j]`的时候，`dp[i - 1][j]` 和 `dp[i][j - 1]`一定是有数值。代码如下：

```cpp
for (int i = 1; i < m; i++) {
    for (int j = 1; j < n; j++) {
        if (obstacleGrid[i][j] == 1) continue;
        dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
    }
}
```

5. 举例推导dp数组

```cpp
class Solution {
public:
    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
        int m = obstacleGrid.size();
        int n = obstacleGrid[0].size();
        //如果在起点或终点出现了障碍，直接返回0
	    if (obstacleGrid[m - 1][n - 1] == 1 || obstacleGrid[0][0] == 1) return 0;
        vector<vector<int>> dp(m, vector<int>(n, 0));
        for (int i = 0; i < m && obstacleGrid[i][0] == 0; i++) dp[i][0] = 1;
        for (int j = 0; j < n && obstacleGrid[0][j] == 0; j++) dp[0][j] = 1;
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                if (obstacleGrid[i][j] == 1) continue;
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
            }
        }
        return dp[m - 1][n - 1];
    }
};
```



### 打家劫舍

#### 相关链接

+ [198. 打家劫舍](https://leetcode.cn/problems/house-robber/)

#### 相关题目

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，**如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警**。

给定一个代表每个房屋存放金额的非负整数数组，计算你 **不触动警报装置的情况下** ，一夜之内能够偷窃到的最高金额。

#### 解题思路

1. 确定dp数组（dp table）以及下标的含义

   **dp[i]：考虑下标i（包括i）以内的房屋，最多可以偷窃的金额为dp[i]**。

2. 确定递推公式

   决定dp[i]的因素就是第i房间偷还是不偷。

   如果偷第i房间，那么dp[i] = dp[i - 2] + nums[i] ，即：第i-1房一定是不考虑的，找出 下标i-2（包括i-2）以内的房屋，最多可以偷窃的金额为dp[i-2] 加上第i房间偷到的钱。

   如果不偷第i房间，那么dp[i] = dp[i - 1]，即考虑i-1房，（**注意这里是考虑，并不是一定要偷i-1房，这是很多同学容易混淆的点**）

   然后dp[i]取最大值，即`dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]);`

3. dp数组如何初始化

   从递推公式dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]);可以看出，递推公式的基础就是dp[0] 和 dp[1]

   从dp[i]的定义上来讲，dp[0] 一定是 nums[0]，dp[1]就是nums[0]和nums[1]的最大值即：dp[1] = max(nums[0], nums[1]);

4. 确定遍历顺序

   dp[i] 是根据dp[i - 2] 和 dp[i - 1] 推导出来的，那么一定是从前到后遍历！

   代码如下：

   ```cpp
   for (int i = 2; i < nums.size(); i++) {
       dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]);
   }
   ```

5. 举例推导dp数组

```cpp
class Solution {
public:
    int rob(vector<int>& nums) {
        if (nums.size() == 0) return 0;
        if (nums.size() == 1) return nums[0];
        vector<int> dp(nums.size());
        dp[0] = nums[0];
        dp[1] = max(nums[0], nums[1]);
        for (int i = 2; i < nums.size(); i++) {
            dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]);
        }
        return dp[nums.size() - 1];
    }
};
```

### 打家劫舍II

#### 相关链接

+ [213. 打家劫舍 II ](https://leetcode.cn/problems/house-robber-ii/)

#### 相关题目

你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 **围成一圈** ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，**如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警** 。

给定一个代表每个房屋存放金额的非负整数数组，计算你 **在不触动警报装置的情况下** ，今晚能够偷窃到的最高金额。

**示例 1：**

```
输入：nums = [2,3,2]
输出：3
解释：你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。
```

#### 解题思路

+ 情况一：考虑不包含首尾元素
+ 情况二：考虑包含首元素，不包含尾元素
+ 情况三：考虑包含尾元素，不包含首元素

**注意我这里用的是"考虑"**，例如情况三，虽然是考虑包含尾元素，但不一定要选尾部元素！ 对于情况三，取nums[1] 和 nums[3]就是最大的。**而情况二 和 情况三 都包含了情况一了，所以只考虑情况二和情况三就可以了。**

代码如下：

```cpp
// 注意注释中的情况二情况三，以及把198.打家劫舍的代码抽离出来了
class Solution {
public:
    int rob(vector<int>& nums) {
        if (nums.size() == 0) return 0;
        if (nums.size() == 1) return nums[0];
        int result1 = robRange(nums, 0, nums.size() - 2); // 情况二
        int result2 = robRange(nums, 1, nums.size() - 1); // 情况三
        return max(result1, result2);
    }
    // 198.打家劫舍的逻辑
    int robRange(vector<int>& nums, int start, int end) {
        if (end == start) return nums[start];
        vector<int> dp(nums.size());
        dp[start] = nums[start];
        dp[start + 1] = max(nums[start], nums[start + 1]);
        for (int i = start + 2; i <= end; i++) {
            dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]);
        }
        return dp[end];
    }
};
```

### 买卖股票的最佳时机

#### 相关链接

+ [121. 买卖股票的最佳时机 ](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/description/)

#### 相关题目

给定一个数组 `prices` ，它的第 `i` 个元素 `prices[i]` 表示一支给定股票第 `i` 天的价格。

你只能选择 **某一天** 买入这只股票，并选择在 **未来的某一个不同的日子** 卖出该股票。设计一个算法来计算你所能获取的最大利润。

返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 `0` 。

**示例 1：**

```
输入：[7,1,5,3,6,4]
输出：5
解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。
```

#### 解题思路

1. 确定dp数组（dp table）以及下标的含义

+ `dp[i][0]` 表示第 i 天持有股票所得最多现金 
+ `dp[i][1]` 表示第 i 天不持有股票所得最多现金

2. 确定递推公式

如果第 i 天持有股票即`dp[i][0]`， 那么可以由两个状态推出来

+ 第i-1天就持有股票，那么就保持现状，所得现金就是昨天持有股票的所得现金 即：`dp[i - 1][0]`
+ 第 i 天买入股票，所得现金就是买入今天的股票后所得现金即：`-prices[i]`

那么`dp[i][0]`应该选所得现金最大的，所以`dp[i][0] = max(dp[i - 1][0], -prices[i]);`

如果第i天不持有股票即`dp[i][1]`， 也可以由两个状态推出来

+ 第i-1天就不持有股票，那么就保持现状，所得现金就是昨天不持有股票的所得现金 即：`dp[i - 1][1]`
+ 第 i 天卖出股票，所得现金就是按照今天股票佳价格卖出后所得现金即：`prices[i] + dp[i - 1][0]`

同样`dp[i][1]`取最大的，`dp[i][1] = max(dp[i - 1][1], prices[i] + dp[i - 1][0]);`

3. dp数组如何初始化

`dp[0][0]`表示第0天持有股票，此时的持有股票就一定是买入股票了，因为不可能有前一天推出来，所以`dp[0][0] -= prices[0];`

`dp[0][1]`表示第0天不持有股票，不持有股票那么现金就是0，所以`dp[0][1] = 0;`

4. 确定遍历顺序

从递推公式可以看出dp[i]都是有dp[i - 1]推导出来的，那么一定是从前向后遍历。

5. 举例推导dp数组

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int len = prices.size();
        if (len == 0) return 0;
        vector<vector<int>> dp(len, vector<int>(2));
        dp[0][0] -= prices[0];
        dp[0][1] = 0;
        for (int i = 1; i < len; i++) {
            dp[i][0] = max(dp[i - 1][0], -prices[i]);
            dp[i][1] = max(dp[i - 1][1], prices[i] + dp[i - 1][0]);
        }
        return dp[len - 1][1];
    }
};
```

滚动数组优化，优先理解普通版本

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int len = prices.size();
        vector<vector<int>> dp(2, vector<int>(2)); // 注意这里只开辟了一个2 * 2大小的二维数组
        dp[0][0] -= prices[0];
        dp[0][1] = 0;
        for (int i = 1; i < len; i++) {
            dp[i % 2][0] = max(dp[(i - 1) % 2][0], -prices[i]);
            dp[i % 2][1] = max(dp[(i - 1) % 2][1], prices[i] + dp[(i - 1) % 2][0]);
        }
        return dp[(len - 1) % 2][1];
    }
};
```

### 买卖股票的最佳时机 II

#### 相关链接

+ [122. 买卖股票的最佳时机 II ](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/)

#### 相关题目

给你一个整数数组 `prices` ，其中 `prices[i]` 表示某支股票第 `i` 天的价格。

在每一天，你可以决定是否购买/出售股票。你在任何时候 **最多** 只能持有 **一股** 股票。你也可以先购买，然后在 **同一天** 出售。

返回 你能获得的 **最大** 利润。

**示例 1：**

```
输入：prices = [7,1,5,3,6,4]
输出：7
解释：在第 2 天（股票价格 = 1）的时候买入，
	 在第 3 天（股票价格 = 5）的时候卖出, 
	 这笔交易所能获得利润 = 5 - 1 = 4。
     随后，在第 4 天（股票价格 = 3）的时候买入，
     在第 5 天（股票价格 = 6）的时候卖出, 
     这笔交易所能获得利润 = 6 - 3 = 3。
     总利润为 4 + 3 = 7。
```

#### 解题思路

这里重申一下dp数组的含义：

+ `dp[i][0]` 表示第 i 天持有股票所得现金。
+ `dp[i][1]` 表示第 i 天不持有股票所得最多现金

如果第i天持有股票即`dp[i][0]`， 那么可以由两个状态推出来

+ 第 i - 1 天就持有股票，那么就保持现状，所得现金就是昨天持有股票的所得现金 即：`dp[i - 1][0]`
+ 第 i 天买入股票，所得现金就是昨天不持有股票的所得现金减去 今天的股票价格 即：`dp[i - 1][1] - prices[i]`

**注意这里和121. 买卖股票的最佳时机唯一不同的地方，就是推导`dp[i][0]`的时候，第i天买入股票的情况**。

在121. 买卖股票的最佳时机中，因为股票全程只能买卖一次，所以如果买入股票，那么第 i 天持有股票即`dp[i][0]`一定就是 -prices[i]。

而本题，因为一只股票可以买卖多次，所以当第i天买入股票的时候，所持有的现金可能有之前买卖过的利润。

那么第i天持有股票即`dp[i][0]`，如果是第 i 天买入股票，所得现金就是昨天不持有股票的所得现金 减去 今天的股票价格 即：`dp[i - 1][1] - prices[i]`。

在来看看如果第i天不持有股票即dp[i][1]的情况， 依然可以由两个状态推出来

+ 第 i-1 天就不持有股票，那么就保持现状，所得现金就是昨天不持有股票的所得现金 即：`dp[i - 1][1]`
+ 第 i 天卖出股票，所得现金就是按照今天股票佳价格卖出后所得现金即：`prices[i] + dp[i - 1][0]`

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int len = prices.size();
        vector<vector<int>> dp(len, vector<int>(2, 0));
        dp[0][0] -= prices[0];
        dp[0][1] = 0;
        for (int i = 1; i < len; i++) {
            dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] - prices[i]); 
            // 注意这里是和121. 买卖股票的最佳时机唯一不同的地方。
            dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i]);
        }
        return dp[len - 1][1];
    }
};
```

这里我依然给出滚动数组的版本，C++代码如下：

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int len = prices.size();
        vector<vector<int>> dp(2, vector<int>(2)); // 注意这里只开辟了一个2 * 2大小的二维数组
        dp[0][0] -= prices[0];
        dp[0][1] = 0;
        for (int i = 1; i < len; i++) {
            dp[i % 2][0] = max(dp[(i - 1) % 2][0], dp[(i - 1) % 2][1] - prices[i]);
            dp[i % 2][1] = max(dp[(i - 1) % 2][1], prices[i] + dp[(i - 1) % 2][0]);
        }
        return dp[(len - 1) % 2][1];
    }
};
```

### 买卖股票的最佳时机III

#### 相关链接

+ [123. 买卖股票的最佳时机 III ](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/)

#### 相关题目

给定一个数组，它的第 `i` 个元素是一支给定的股票在第 `i` 天的价格。

设计一个算法来计算你所能获取的最大利润。你最多可以完成 **两笔** 交易。

**注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

**示例 1:**

```
输入：prices = [3,3,5,0,0,3,1,4]
输出：6
解释：在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，
	 这笔交易所能获得利润 = 3-0 = 3 。
     随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，
     这笔交易所能获得利润 = 4-1 = 3 。
```

#### 解题思路

1. 确定dp数组以及下标的含义

   一天一共就有五个状态，

   （1）没有操作

   （2）第一次买入

   （3）第一次卖出

   （4）第二次买入

   （5）第二次卖出

   `dp[i][j]` 中 i 表示第 i 天，j 为 [0 - 4] 五个状态，`dp[i][j]`表示第 i 天状态 j 所剩最大现金。

2. 确定递推公式

`dp[i][1]`，**表示的是第i天，买入股票的状态，并不是说一定要第 i 天买入股票，这是很多同学容易陷入的误区。**

达到`dp[i][1]`状态，有两个具体操作：

+ 操作一：第 i 天买入股票了，那么`dp[i][1] = dp[i-1][0] - prices[i]`
+ 操作二：第 i 天没有操作，而是沿用前一天买入的状态，即：`dp[i][1] = dp[i - 1][1]`

那么`dp[i][1]`究竟选 `dp[i-1][0] - prices[i]`，还是`dp[i - 1][1]`呢？

一定是选最大的，所以 `dp[i][1] = max(dp[i-1][0] - prices[i], dp[i - 1][1]);`

同理`dp[i][2]`也有两个操作：

+ 操作一：第i天卖出股票了，那么`dp[i][2] = dp[i - 1][1] + prices[i]`
+ 操作二：第i天没有操作，沿用前一天卖出股票的状态，即：`dp[i][2] = dp[i - 1][2]`

所以`dp[i][2] = max(dp[i - 1][1] + prices[i], dp[i - 1][2])`

同理可推出剩下状态部分：

`dp[i][3] = max(dp[i - 1][3], dp[i - 1][2] - prices[i]);`

`dp[i][4] = max(dp[i - 1][4], dp[i - 1][3] + prices[i]);`

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        if (prices.size() == 0) return 0;
        vector<vector<int>> dp(prices.size(), vector<int>(5, 0));
        dp[0][1] = -prices[0];
        dp[0][3] = -prices[0];
        for (int i = 1; i < prices.size(); i++) {
            dp[i][0] = dp[i - 1][0];
            dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i]);
            dp[i][2] = max(dp[i - 1][2], dp[i - 1][1] + prices[i]);
            dp[i][3] = max(dp[i - 1][3], dp[i - 1][2] - prices[i]);
            dp[i][4] = max(dp[i - 1][4], dp[i - 1][3] + prices[i]);
        }
        return dp[prices.size() - 1][4];
    }
};
```

这里我依然给出滚动数组的版本，C++代码如下：

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        if (prices.size() == 0) return 0;
        vector<int> dp(5, 0);
        dp[1] = -prices[0];
        dp[3] = -prices[0];
        for (int i = 1; i < prices.size(); i++) {
            dp[1] = max(dp[1], dp[0] - prices[i]);
            dp[2] = max(dp[2], dp[1] + prices[i]);
            dp[3] = max(dp[3], dp[2] - prices[i]);
            dp[4] = max(dp[4], dp[3] + prices[i]);
        }
        return dp[4];
    }
};
```

### 买卖股票的最佳时机含手续费

#### 相关链接

+ [714. 买卖股票的最佳时机含手续费](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/)

#### 相关题目

给定一个整数数组 `prices`，其中 `prices[i]`表示第 `i` 天的股票价格 ；整数 `fee` 代表了交易股票的手续费用。

你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。

返回获得利润的最大值。

**注意：**这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。

**示例 1：**

```
输入：prices = [1, 3, 2, 8, 4, 9], fee = 2
输出：8
解释：能够达到的最大利润:  
在此处买入 prices[0] = 1
在此处卖出 prices[3] = 8
在此处买入 prices[4] = 4
在此处卖出 prices[5] = 9
总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8
```

#### 解题思路

这里重申一下dp数组的含义：

dp[i][0] 表示第i天持有股票所省最多现金。 dp[i][1] 表示第i天不持有股票所得最多现金

如果第i天持有股票即dp[i][0]， 那么可以由两个状态推出来

+ 第i-1天就持有股票，那么就保持现状，所得现金就是昨天持有股票的所得现金 即：`dp[i - 1][0]`
+ 第i天买入股票，所得现金就是昨天不持有股票的所得现金减去 今天的股票价格 即：`dp[i - 1][1] - prices[i]`

所以：`dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] - prices[i]);`

在来看看如果第i天不持有股票即dp[i][1]的情况， 依然可以由两个状态推出来

+ 第i-1天就不持有股票，那么就保持现状，所得现金就是昨天不持有股票的所得现金 即：`dp[i - 1][1]`
+ 第i天卖出股票，所得现金就是按照今天股票价格卖出后所得现金，**注意这里需要有手续费了**即：`dp[i - 1][0] + prices[i] - fee`

所以：`dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i] - fee);`

完整代码如下：

```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices, int fee) {
        int n = prices.size();
        vector<vector<int>> dp(n, vector<int>(2, 0));
        dp[0][0] -= prices[0]; // 持股票
        for (int i = 1; i < n; i++) {
            dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] - prices[i]);
            dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i] - fee);
        }
        return max(dp[n - 1][0], dp[n - 1][1]);
    }
};
```

### 不同的二叉搜索树

#### 相关链接

+ [96. 不同的二叉搜索树](https://leetcode.cn/problems/unique-binary-search-trees/description/)

#### 相关题目

给你一个整数 `n` ，求恰由 `n` 个节点组成且节点值从 `1` 到 `n` 互不相同的 **二叉搜索树** 有多少种？返回满足题意的二叉搜索树的种数。

**示例 1：**

<img src="https://assets.leetcode.com/uploads/2021/01/18/uniquebstn3.jpg" alt="示例1" style="zoom:50%;box-shadow:rgba(0,0,0,0) 0 0px 0px 0px;" />

```
输入：n = 3
输出：5
```

#### 解题思路

1. 确定dp数组（dp table）以及下标的含义

   **dp[i] : 1 到 i 为节点组成的二叉搜索树的个数为dp[i] 。**

2. 确定递推公式

   dp[3]，就是 元素1为头结点搜索树的数量 + 元素2为头结点搜索树的数量 + 元素3为头结点搜索树的数量

   元素1为头结点搜索树的数量 = 右子树有2个元素的搜索树数量 * 左子树有0个元素的搜索树数量

   元素2为头结点搜索树的数量 = 右子树有1个元素的搜索树数量 * 左子树有1个元素的搜索树数量

   元素3为头结点搜索树的数量 = 右子树有0个元素的搜索树数量 * 左子树有2个元素的搜索树数量

   有2个元素的搜索树数量就是dp[2]。

   有1个元素的搜索树数量就是dp[1]。

   有0个元素的搜索树数量就是dp[0]。

   所以dp[3] = dp[2] * dp[0] + dp[1] * dp[1] + dp[0] * dp[2]

   在上面的分析中，其实已经看出其递推关系

   ```cpp
   dp[i] += dp[以j为头结点左子树节点数量] * dp[以j为头结点右子树节点数量]
   ```

   j 相当于是头结点的元素，从1遍历到 i 为止。

   所以递推公式：`dp[i] += dp[j - 1] * dp[i - j];` j-1 为 j 为头结点左子树节点数量，i-j 为以j为头结点右子树节点数量

3. dp数组如何初始化

   初始化，只需要初始化dp[0]就可以了，推导的基础，都是dp[0]。那么dp[0]应该是多少呢？

   从定义上来讲，空节点也是一棵二叉树，也是一棵二叉搜索树，这是可以说得通的。

   从递归公式上来讲，`dp[以j为头结点左子树节点数量] * dp[以j为头结点右子树节点数量]` 中以j为头结点左子树节点数量为0，也需要`dp[以j为头结点左子树节点数量] = 1`， 否则乘法的结果就都变成0了。

   **所以初始化dp[0] = 1**

4. 确定遍历顺序

   首先一定是遍历节点数，从递归公式：dp[i] += dp[j - 1] * dp[i - j]可以看出，节点数为i的状态是依靠 i之前节点数的状态。那么遍历 i 里面每一个数作为头结点的状态，用 j 来遍历。

   代码如下：

```cpp
for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= i; j++) {
        dp[i] += dp[j - 1] * dp[i - j];
    }
}
```

5. 举例推导dp数组

完整代码：

```cpp
class Solution {
public:
    int numTrees(int n) {
        vector<int> dp(n + 1);
        dp[0] = 1;
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= i; j++) {
                dp[i] += dp[j - 1] * dp[i - j];
            }
        }
        return dp[n];
    }
};
```

## 子序列问题

### 最长递增子序列

#### 相关链接

+ [300. 最长递增子序列 ](https://leetcode.cn/problems/longest-increasing-subsequence/)

#### 相关题目

给你一个整数数组 `nums` ，找到其中最长严格递增子序列的长度。

**子序列** 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，`[3,6,2,7]` 是数组 `[0,3,1,6,2,2,7]` 的子序列。

**示例 1：**

```
输入：nums = [10,9,2,5,3,7,101,18]
输出：4
解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。
```

#### 解题思路

1. dp[i]的定义

   **dp[i]表示i之前包括i的以nums[i]结尾最长上升子序列的长度**

2. 状态转移方程

   位置 i 的最长升序子序列等于 j 从0到 i-1 各个位置的最长升序子序列 + 1 的最大值。

   所以：if (nums[i] > nums[j]) dp[i] = max(dp[i], dp[j] + 1);

   **注意这里不是要dp[i] 与 dp[j] + 1进行比较，而是我们要取dp[j] + 1的最大值**。

3. dp[i]的初始化

   每一个i，对应的dp[i]（即最长上升子序列）起始大小至少都是1.

4. 确定遍历顺序

   dp[i] 是有0到i-1各个位置的最长升序子序列 推导而来，那么遍历i一定是从前向后遍历。

   j 其实就是0到i-1，遍历i的循环在外层，遍历j则在内层，代码如下：

```cpp
for (int i = 1; i < nums.size(); i++) {
    for (int j = 0; j < i; j++) {
        if (nums[i] > nums[j]) dp[i] = max(dp[i], dp[j] + 1);
    }
    if (dp[i] > result) result = dp[i]; // 取长的子序列
}
```

5. 举例推导dp数组

完整代码如下：

```cpp
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        if (nums.size() <= 1) return nums.size();
        vector<int> dp(nums.size(), 1);
        int result = 0;
        for (int i = 1; i < nums.size(); i++) {
            for (int j = 0; j < i; j++) 
                if (nums[i] > nums[j]) dp[i] = max(dp[i], dp[j] + 1);
            if (dp[i] > result) result = dp[i]; // 取长的子序列
        }
        return result;
    }
};
```

### 最长连续递增序列

#### 相关链接

+ [674. 最长连续递增序列](https://leetcode.cn/problems/longest-continuous-increasing-subsequence/)

#### 相关题目

给定一个未经排序的整数数组，找到最长且 **连续递增的子序列**，并返回该序列的长度。

**连续递增的子序列** 可以由两个下标 `l` 和 `r`（`l < r`）确定，如果对于每个 `l <= i < r`，都有 `nums[i] < nums[i + 1]` ，那么子序列 `[nums[l], nums[l + 1], ..., nums[r - 1], nums[r]]` 就是连续递增子序列。

**示例 1：**

```
输入：nums = [1,3,5,4,7]
输出：3
解释：最长连续递增序列是 [1,3,5], 长度为3。
尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为 5 和 7 在原数组里被 4 隔开。 
```

#### 解题思路

1. 确定dp数组（dp table）以及下标的含义

   **dp[i]：以下标i为结尾的数组的连续递增的子序列长度为dp[i]**。

   注意这里的定义，一定是以下标i为结尾，并不是说一定以下标0为起始位置。

2. 确定递推公式

   如果 nums[i + 1] > nums[i]，那么以 i+1 为结尾的数组的连续递增的子序列长度 一定等于 以i为结尾的数组的连续递增的子序列长度 + 1 。即：dp[i + 1] = dp[i] + 1;

   因为本题要求连续递增子序列，所以就必要比较nums[i + 1]与nums[i]，而不用去比较nums[j]与nums[i] （j是在0到i之间遍历）。

   既然不用j了，那么也不用两层for循环，本题一层for循环就行，比较nums[i + 1] 和 nums[i]。

3. dp数组如何初始化

   以下标i为结尾的数组的连续递增的子序列长度最少也应该是1，即就是nums[i]这一个元素。所以dp[i]应该初始1;

4. 确定遍历顺序

   从递推公式上可以看出， dp[i + 1]依赖dp[i]，所以一定是从前向后遍历。

   本文在确定递推公式的时候也说明了为什么本题只需要一层for循环，代码如下：

```cpp
for (int i = 0; i < nums.size() - 1; i++) {
    if (nums[i + 1] > nums[i]) { // 连续记录
        dp[i + 1] = dp[i] + 1; // 递推公式
    }
}
```

5. 举例推导dp数组

完整代码如下：

```cpp
class Solution {
public:
    int findLengthOfLCIS(vector<int>& nums) {
        if (nums.size() <= 1) return nums.size();
        int result = 1;
        vector<int> dp(nums.size(), 1);
        for (int i = 0; i < nums.size() - 1; i++) {
            if (nums[i + 1] > nums[i]) dp[i + 1] = dp[i] + 1; 
            if (dp[i + 1] > result) result = dp[i + 1];
        }
        return result;
    }
};
```

### 最长重复子数组

#### 相关链接

+ [718. 最长重复子数组 ](https://leetcode.cn/problems/maximum-length-of-repeated-subarray/)

#### 相关题目

给两个整数数组 `nums1` 和 `nums2` ，返回 *两个数组中 **公共的** 、长度最长的子数组的长度* 。

**示例 1：**

```
输入：nums1 = [1,2,3,2,1], nums2 = [3,2,1,4,7]
输出：3
解释：长度最长的公共子数组是 [3,2,1] 。
```

#### 解题思路

1. 确定dp数组（dp table）以及下标的含义

   `dp[i][j]` ：以下标i - 1为结尾的A，和以下标j - 1为结尾的B，最长重复子数组长度为`dp[i][j]`。 

2. 确定递推公式

   根据`dp[i][j]`的定义，`dp[i][j]`的状态只能由`dp[i - 1][j - 1]`推导出来。

   即当A[i - 1] 和B[j - 1]相等的时候，`dp[i][j] = dp[i - 1][j - 1] + 1;`

   根据递推公式可以看出，遍历i 和 j 要从1开始！

3. dp数组如何初始化

   此时细心的同学应该发现，那`dp[0][0]`是什么含义呢？总不能是以下标-1为结尾的A数组吧

   其实`dp[i][j]`的定义也就决定着，我们在遍历`dp[i][j]`的时候i 和 j都要从1开始。

   根据`dp[i][j]`的定义，`dp[i][0]` 和`dp[0][j]`其实都是没有意义的！

   但`dp[i][0]` 和`dp[0][j]`要初始值，因为 为了方便递归公式`dp[i][j] = dp[i - 1][j - 1] + 1;`

   所以`dp[i][0]` 和`dp[0][j]`初始化为0。

   举个例子A[0]如果和B[0]相同的话，`dp[1][1] = dp[0][0] + 1`，只有`dp[0][0]`初始为0，正好符合递推公式逐步累加起来。

4. 确定遍历顺序

   外层for循环遍历A，内层for循环遍历B。

   那又有同学问了，外层for循环遍历B，内层for循环遍历A。不行么？

   也行，一样的，我这里就用外层for循环遍历A，内层for循环遍历B了。

   同时题目要求长度最长的子数组的长度。所以在遍历的时候顺便把`dp[i][j]`的最大值记录下来。

   代码如下：

```cpp
for (int i = 1; i <= A.size(); i++) {
    for (int j = 1; j <= B.size(); j++) {
        if (A[i - 1] == B[j - 1]) {
            dp[i][j] = dp[i - 1][j - 1] + 1;
        }
        if (dp[i][j] > result) result = dp[i][j];
    }
}
```

5. 举例推导dp数组

完整代码如下：

```cpp
class Solution {
public:
    int findLength(vector<int>& A, vector<int>& B) {
        vector<vector<int>> dp (A.size() + 1, vector<int>(B.size() + 1, 0));
        int result = 0;
        for (int i = 1; i <= A.size(); i++) {
            for (int j = 1; j <= B.size(); j++) {
                if (A[i - 1] == B[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                }
                if (dp[i][j] > result) result = dp[i][j];
            }
        }
        return result;
    }
};
```

### 最长公共子序列

#### 相关链接

+ [1143. 最长公共子序列 ](https://leetcode.cn/problems/longest-common-subsequence/)

#### 相关题目

给定两个字符串 `text1` 和 `text2`，返回这两个字符串的最长 **公共子序列** 的长度。如果不存在 **公共子序列** ，返回 `0` 。

一个字符串的 **子序列** 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。

+ 例如，`"ace"` 是 `"abcde"` 的子序列，但 `"aec"` 不是 `"abcde"` 的子序列。

两个字符串的 **公共子序列** 是这两个字符串所共同拥有的子序列。

**示例 1：**

```
输入：nums = [1,3,5,4,7]
输出：3
解释：最长连续递增序列是 [1,3,5], 长度为3。
尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为 5 和 7 在原数组里被 4 隔开。 
```

#### 解题思路

1. 确定dp数组（dp table）以及下标的含义

   `dp[i][j]`：长度为[0, i - 1]的字符串text1与长度为[0, j - 1]的字符串text2的最长公共子序列为`dp[i][j]`

   有同学会问：为什么要定义长度为[0, i - 1]的字符串text1，定义为长度为[0, i]的字符串text1不香么？

   这样定义是为了后面代码实现方便，如果非要定义为为长度为[0, i]的字符串text1也可以，大家可以试一试！

2. 确定递推公式

   主要就是两大情况： 

   (1) 如果text1[i - 1] 与 text2[j - 1]相同，那么找到了一个公共元素，即：`dp[i][j] = dp[i - 1][j - 1] + 1;`

   (2) 如果text1[i - 1] 与 text2[j - 1]不相同，那就看看text1[0, i - 2]与text2[0, j - 1]的最长公共子序列 和 text1[0, i - 1]与text2[0, j - 2]的最长公共子序列，取最大的。即：`dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);`
```cpp
if (text1[i - 1] == text2[j - 1]) {
    dp[i][j] = dp[i - 1][j - 1] + 1;
} else {
    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
}
```

3. dp数组如何初始化

   先看看`dp[i][0]`应该是多少呢？

   test1[0, i-1]和空串的最长公共子序列自然是0，所以`dp[i][0] = 0;`

   同理`dp[0][j]`也是0。

4. 确定遍历顺序

   那么为了在递推的过程中，这三个方向都是经过计算的数值，所以要从前向后，从上到下来遍历这个矩阵。

5. 举例推导dp数组

```cpp
class Solution {
public:
    int longestCommonSubsequence(string text1, string text2) {
        vector<vector<int>> dp(text1.size() + 1, vector<int>(text2.size() + 1, 0));
        for (int i = 1; i <= text1.size(); i++) {
            for (int j = 1; j <= text2.size(); j++) {
                if (text1[i - 1] == text2[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }
        return dp[text1.size()][text2.size()];
    }
};
```



### 最大子序和

#### 相关链接

+ [53. 最大子数组和](https://leetcode.cn/problems/maximum-subarray/)

#### 相关题目

给你一个整数数组 `nums` ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

**子数组** 是数组中的一个连续部分。

**示例 1：**

```
输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
输出：6
解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。
```

#### 解题思路

1. 确定dp数组（dp table）以及下标的含义

   **dp[i]：包括下标i之前的最大连续子序列和为dp[i]**。

2. 确定递推公式

   dp[i]只有两个方向可以推出来：

   (1) dp[i - 1] + nums[i]，即：nums[i]加入当前连续子序列和

   (2) nums[i]，即：从头开始计算当前连续子序列和
   
   一定是取最大的，所以dp[i] = max(dp[i - 1] + nums[i], nums[i]);
   
3. dp数组如何初始化

   从递推公式可以看出来dp[i]是依赖于dp[i - 1]的状态，dp[0]就是递推公式的基础。

   dp[0]应该是多少呢?

   根据dp[i]的定义，很明显dp[0]应为nums[0]即dp[0] = nums[0]。

4. 确定遍历顺序

   递推公式中dp[i]依赖于dp[i - 1]的状态，需要从前向后遍历。

5. 举例推导dp数组

完整代码如下：

```cpp
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        if (nums.size() == 0) return 0;
        vector<int> dp(nums.size());
        dp[0] = nums[0];
        int result = dp[0];
        for (int i = 1; i < nums.size(); i++) {
            dp[i] = max(dp[i - 1] + nums[i], nums[i]); // 状态转移公式
            if (dp[i] > result) result = dp[i]; // result 保存dp[i]的最大值
        }
        return result;
    }
};
```

### 不相交的线

#### 相关链接

+ [1035. 不相交的线](https://leetcode.cn/problems/uncrossed-lines/description/)

#### 相关题目

在两条独立的水平线上按给定的顺序写下 `nums1` 和 `nums2` 中的整数。

现在，可以绘制一些连接两个数字 `nums1[i]` 和 `nums2[j]` 的直线，这些直线需要同时满足满足：

+  `nums1[i] == nums2[j]`
+ 且绘制的直线不与任何其他连线（非水平线）相交。

请注意，连线即使在端点也不能相交：每个数字只能属于一条连线。

以这种方法绘制线条，并返回可以绘制的最大连线数。

**示例 1：**

<img src="https://assets.leetcode.com/uploads/2019/04/26/142.png" alt="示例1" style="zoom: 10%;box-shadow:rgba(0,0,0,0) 0 0px 0px 0px;"  />

```
输入：nums1 = [1,4,2], nums2 = [1,2,4]
输出：2
解释：可以画出两条不交叉的线，如上图所示。 
但无法画出第三条不相交的直线，因为从 nums1[1]=4 到 nums2[2]=4 的直线
将与从 nums1[2]=2 到 nums2[1]=2 的直线相交。
```

#### 解题思路

绘制一些连接两个数字 A[i] 和 B[j] 的直线，只要 A[i] == B[j]，且直线不能相交！

直线不能相交，这就是说明在字符串A中 找到一个与字符串B相同的子序列，且这个子序列不能改变相对顺序，只要相对顺序不改变，链接相同数字的直线就不会相交。

其实也就是说A和B的最长公共子序列是[1,4]，长度为2。 这个公共子序列指的是相对顺序不变（即数字4在字符串A中数字1的后面，那么数字4也应该在字符串B数字1的后面）。这么分析完之后，大家可以发现：**本题说是求绘制的最大连线数，其实就是求两个字符串的最长公共子序列的长度！**

```cpp
class Solution {
public:
    int maxUncrossedLines(vector<int>& A, vector<int>& B) {
        vector<vector<int>> dp(A.size() + 1, vector<int>(B.size() + 1, 0));
        for (int i = 1; i <= A.size(); i++) {
            for (int j = 1; j <= B.size(); j++) {
                if (A[i - 1] == B[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }
        return dp[A.size()][B.size()];
    }
};
```



## 状态压缩DP

## 树形DP

### 打家劫舍 III

#### 相关链接

+ [337. 打家劫舍 III ](https://leetcode.cn/problems/house-robber-iii/)

#### 相关题目

小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为 `root` 。

除了 `root` 之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果 **两个直接相连的房子在同一天晚上被打劫** ，房屋将自动报警。

给定二叉树的 `root` 。返回 在不触动警报的情况下 ，小偷能够盗取的最高金额 。

**示例1:**

<img src="https://assets.leetcode.com/uploads/2021/03/10/rob1-tree.jpg" alt="示例1" style="zoom:50%;box-shadow:rgba(0,0,0,0) 0 0px 0px 0px;" />

```
输入: root = [3,2,3,null,3,null,1]
输出: 7 
解释: 小偷一晚能够盗取的最高金额 3 + 3 + 1 = 7
```

#### 解题思路

对于树的话，首先就要想到遍历方式，前中后序（深度优先搜索）还是层序遍历（广度优先搜索）。

**本题一定是要后序遍历，因为通过递归函数的返回值来做下一步计算**。

如果抢了当前节点，两个孩子就不能动，如果没抢当前节点，就可以考虑抢左右孩子（**注意这里说的是“考虑”**）

**这道题目算是树形dp的入门题目，因为是在树上进行状态转移，我们在讲解二叉树的时候说过递归三部曲，那么下面我以递归三部曲为框架，其中融合动规五部曲的内容来进行讲解**。

1. 确定递归函数的参数和返回值

   这里我们要求一个节点 偷与不偷的两个状态所得到的金钱，那么返回值就是一个长度为2的数组。

   其实这里的返回数组就是dp数组。

	所以dp数组（dp table）以及下标的含义：下标为0记录不偷该节点所得到的的最大金钱，下标为1记录偷该节点所得到的的最大金钱。**所以本题dp数组就是一个长度为2的数组！**

	那么有同学可能疑惑，长度为2的数组怎么标记树中每个节点的状态呢？
	
	**别忘了在递归的过程中，系统栈会保存每一层递归的参数**。
	
	如果还不理解的话，就接着往下看，看到代码就理解了哈。

2. 确定终止条件

   在遍历的过程中，如果遇到空节点的话，很明显，无论偷还是不偷都是0，所以就返回，这也相当于dp数组的初始化

```text
if (cur == NULL) return vector<int>{0, 0};
```

3. 确定遍历顺序

   首先明确的是使用后序遍历。 因为通过递归函数的返回值来做下一步计算。

   通过递归左节点，得到左节点偷与不偷的金钱。

   通过递归右节点，得到右节点偷与不偷的金钱。

   代码如下：

```cpp
// 下标0：不偷，下标1：偷
vector<int> left = robTree(cur->left); // 左
vector<int> right = robTree(cur->right); // 右
// 中
```

4. 确定单层递归的逻辑

   如果是偷当前节点，那么左右孩子就不能偷，`val1 = cur->val + left[0] + right[0];` （**如果对下标含义不理解就在回顾一下dp数组的含义**）

   如果不偷当前节点，那么左右孩子就可以偷，至于到底偷不偷一定是选一个最大的，所以：`val2 = max(left[0], left[1]) + max(right[0], right[1]);`

   最后当前节点的状态就是{val2, val1}; 即：{不偷当前节点得到的最大金钱，偷当前节点得到的最大金钱}

   代码如下：

```cpp
vector<int> left = robTree(cur->left); // 左
vector<int> right = robTree(cur->right); // 右
// 偷cur
int val1 = cur->val + left[0] + right[0];
// 不偷cur
int val2 = max(left[0], left[1]) + max(right[0], right[1]);
return {val2, val1};
```

5. 举例推导dp数组

递归三部曲与动规五部曲分析完毕，C++代码如下：

```cpp
class Solution {
public:
    int rob(TreeNode* root) {
        vector<int> result = robTree(root);
        return max(result[0], result[1]);
    }
    // 长度为2的数组，0：不偷，1：偷
    vector<int> robTree(TreeNode* cur) {
        if (cur == NULL) return vector<int>{0, 0};
        vector<int> left = robTree(cur->left);
        vector<int> right = robTree(cur->right);
        // 偷cur，那么就不能偷左右节点。
        int val1 = cur->val + left[0] + right[0];
        // 不偷cur，那么可以偷也可以不偷左右节点，则取较大的情况
        int val2 = max(left[0], left[1]) + max(right[0], right[1]);
        return {val2, val1};
    }
};
```



+ 快速排序
+ 归并排序
+ 冒泡排序
+ 二分查找
+ 数组问题
  + 矩阵乘法
  
  + 旋转数组
  
  + [48. 旋转图像 ](https://leetcode.cn/problems/rotate-image/)
  
  + [1886. 判断矩阵经轮转后是否一致 ](https://leetcode.cn/problems/determine-whether-matrix-can-be-obtained-by-rotation/)
+ 前缀和问题
+ 位运算问题
+ 年份日期问题
+ 多关键字比较
+ 斐波那契问题
+ 进制转换问题
+ 字母数字转换
+ 回文数问题

**优化**

上面的代码还存在一定的优化空间, 在于如何更高效的计算一个子字符串是否是回文字串。上述代码`isPalindrome`函数运用双指针的方法来判定对于一个字符串`s`, 给定起始下标和终止下标, 截取出的子字符串是否是回文字串。但是其中有一定的重复计算存在:

例如给定字符串`"abcde"`, 在已知`"bcd"`不是回文字串时, 不再需要去双指针操作`"abcde"`而可以直接判定它一定不是回文字串。

具体来说, 给定一个字符串`s`, 长度为`n`, 它成为回文字串的充分必要条件是`s[0] == s[n-1]`且`s[1:n-1]`是回文字串。

大家如果熟悉动态规划这种算法的话, 我们可以高效地事先一次性计算出, 针对一个字符串`s`, 它的任何子串是否是回文字串, 然后在我们的回溯函数中直接查询即可, 省去了双指针移动判定这一步骤.

具体参考代码如下:

```cpp
class Solution {
private:
    vector<vector<string>> result;
    vector<string> path; // 放已经回文的子串
    vector<vector<bool>> isPalindrome; // 放事先计算好的是否回文子串的结果
    void backtracking (const string& s, int startIndex) {
        // 如果起始位置已经大于s的大小，说明已经找到了一组分割方案了
        if (startIndex >= s.size()) {
            result.push_back(path);
            return;
        }
        for (int i = startIndex; i < s.size(); i++) {
            if (isPalindrome[startIndex][i]) {   // 是回文子串
                // 获取[startIndex,i]在s中的子串
                string str = s.substr(startIndex, i - startIndex + 1);
                path.push_back(str);
            } else {                                // 不是回文，跳过
                continue;
            }
            backtracking(s, i + 1); // 寻找i+1为起始位置的子串
            path.pop_back(); // 回溯过程，弹出本次已经填在的子串
        }
    }
    void computePalindrome(const string& s) {
        // isPalindrome[i][j] 代表 s[i:j](双边包括)是否是回文字串 
        isPalindrome.resize(s.size(), vector<bool>(s.size(), false)); // 根据字符串s, 刷新布尔矩阵的大小
        for (int i = s.size() - 1; i >= 0; i--) { 
            // 需要倒序计算, 保证在i行时, i+1行已经计算好了
            for (int j = i; j < s.size(); j++) {
                if (j == i) {isPalindrome[i][j] = true;}
                else if (j - i == 1) {isPalindrome[i][j] = (s[i] == s[j]);}
                else {isPalindrome[i][j] = (s[i] == s[j] && isPalindrome[i+1][j-1]);}
            }
        }
    }
public:
    vector<vector<string>> partition(string s) {
        result.clear();
        path.clear();
        computePalindrome(s);
        backtracking(s, 0);
        return result;
    }
};
```

+ 开关问题



+ 将数组 C[1:n]中所有奇数移到偶数之前，要求时间复杂度为 O(n)
+ 在一个顺序表 L 之中，编写算法删除所有值介于 x 和 y 之间的元素， （x<=y）,要求算法尽可能高效。
+ 从尾到头打印单链表，要求不改变该链表顺序，算法尽可能高效。
+ 已知带头节点的单链表 L，编写一个尽可能高效的算法将 L 中的元素就地逆置。
+ 线性表 C=（a1, b1, a2, b2, …, an, bn）采用带头结点的单链表存放，设计 算法，利用原表元素的结点，将其拆分成两个单链表，是 A=（an, an-1, …, a2, a1） B=(b1, 
+ 二叉树采用二叉链表结构存储，编写实现二叉树后序线索化的算法。
+ 已知二叉树采用二叉链表结构存储，编写算法，判断其是否为完全二叉树
+ 二叉树采用二叉链表存储表示。编写算法求取一棵二叉树的路径长度。 （二叉树的路径长度是指从树根到树中所有节点的路径长度之和。二叉树 中节点的路径长度为该节点所在的层次值-1，根节点为第一层，以此类推）
+ 已知二叉树采用二叉链表存放，要求编写算法不用递归也不用栈，返回二叉 树 T 的后序序列中的第一个结点的指针。



