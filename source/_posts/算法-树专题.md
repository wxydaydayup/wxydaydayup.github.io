---
rauthor: WangXinYi
img: /images/homePage/树.webp
summary: 算法-树专题
categories:
  - 算法
  - C++
  - 树
tags:
  - 算法
  - C++
  - 树
top: false
typora-root-url: ..
date: 2021-10-20 12:06:57
---

## 力扣核心代码变为ACM模式

### 参考链接

+ [力扣上如何自己构造二叉树输入用例 | 代码随想录 ](https://www.programmercarl.com/前序/ACM模式如何构建二叉树.html#java)

### 算法思路

将要打印的树以Vector数组输入，再遍历一遍，将顺序存储变为链式存储即可。

> 注意: 结束规则是 i * 2 + 1 < vec.size()，是将下面 if (i * 2 + 1 < vec.size())进行了省略，放到了for循环里面。

> 为什么结束规则不能是i * 2 + 2 < arr.length呢 ?
> 因为如果i * 2 + 2 < arr.length 是结束条件，那么i * 2 + 1这个符合条件的节点就被忽略掉了。
> 例如 [2,7,9,-1,1,9,6,-1,-1,10]  这样的一个二叉树, 最后的10就会被忽略掉。

```cpp
#include<bits/stdc++.h>
using namespace std;
struct TreeNode{
	int val;
	TreeNode *left;
	TreeNode *right;
	TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};

TreeNode* construct_binary_tree(const vector<int> &vec){
	vector<TreeNode*> vecTree(vec.size(), NULL);
	TreeNode* root = NULL;
	for(int i = 0; i < vec.size(); i++){
		TreeNode* node = NULL; 
		if(vec[i] != -1) node = new TreeNode(vec[i]);
		vecTree[i] = node; 
		if(i == 0) root = node;
	}
	for(int i = 0; i * 2 < vec.size(); i++){
		if(vecTree[i] != NULL){
			vecTree[i]->left = vecTree[i * 2 + 1];
			if(i * 2 + 2 < vec.size())
			vecTree[i]->right = vecTree[i * 2 + 2];
		}
	}	
	return root;
}

class Solution {
public:
    // 层序打印打印二叉树
    void print_binary_tree(TreeNode* root) {
        queue<TreeNode*> que;
        if (root != NULL) que.push(root);
        vector<vector<int>> result;
        while (!que.empty()) {
            int size = que.size();
            vector<int> vec;
            for (int i = 0; i < size; i++) {
                TreeNode* node = que.front();
                que.pop();
                if (node != NULL) {
                    vec.push_back(node->val);
                    que.push(node->left);
                    que.push(node->right);
                }
                // 这里的处理逻辑是为了把null节点打印出来，用-1 表示null
                else vec.push_back(-1);
            }
            result.push_back(vec);
        }
        for (int i = 0; i < result.size(); i++) {
            for (int j = 0; j < result[i].size(); j++) {
                cout << result[i][j] << " ";
            }
            cout << endl;
        }
    }
};

int main(){
	vector<int> vec = {2,7,9,-1,1,9,6,-1,-1,10};
    TreeNode* root = construct_binary_tree(vec);
    Solution solution;
	solution.print_binary_tree(root);
	return 0;
} 
```

## 二叉树的遍历问题

### 二叉树的前中后遍历

#### 相关链接

+ [二叉树的前序遍历](https://leetcode.cn/problems/binary-tree-preorder-traversal/)
+ [二叉树的中序遍历 ](https://leetcode.cn/problems/binary-tree-inorder-traversal/description/)
+ [二叉树的后序遍历](https://leetcode.cn/problems/binary-tree-postorder-traversal/description/)
+ [589. N 叉树的前序遍历 ](https://leetcode.cn/problems/n-ary-tree-preorder-traversal/description/)
+ [590. N 叉树的后序遍历 ](https://leetcode.cn/problems/n-ary-tree-postorder-traversal/description/)

#### 相关题目

以前序遍历为例

给你二叉树的根节点 `root` ，返回它节点值的 **前序** 遍历。

**示例 1：**

<img src="https://assets.leetcode.com/uploads/2020/09/15/inorder_1.jpg" alt="示例1" style="zoom:40%;box-shadow:rgba(0,0,0,0) 0 0px 0px 0px;" />

```
输入：root = [1,null,2,3]
输出：[1,2,3]
```

**示例 2：**

```
输入：root = []
输出：[]
```

**示例 3：**

```
输入：root = [1]
输出：[1]
```

**示例 4：**

<img src="https://assets.leetcode.com/uploads/2020/09/15/inorder_5.jpg" alt="示例2" style="zoom:40%;box-shadow:rgba(0,0,0,0) 0 0px 0px 0px;" />

```
输入：root = [1,2]
输出：[1,2]
```

#### 解题思路

**写法1-前中后序递归法**

以前序遍历为例，递归形式，遍历二叉树首先需要确定递归算法三个要素

+ 首先确定递归的参数和返回条件：需要传入树节点进行遍历，以及通过vector数组存储遍历的结果，不需要返回值

  ```c
  void traversal(TreeNode* root, vector<int> &res)
  ```

+ 其次递归的终止条件：当根结点为空时，结束此次递归

  ```c
  if(root == NULL) return;
  ```

+ 最后单层递归的逻辑：前序遍历的逻辑，先根结点，再左子树，最后右子树

  ```cpp
  res.push_back(root->val);
  traversal(root->left, res);
  traversal(root->right, res);
  ```

前序遍历完整的代码示例如下：

```cpp
class Solution {
public:
    void traversal(TreeNode* root, vector<int> &res){
        if(root == NULL) return;
        res.push_back(root->val);
        traversal(root->left, res);
        traversal(root->right, res);
    }
    vector<int> preorderTraversal(TreeNode* root) {
        vector<int> res;
        traversal(root, res);
        return res;
    }
};



```

**写法2-前中后序迭代法**

**前序遍历**：前序遍历是中左右，每次先处理的是中间节点，那么先将根节点放入栈中，然后将**右孩子**加入栈，再加入**左孩子**。（**注意代码中空节点不入栈**）

```cpp
class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {
        stack<TreeNode*> st;
        vector<int> res;
        if(root == NULL) return res;
        st.push(root);
        while(!st.empty()){
            auto node = st.top();
            st.pop();
            res.push_back(node->val);
            if(node->right) st.push(node->right);
            if(node->left) st.push(node->left);
        }
        return res;
    }
};



```

**中序遍历**：前序遍历的代码不能和中序遍历通用，因为前序遍历的顺序是中左右，先访问的元素是中间节点，要处理的元素也是中间节点，所以刚刚才能写出相对简洁的代码，因为要访问的元素和要处理的元素顺序是一致的，都是中间节点。

而中序遍历是左中右，先访问的是二叉树顶部的节点，然后一层一层向下访问，直到到达树左面的最底部，再开始处理节点（也就是在把节点的数值放进result数组中），这就造成了**处理顺序和访问顺序是不一致的。**那么就需要从树最左边的点开始。

```cpp
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> res;
        stack<TreeNode*> st;
        if(root == NULL) return res;
        TreeNode* cur = root;
        while(cur != NULL || !st.empty()){
            if(cur != NULL){
                st.push(cur);
                cur = cur->left;
            }else{
                cur = st.top();
                st.pop();
                res.push_back(cur->val);
                cur = cur->right;
            }
        }
        return res;
    }
};


```

**后序遍历**：再来看后序遍历，先序遍历是中左右，后续遍历是左右中，那么我们只需要调整一下先序遍历的代码顺序，就变成中右左的遍历顺序，然后再反转result数组，输出的结果顺序就是左右中了，如下图：

<img src="/images/%E7%AE%97%E6%B3%95-%E6%A0%91%E4%B8%93%E9%A2%98/image-20230414184305776.png" alt="" style="zoom:5=70%;box-shadow:rgba(0,0,0,0) 0 0px 0px 0px;" />

所以后序遍历只需要前序遍历的代码稍作修改就可以了，代码如下：

```cpp
class Solution {
public:
    vector<int> postorderTraversal(TreeNode* root) {
        stack<TreeNode*> st;
        vector<int> res;
        if(root == NULL) return res;
        st.push(root);
        while(!st.empty()){
            auto node = st.top();
            st.pop();
            res.push_back(node->val);
            if(node->left) st.push(node->left);
            if(node->right) st.push(node->right);
        }
        reverse(res.begin(), res.end());
        return res;
    }
};
```

**写法3-前中后序迭代方式统一写法**

这种形式的代码易于背诵，但不易理解。

我们将访问的节点直接加入到栈中，但如果是需要处理的节点则后面放入一个空节点， 只有空节点弹出的时候，才将下一个节点放进结果集。

**前序遍历：**

```cpp
class Solution {
public:
    vector<int> preorderTraversal(TreeNode* root) {
        stack<TreeNode*> st;
        vector<int> res;
        if(root == NULL) return res;
        st.push(root);
        while(!st.empty()){
            auto node = st.top();
            st.pop();
            if(node){
                if(node->right) st.push(node->right);
                if(node->left) st.push(node->left);
                st.push(node);
                st.push(NULL);
            }
            else{
                node = st.top();
                st.pop();
                res.push_back(node->val);
            }
        }
        return res;
    }
};
```

**中序遍历：**

```cpp
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        stack<TreeNode*> st;
        vector<int> res;
        if(root == NULL) return res;
        st.push(root);
        while(!st.empty()){
            auto node = st.top();
            st.pop();
            if(node){
                if(node->right) st.push(node->right);
                st.push(node);
                st.push(NULL);
                if(node->left) st.push(node->left);
            }
            else{
                node = st.top();
                st.pop();
                res.push_back(node->val);
            }
        }
        return res;
    }
};
```

**后序遍历：**

```cpp
class Solution {
public:
    vector<int> postorderTraversal(TreeNode* root) {
        stack<TreeNode*> st;
        vector<int> res;
        if(root == NULL) return res;
        st.push(root);
        while(!st.empty()){
            auto node = st.top();
            st.pop();
            if(node){
                st.push(node);
                st.push(NULL);
                if(node->right) st.push(node->right);
                if(node->left) st.push(node->left);
            }
            else{
                node = st.top();
                st.pop();
                res.push_back(node->val);
            }
        }
        return res;
    }
};
```

### 二叉树的层次遍历

#### 相关链接

下面题目全部可以用层次遍历模板解决，可以看出层次遍历是多么重要！

+ [102. 二叉树的层序遍历](https://leetcode.cn/problems/binary-tree-level-order-traversal/description/)
+ [104. 二叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-binary-tree/description/)
+ [107. 二叉树的层序遍历 II ](https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/description/)
+ [111. 二叉树的最小深度](https://leetcode.cn/problems/minimum-depth-of-binary-tree/description/)
+ [116. 填充每个节点的下一个右侧节点指针](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/description/)
+ [117. 填充每个节点的下一个右侧节点指针 II ](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/submissions/384507687/)
+ [199. 二叉树的右视图](https://leetcode.cn/problems/binary-tree-right-side-view/description/)
+ [222. 完全二叉树的节点个数](https://leetcode.cn/problems/count-complete-tree-nodes/description/)
+ [226. 翻转二叉树](https://leetcode.cn/problems/invert-binary-tree/submissions/374169926/)
+ [429. N 叉树的层序遍历](https://leetcode.cn/problems/n-ary-tree-level-order-traversal/description/)
+ [515. 在每个树行中找最大值 ](https://leetcode.cn/problems/find-largest-value-in-each-tree-row/description/)
+ [559. N 叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-n-ary-tree/description/)
+ [637. 二叉树的层平均值 ](https://leetcode.cn/problems/average-of-levels-in-binary-tree/)
+ [按之字形顺序打印二叉树–牛客题霸](https://www.nowcoder.com/practice/91b69814117f4e8097390d107d2efbe0?tpId=295&tqId=23454&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26tab%3D%E7%AE%97%E6%B3%95%E7%AF%87%26topicId%3D295%26fromPut%3Dpc_kol_aaaxiu)

#### 相关题目

给你二叉树的根节点 `root` ，返回其节点值的 **层序遍历** 。 （即逐层地，从左到右访问所有节点）。

**示例 1：**

<img src="https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg" alt="示例1" style="zoom:50%;box-shadow:rgba(0,0,0,0) 0 0px 0px 0px;" />

```
输入：root = [3,9,20,null,null,15,7]
输出：[[3],[9,20],[15,7]]
```

**示例 2：**

```
输入：root = [1]
输出：[[1]]
```

#### 解题思路

队列进行层次遍历的模板，相关题目具体问题具体分析

```cpp
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        vector<vector<int>> res;
        queue<TreeNode*> q;
        if(root) q.push(root);
        while(!q.empty()){
            int size = q.size();
            vector<int> tmp;
            // 这里一定要使用固定大小size，不要使用q.size()，因为q.size是不断变化的
            for(int i = 0; i < size; i++){
                auto node = q.front();
                q.pop();
                tmp.push_back(node->val);
                if(node->left) q.push(node->left);
                if(node->right) q.push(node->right);
            }
            res.push_back(tmp);
        }
        return res;
    }
};
```

### 二叉树的所有路径

#### 相关链接

+ [二叉树的所有路径 ](https://leetcode.cn/problems/binary-tree-paths/description/)

#### 相关题目

给你一个二叉树的根节点 `root` ，按 **任意顺序** ，返回所有从根节点到叶子节点的路径。

**叶子节点** 是指没有子节点的节点。

**示例 1：**

<img src="https://assets.leetcode.com/uploads/2021/03/12/paths-tree.jpg" alt="示例1" style="zoom:50%;box-shadow:rgba(0,0,0,0) 0 0px 0px 0px;" />

```
输入：root = [1,2,3,null,5]
输出：["1->2->5","1->3"]
```

#### 解题思路

**写法1-普通递归**

1. 递归函数函数参数以及返回值

要传入根节点，记录每一条路径的path，和存放结果集的result，这里递归不需要返回值，代码如下：

```cpp
void traversal(TreeNode* cur, vector<int>& path, vector<string>& result)
```

2. 确定递归终止条件

在写递归的时候都习惯了这么写：

```cpp
if (cur == NULL) {
    //终止处理逻辑
}
```

但是本题的终止条件这样写会很麻烦，因为本题要找到叶子节点，就开始结束的处理逻辑了（把路径放进result里）。**那么什么时候算是找到了叶子节点？** 是当 cur不为空，其左右孩子都为空的时候，就找到叶子节点。所以本题的终止条件是：

```cpp
if (cur->left == NULL && cur->right == NULL) {
    //终止处理逻辑
}
```

为什么没有判断cur是否为空呢，因为下面的逻辑可以控制空节点不入循环。

再看一下终止处理的逻辑。使用vector 结构path来记录路径，所以要把vector 结构的path转为string格式，在把这个string 放进 result里。**那么为什么使用了vector 结构来记录路径呢？** 因为在下面处理单层递归逻辑的时候，要做回溯，使用vector方便来做回溯。**一些代码看似没有回溯的，只不过隐藏在函数调用时的参数赋值里**。

这里先使用vector结构的path容器来记录路径，那么终止处理逻辑如下：

```cpp
if (cur->left == NULL && cur->right == NULL) { // 遇到叶子节点
    string sPath;
    for (int i = 0; i < path.size() - 1; i++) { 
        sPath += to_string(path[i]);
        sPath += "->";
    }
    sPath += to_string(path[path.size() - 1]); // 记录最后一个节点（叶子节点）
    result.push_back(sPath); // 
    return;
}
```

3. 确定单层递归逻辑

因为是前序遍历，需要先处理中间节点，中间节点就是我们要记录路径上的节点，先放进path中。

```cpp
path.push_back(cur->val);
```

然后是递归和回溯的过程，上面说过没有判断cur是否为空，那么在这里递归的时候，如果为空就不进行下一层递归了。

所以递归前要加上判断语句下面要递归的节点是否为空已经回溯：

```cpp
if (cur->left) {
    traversal(cur->left, path, result);
    path.pop_back(); // 回溯
}
if (cur->right) {
    traversal(cur->right, path, result);
    path.pop_back(); // 回溯
}
```

那么本题整体代码如下：

```cpp
class Solution {
private:
    void traversal(TreeNode* cur, vector<int>& path, vector<string>& result) {
        path.push_back(cur->val); // 中，中为什么写在这里，因为最后一个节点也要加入到path中 
        // 叶子节点
        if (cur->left == NULL && cur->right == NULL) {
            string sPath;
            for (int i = 0; i < path.size() - 1; i++) {
                sPath += to_string(path[i]);
                sPath += "->";
            }
            sPath += to_string(path[path.size() - 1]);
            result.push_back(sPath);
            return;
        }
        if (cur->left) { // 左 
            traversal(cur->left, path, result);
            path.pop_back(); // 回溯
        }
        if (cur->right) { // 右
            traversal(cur->right, path, result);
            path.pop_back(); // 回溯
        }
    }

public:
    vector<string> binaryTreePaths(TreeNode* root) {
        vector<string> result;
        vector<int> path;
        if (root == NULL) return result;
        traversal(root, path, result);
        return result;
    }
};
```

**写法2-精简递归**

```cpp
class Solution {
public:
    void traversal(TreeNode* root, string path, vector<string> &res){
        path += to_string(root->val);
        if(!root->left && !root->right){
            res.push_back(path);
            return;
        }
        if(root->left) traversal(root->left, path + "->", res);
        if(root->right) traversal(root->right, path + "->", res);
    }
    vector<string> binaryTreePaths(TreeNode* root) {
        vector<string> res;
        if(!root) return res;
        string path;
        traversal(root, path, res);
        return res;
    }
};
```

需要注意的是回溯条件隐藏在`traversal(root->left, path + "->", res);`中， 每次函数调用完，path依然是没有加上"->" 的，这就是回溯了。

## 二叉树的属性问题

### 左叶子之和

#### 相关链接

+ [404. 左叶子之和 ](https://leetcode.cn/problems/sum-of-left-leaves/description/)

#### 相关题目

给定二叉树的根节点 `root` ，返回所有左叶子之和。

**示例 1：**

<img src="https://assets.leetcode.com/uploads/2021/04/08/leftsum-tree.jpg" alt="示例1" style="zoom:50%;box-shadow:rgba(0,0,0,0) 0 0px 0px 0px;" />

```
输入: root = [3,9,20,null,null,15,7] 
输出: 24 
解释: 在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24
```

#### 解题思路

**首先要注意是判断左叶子，不是二叉树左侧节点，所以不要上来想着层序遍历。**

左叶子的明确定义：**节点A的左孩子不为空，且左孩子的左右孩子都为空（说明是叶子节点），那么A节点的左孩子为左叶子节点**

**写法1-递归法**

递归的遍历顺序为**后序遍历（左右中）**，是因为要通过递归函数的返回值来累加求取左叶子数值之和。

```cpp
class Solution {
public:
    int sumOfLeftLeaves(TreeNode* root) {
        if(!root) return 0;
        //其实这个也可以不写，如果不写不影响结果，但就会让递归多进行了一层。
        if(!root->left && !root->right) return 0;

        int l = sumOfLeftLeaves(root->left);//左
        if(root->left && !root->left->left && !root->left->right) l = root->left->val;
        int r = sumOfLeftLeaves(root->right);//右
        int sum = l + r;//中
        return sum;
    }
};
```

自己写的比较好理解和记忆

```cpp
class Solution {
public:
    int sumOfLeftLeaves(TreeNode* root) {
        if(!root) return 0;
        int sum = 0;
        if(root->left && !root->left->left && !root->left->right) sum += root->left->val;
        sum += sumOfLeftLeaves(root->left) + sumOfLeftLeaves(root->right);
        return sum;
    }
};
```

**写法2-迭代法**

**前序遍历**

```cpp
class Solution {
public:
    int sumOfLeftLeaves(TreeNode* root) {
        if(!root) return 0;
        stack<TreeNode*> st;
        st.push(root);
        int res = 0;
        while(!st.empty()){
            auto node = st.top();
            st.pop();
            if(node->left && !node->left->left && !node->left->right) res += node->left->val;
            if(node->right) st.push(node->right);
            if(node->left) st.push(node->left);
        }
        return res;
    }
};
```

### 二叉树的最大深度

#### 相关链接

+ [二叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)

#### 相关题目

给定一个二叉树，找出其最大深度。

二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。

**说明:** 叶子节点是指没有子节点的节点。

**示例:** 给定二叉树 `[3,9,20,null,null,15,7]`，返回它的最大深度 3 。

```txt
    3
   / \
  9  20
    /  \
   15   7
```

#### 解题思路

**写法1-普通递归**

+ 递归的参数：根结点与递归的层数
+ 返回条件是：当前为叶子节点 或是 返回左右子树的深度最大值
+ 进行递归的条件是：左右子树不为空，取左右子树的最大值

```cpp
class Solution {
public:
    int dfs(TreeNode* root, int cnt){
        if(root->left == NULL && root->right == NULL) return cnt;
        int l = 0, r = 0;
        if(root->left)  l = dfs(root->left, cnt + 1);
        if(root->right) r = dfs(root->right, cnt + 1);
        return max(l, r);
    }
    int maxDepth(TreeNode* root) {
        if(!root) return 0;
        return dfs(root, 1);
    }
};
```

**写法2-精简递归**

但是写法1太过冗余，可以继续进行精简

+ 递归的参数：根结点与递归的层数，需要注意：
  + 如果初始传入递归层数参数为1，当递归到空节点时应该为返回上一层的层数，结束条件应该为return cnt - 1;
  + 如果初始递归层数参数为0，当递归到空节点时正好为返回当层的层数，结束条件应该为return cnt；
+ 返回条件是：当前节点为空节点 或是 返回左右子树的深度最大值
+ 递归的条件可以进行取消，因为节点为空节点才进行返回

```cpp
class Solution {
public:
    int dfs(TreeNode* root, int cnt){
        if(!root) return cnt;
        return max(dfs(root->left, cnt + 1),dfs(root->right, cnt + 1));
    }
    int maxDepth(TreeNode* root) {
        if(!root) return 0;
        return dfs(root, 0);
    }
};
```

**写法3-极简递归**

写法2仍然多定义了dfs函数，显得冗余，可以不定义dfs函数，将cnt层数这个参数提取出来，直接在maxDepth进行递归。

```cpp
class Solution {
public:
    int maxDepth(TreeNode* root) {
        if(!root) return 0;
        return max(maxDepth(root->left), maxDepth(root->right)) + 1;
    }
};
```

**写法4-层次遍历模板法**

直接使用上文二叉排序树层次遍历的模板

```cpp
class Solution {
public:
    int maxDepth(TreeNode* root) {
        if (root == NULL) return 0;
        int depth = 0;
        queue<TreeNode*> que;
        que.push(root);
        while(!que.empty()) {
            int size = que.size();
            depth++; // 记录深度
            for (int i = 0; i < size; i++) {
                TreeNode* node = que.front();
                que.pop();
                if (node->left) que.push(node->left);
                if (node->right) que.push(node->right);
            }
        }
        return depth;
    }
};
```

### 二叉树的直径

#### 相关链接

+ [543. 二叉树的直径](https://leetcode.cn/problems/diameter-of-binary-tree/description/?favorite=2cktkvj)

#### 相关题目

给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。

**示例 :**
给定二叉树

```
          1
         / \
        2   3
       / \     
      4   5    
```

返回 **3**, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。

#### 解题思路

```cpp
class Solution {
private:
    int Max = 0;
    int dfs(TreeNode* root) {
        if(!root) return 0;
        int l = dfs(root->left);
        int r = dfs(root->right);
        if(Max < (l + r)) Max = l + r;
        return max(l, r) + 1;
    }
public:
    int diameterOfBinaryTree(TreeNode* root) {
        dfs(root);
        return Max;
    }
};
```

### 二叉树中的最大路径和

#### 相关链接

+ [124. 二叉树中的最大路径和](https://leetcode.cn/problems/binary-tree-maximum-path-sum/description/?favorite=2cktkvj)

#### 相关题目

二叉树中的 **路径** 被定义为一条节点序列，序列中每对相邻节点之间都存在一条边。同一个节点在一条路径序列中 **至多出现一次** 。该路径 **至少包含一个** 节点，且不一定经过根节点。

**路径和** 是路径中各节点值的总和。

给你一个二叉树的根节点 `root` ，返回其 **最大路径和** 。

**示例 1：**

<img src="https://assets.leetcode.com/uploads/2020/10/13/exx1.jpg" alt="示例1" style="zoom: 80%;box-shadow:rgba(0,0,0,0) 0 0px 0px 0px;">

```
输入：root = [1,2,3]
输出：6
解释：最优路径是 2 -> 1 -> 3 ，路径和为 2 + 1 + 3 = 6
```

#### 解题思路

```cpp
class Solution {
private:
    int dfs(TreeNode* root, int& res) {
        if(!root) return 0;
        int l = max(dfs(root->left, res), 0);
        int r = max(dfs(root->right, res), 0);
        res = max(res, root->val + l + r);
        return root->val + max(l, r); 
    }
public:
    int maxPathSum(TreeNode* root) {
        int res = INT_MIN;
        dfs(root, res);
        return res;
    }
};
```



### 二叉树每层的最大值

#### 相关链接

+ [二叉树每层的最大值](https://leetcode.cn/problems/hPov7L/)

#### 相关题目

给定一棵二叉树的根节点 `root` ，请找出该二叉树中每一层的最大值。

**示例1：**

```
输入: root = [1,3,2,5,3,null,9]
输出: [1,3,9]
解释:
          1
         / \
        3   2
       / \   \  
      5   3   9 
```

#### 解题思路

**写法1-递归法**

深度优先遍历，思路与求二叉树最大值一样，但是多传递一个h参数表示当前的高度，通过当时h来找到此时这层高度存储的最大值，进行比较。需要注意的是，当第一次结果数组等于树的高度时候，要在结果数组内放入当前元素，以后才能通过下标访问！

```cpp
class Solution {
public:
    void dfs(vector<int> & res, TreeNode* root, int h){
        if(res.size() == h) res.push_back(root->val);
        res[h] = max(res[h], root->val);
        if(root->left) dfs(res, root->left, h + 1);
        if(root->right)  dfs(res, root->right, h + 1);
    }
    vector<int> largestValues(TreeNode* root) {
        if(!root) return {};
        vector<int> res;
        dfs(res, root, h);
        return res;
    }
};
```

**写法2-层次遍历模板法**

广度优先遍历，与深度优先遍历一个一个比较不同的是，广度优先遍历是通过一层一层的比较的

```cpp
class Solution {
public:
    vector<int> largestValues(TreeNode* root) {
        queue<TreeNode*> q;
        vector<int> res;
        if(root) q.push(root);
        while(!q.empty()){
            int size = q.size();
            int MAX = INT_MIN;
            for(int i = 0; i < size; i++){
                auto node = q.front();
                q.pop();
                MAX = max(MAX, node->val);
                if(node->left) q.push(node->left);
                if(node->right) q.push(node->right);
            }
            res.push_back(MAX);
        }
        return res;
    }
};
```

### 二叉树最底层最左边的值

#### 相关链接

+ [二叉树最底层最左边的值](https://leetcode.cn/problems/LwUNpT/)
+ [513. 找树左下角的值](https://leetcode.cn/problems/find-bottom-left-tree-value/)

#### 相关题目

给定一个二叉树的 **根节点** `root`，请找出该二叉树的 **最底层 最左边** 节点的值。

假设二叉树中至少有一个节点。

**示例 1：**

<img src="https://assets.leetcode.com/uploads/2020/12/14/tree1.jpg" alt="示例1" style="zoom:50%;box-shadow:rgba(0,0,0,0) 0 0px 0px 0px;" />

```
输入: root = [2,1,3]
输出: 1
```

**示例 2:**

<img src="https://assets.leetcode.com/uploads/2020/12/14/tree2.jpg" alt="示例1" style="zoom: 33%; box-shadow: rgba(0, 0, 0, 0) 0px 0px 0px 0px;" />

```
输入: [1,2,3,4,null,5,6,null,null,7]
输出: 7
```

#### 解答思路

**写法1-递归法** 

深度优先遍历：当最大高度超过当前高度后才开始更新 最底层 最左边 的值

```cpp
class Solution {
private:
    int res = 0, maxh = 0;
    void dfs(TreeNode* root, int h) {
        if(!root) return;
        h++;
        dfs(root->left, h);
        dfs(root->right, h);
        if(h > maxh) {
            maxh = h;
            res = root->val;
        }
    }
public:
    int findBottomLeftValue(TreeNode* root) {
        dfs(root, 0);
        return res;
    }
};
```

**需要注意的是**

`h++` 应该写在遍历左右子树之前，不应该在`dfs(root->left, ++h);dfs(root->right, ++h);`，后者会在遍历左子树后再加左子树的高度上加1，导致错误。

**写法2-广搜法**

在遍历一个节点时，需要先把它的非空右子节点放入队列，然后再把它的非空左子节点放入队列，这样才能保证从右到左遍历每一层的节点。广度优先搜索所遍历的最后一个节点的值就是最底层最左边节点的值。

```cpp
class Solution {
public:
    int findBottomLeftValue(TreeNode* root) {
        queue<TreeNode*> q;
        q.push(root);
        int val;
        while(!q.empty()){
            TreeNode* t = q.front();
            q.pop();
            val = t->val;
            if(t->right) q.push(t->right);
            if(t->left) q.push(t->left);
        }
        return val; 
    }
};
```

**易错点**

二叉树的 **最底层 最左边** 节点的值不一定就是**最左边**的点，如下图示例2所示，最左边的点为4，最底层最左边点为 7，两者并不相同，并且求最左边的点可以重新出题为**返回中序遍历的第一个点**。

<img src="/images/%E6%A0%91-%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/image-20221101101037177.png" alt="示例2" style="zoom:55%;box-shadow:rgba(0,0,0,0) 0 0px 0px 0px;" />

求最左边的点代码如下，可以出题为**返回中序遍历的第一个点**

```cpp
class Solution {
public:
    int findLeftValue(TreeNode* root) {
        auto t = root;
        while(t->left || t->right){
            while(t->left) t = t->left;
        }
        return t->val;
    }
};
```

如果是**返回后序遍历的第一个点，**求法如下：

```cpp
class Solution {
public:
    int findPostValue(TreeNode* root) {
        auto t = root;
        while(t->left || t->right){
            while(t->left) t = t->left;
            if(t->right) t = t->right;
        }
        return t->val;
    }
};
```

### 填充每个节点的下一个右侧节点指针

#### 相关链接

+ [116. 填充每个节点的下一个右侧节点指针](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/description/)

#### 相关题目

给定一个 **完美二叉树** ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：

```
struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}
```

填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 `NULL`。

初始状态下，所有 next 指针都被设置为 `NULL`。

**示例 1：**

<img src="https://assets.leetcode.com/uploads/2019/02/14/116_sample.png" alt="示例1" style="zoom: 50%;box-shadow:rgba(0,0,0,0) 0 0px 0px 0px;" />

```
输入：root = [1,2,3,4,5,6,7]
输出：[1,#,2,3,#,4,5,6,7,#]
解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。序列化的输出按层序遍历排列，同一层节点由 next 指针连接，'#' 标志着每一层的结束。
```

#### 解题思路

**层次遍历-易理解版本**

```cpp
class Solution {
public:
    Node* connect(Node* root) {
        queue<Node*> q;
        if(root) q.push(root);
        while(!q.empty()){
            int size = q.size();
            Node* node;
            Node* nodePre;
            for(int i = 0; i < size; i++){
                nodePre = q.front();
                q.pop();
                if(i == 0){
                    nodePre = q.front();
                    q.pop();
                    node = nodePre;
                }else{
                    node = q.front();
                    q.pop();
                    nodePre->next = node;
                    nodePre = nodePre->next;
                }
                if(node->left) q.push(node->left);
                if(node->right) q.push(node->right);
            }
            nodePre->next = NULL;
        } 
        return root;
    }
};
```

**层次遍历-简易版本**

```cpp
class Solution {
public:
    Node* connect(Node* root) {
        queue<Node*> q;
        if(root) q.push(root);
        while(!q.empty()){
            int size = q.size();
            for(int i = 0; i < size; i++){
                Node* node = q.front();
                q.pop();
                if(i < size - 1) node->next = q.front();
                if(node->left) q.push(node->left);
                if(node->right) q.push(node->right);
            }
        } 
        return root;
    }
};
```

**递归版本**

<img src="/images/%E7%AE%97%E6%B3%95-%E6%A0%91%E4%B8%93%E9%A2%98/image-20221223104515488.png" alt="递归版本" style="zoom: 67%;box-shadow:rgba(0,0,0,0) 0 0px 0px 0px;" />

```cpp
class Solution {
private:
    void traversal(Node* cur) {
        if (cur == NULL) return;
                                // 中
        if (cur->left) cur->left->next = cur->right; // 操作1
        if (cur->right) {
            if (cur->next) cur->right->next = cur->next->left; // 操作2
            else cur->right->next = NULL;
        }
        traversal(cur->left);   // 左
        traversal(cur->right);  // 右
    }
public:
    Node* connect(Node* root) {
        traversal(root);
        return root;
    }
};
```

### 二叉树展开为链表

#### 相关链接

+ [114. 二叉树展开为链表 ](https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/description/)

#### 相关题目

给你二叉树的根结点 `root` ，请你将它展开为一个单链表：

+ 展开后的单链表应该同样使用 `TreeNode` ，其中 `right` 子指针指向链表中下一个结点，而左子指针始终为 `null` 。
+ 展开后的单链表应该与二叉树 先序遍历 顺序相同。

**示例 1：**

<img src="/images/%E7%AE%97%E6%B3%95-%E6%A0%91%E4%B8%93%E9%A2%98/image-20230408195230889.png" alt="示例1" style="zoom: 50%;box-shadow:rgba(0,0,0,0) 0 0px 0px 0px;" />



```
输入：root = [1,2,5,3,4,null,6]
输出：[1,null,2,null,3,null,4,null,5,null,6]
```

#### 解题思路

```cpp
class Solution {
public:
    TreeNode* pre = NULL;
    void flatten(TreeNode* root) {
        if(!root) return;
        if(pre == NULL) pre = root;
        else {
            pre->left = NULL;
            pre->right = root; 
            pre = root;
        }
        auto tmp = root->right;
        flatten(root->left);
        flatten(tmp);
    }
};
```

## 补充：二叉树如何确定递归返回值

### 路径之和

#### 相关链接

+ [112. 路径总和](https://leetcode.cn/problems/path-sum/)
+ [113. 路径总和 II ](https://leetcode.cn/problems/path-sum-ii/description/)

#### 相关题目

给你二叉树的根节点 `root` 和一个表示目标和的整数 `targetSum` 。判断该树中是否存在 **根节点到叶子节点** 的路径，这条路径上所有节点值相加等于目标和 `targetSum` 。如果存在，返回 `true` ；否则，返回 `false` 。

**叶子节点** 是指没有子节点的节点。

**示例 1：**

<img src="https://assets.leetcode.com/uploads/2021/01/18/pathsum1.jpg" alt="示例1" style="zoom:50%;box-shadow:rgba(0,0,0,0) 0 0px 0px 0px;" />

```
输入：root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22
输出：true
解释：等于目标和的根节点到叶节点路径如上图所示。
```

#### 解题思路

递归函数什么时候需要返回值？什么时候不需要返回值？这里总结如下三点：

+ 如果需要搜索整棵二叉树且不用处理递归返回值，递归函数就不要返回值。（这种情况在[113. 路径总和 II ](https://leetcode.cn/problems/path-sum-ii/description/)介绍）

+ 如果需要搜索整棵二叉树且需要处理递归返回值，递归函数就需要返回值。 （这种情况在[236. 二叉树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/)中介绍）

+ 如果要搜索其中一条符合条件的路径，那么递归一定需要返回值，因为遇到符合条件的路径了就要及时返回。（本题的情况）

  搜索一条路径的写法：

  ```cpp
  if (递归函数(root->left)) return ;
  if (递归函数(root->right)) return ;
  ```
  

搜索整个树写法：

```cpp
left = 递归函数(root->left);  
right = 递归函数(root->right); 
```

**写法1-普通递归**

1. 确定递归函数的参数和返回类型

   要搜索其中一条符合条件的路径，那么递归一定需要返回值，因为遇到符合条件的路径了就要及时返回,所以本题需要返回值，传入的参数一定要注意要传入`root->val`,而不是0，否则将不会把根结点计算在内

   ```cpp
    bool dfs(TreeNode* root, int targetSum, int sum)
   ```

2. 确定终止条件
   ```cpp
   if(!root->left && !root->right){
       if(sum == targetSum) return true;
       return false;
   }
   ```

3. 确定单层递归的逻辑
    ```cpp
    if(root->left) if(dfs(root->left, targetSum, sum + root->left->val)) return true;
    if(root->right) if(dfs(root->right, targetSum, sum + root->right->val)) return true;
    ```

完整代码如下:

```cpp
class Solution {
public:
    bool dfs(TreeNode* root, int targetSum, int sum){
        if(!root->left && !root->right){
            if(sum == targetSum) return true;
            return false;
        }
        if(root->left) if(dfs(root->left, targetSum, sum + root->left->val)) return true;
        if(root->right) if(dfs(root->right, targetSum, sum + root->right->val)) return true;
        return false;
    }

    bool hasPathSum(TreeNode* root, int targetSum) {
        if(!root) return false;
        return dfs(root, targetSum, root->val);
    }
};
```

**写法2 - 极简递归**

```cpp
class Solution {
public:
    bool hasPathSum(TreeNode* root, int targetSum) {
        if(!root) return false;
        if(!root->left && !root->right && targetSum == root->val) return true;
        return hasPathSum(root->left, targetSum - root->val) || 
               hasPathSum(root->right, targetSum - root->val);
    } 
};
```

如果需要搜索整棵二叉树且不用处理递归返回值，递归函数就不要返回值。（这种情况就是[113. 路径总和 II ](https://leetcode.cn/problems/path-sum-ii/description/)）

代码如下：

```cpp
class Solution {
private:
    vector<vector<int>> result;
    vector<int> path;
    // 递归函数不需要返回值，因为我们要遍历整个树
    void traversal(TreeNode* root, int count) {
        if (!root->left && !root->right) { 
            if(count == 0) result.push_back(path);
            return;
        }
        if (root->left) {
            path.push_back(root->left->val);
            traversal(root->left, count - root->left->val);          
            path.pop_back();                
        }
        if (root->right) {
            path.push_back(root->right->val);
            traversal(root->right, count - root->right->val);       
            path.pop_back();                
        }
        return;
    }
public:
    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {
        if (!root) return result;
        path.push_back(root->val); 
        traversal(root, targetSum - root->val);
        return result;
    }
};
```

### 二叉树的最近公共祖先

#### 相关链接

+ [236. 二叉树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/)

#### 相关题目

给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。

百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（**一个节点也可以是它自己的祖先**）。”

**示例 1：**

<img src="https://assets.leetcode.com/uploads/2018/12/14/binarytree.png" alt="示例1" style="zoom: 80%;box-shadow:rgba(0,0,0,0) 0 0px 0px 0px;" />

```
输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
输出：3
解释：节点 5 和节点 1 的最近公共祖先是节点 3 。
```

#### 解题思路

**本题三个难点**

+ 为实现从低向上的遍历方式，需要想到二叉树可以通过后序遍历实现！
+ 在回溯的过程中，必然要遍历整棵二叉树，所以即使已经找到结果了，依然要把其他节点遍历完，因为要使用递归函数的返回值（也就是代码中的left和right）做逻辑判断。
+ 要理解如果返回值left为空，right不为空，为什么要返回right？为什么要返回right传给上一层结果？因为说明公共祖先不在左子树里面，在右子树里面，要一层一层的把右子树的公共节点返回。

**递归的步骤**

判断逻辑是 如果递归遍历遇到q，就将q返回，遇到p 就将p返回，那么如果 左右子树的返回值都不为空，说明此时的中节点，一定是q 和p 的最近祖先。

1. 确定递归函数返回值以及参数

   需要递归函数返回值，来告诉我们是否找到节点q或者p，那么返回值为bool类型就可以了。但我们还要返回最近公共节点，可以利用上题目中返回值是TreeNode * ，那么如果遇到p或者q，就把q或者p返回，返回值不为空，就说明找到了q或者p。

   ```cpp
   TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q)
   ```

2. 确定终止条件

   遇到 root == null 的话，需要返回root 也为空。

   如果 root == q，或者 root == p，说明找到 q ，p ，则将其返回，这个返回值，后面在节点的处理过程中会用到。

   ```cpp
   if (root == q || root == p || root == NULL) return root;
   ```

3. 确定单层递归逻辑

   ```cpp
   TreeNode* left = lowestCommonAncestor(root->left, p, q);
   TreeNode* right = lowestCommonAncestor(root->right, p, q);
   if (left != NULL && right != NULL) return root;
   if (left == NULL && right != NULL) return right;
   else if (left != NULL && right == NULL) return left;
   else return NULL; //  (left == NULL && right == NULL)
   ```

整体代码如下：

```cpp
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if (root == p || root == q || root == NULL) return root;
        TreeNode* left = lowestCommonAncestor(root->left, p, q);
        TreeNode* right = lowestCommonAncestor(root->right, p, q);
        
        if (left != NULL && right != NULL) return root;
        if (left == NULL && right != NULL) return right;
        else if (left != NULL && right == NULL) return left;
        else  { //  (left == NULL && right == NULL)
            return NULL;
        }
    }
};
```

**精简递归的-完整代码**

```cpp
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if (root == q || root == p || root == NULL) return root;
        TreeNode* left = lowestCommonAncestor(root->left, p, q);
        TreeNode* right = lowestCommonAncestor(root->right, p, q);
        if (left != NULL && right != NULL) return root;
        if (left == NULL) return right;
        return left;
    }
};
```

### 求根节点到叶节点数字之和

#### 相关链接

+ [129. 求根节点到叶节点数字之和](https://leetcode.cn/problems/sum-root-to-leaf-numbers/description/)

#### 相关题目

给你一个二叉树的根节点 `root` ，树中每个节点都存放有一个 `0` 到 `9` 之间的数字。

每条从根节点到叶节点的路径都代表一个数字：

+ 例如，从根节点到叶节点的路径 `1 -> 2 -> 3` 表示数字 `123` 。

计算从根节点到叶节点生成的 **所有数字之和** 。

**叶节点** 是指没有子节点的节点。

**示例 1：**

<img src="https://assets.leetcode.com/uploads/2021/02/19/num1tree.jpg" alt="示例1" style="zoom:67%;box-shadow:rgba(0,0,0,0) 0 0px 0px 0px;" />

```
输入：root = [1,2,3]
输出：25
解释：
从根到叶子节点路径 1->2 代表数字 12
从根到叶子节点路径 1->3 代表数字 13
因此，数字总和 = 12 + 13 = 25
```

#### 解题思路

1. 确定递归函数返回值以及参数

   这里我们要遍历整个二叉树，且不需要要返回值做逻辑处理，所以返回值为void，

   参数只需要把根节点传入，此时还需要定义两个全局遍历，一个是result，记录最终结果，一个是vector path。

   **为什么用vector类型）呢？ 因为用vector方便我们做回溯！**

   所以代码如下：

   ```cpp
   int result;
   vector<int> path;
   void traversal(TreeNode* cur) 
   ```

2. 确定终止条件

   递归什么时候终止呢？

   当然是遇到叶子节点，此时要收集结果了，通知返回本层递归，因为单条路径的结果使用vector，我们需要一个函数vectorToInt把vector转成int。终止条件代码如下：

   ```cpp
   if (!cur->left && !cur->right) { // 遇到了叶子节点
       result += vectorToInt(path);
       return;
   }
   ```

   这里vectorToInt函数就是把数组转成int，代码如下：

   ```cpp
   int vectorToInt(const vector<int>& vec) {
       int sum = 0;
       for (int i = 0; i < vec.size(); i++) {
           sum = sum * 10 + vec[i];
       }
       return sum;
   }
   ```

3. 确定递归单层逻辑

   本题其实采用前中后序都不无所谓， 因为也没有中间几点的处理逻辑。

   这里主要是当左节点不为空，path收集路径，并递归左孩子，右节点同理。**但别忘了回溯**

   代码如下：

   ```cpp
                    // 中
   if (cur->left) { // 左 （空节点不遍历）
       path.push_back(cur->left->val);
       traversal(cur->left);    // 递归
       path.pop_back();         // 回溯
   }
   if (cur->right) { // 右 （空节点不遍历）
       path.push_back(cur->right->val);
       traversal(cur->right);   // 递归
       path.pop_back();         // 回溯
   }
   ```

   这里要注意回溯和递归要永远在一起，一个递归，对应一个回溯，是一对一的关系

完整代码如下：

```cpp
class Solution {
private:
    int result;
    vector<int> path;
    int vectorToInt(vector<int> &vec){
        int sum = 0;
        for(int i = 0; i < vec.size(); i++){
            sum = sum * 10 + vec[i];
        }
        return sum;
    }
    void traversal(TreeNode* cur){
        if(!cur->left && !cur->right){
            result += vectorToInt(path);
            return;
        }
        if(cur->left){
            path.push_back(cur->left->val);
            traversal(cur->left);
            path.pop_back();
        }
        if(cur->right){
            path.push_back(cur->right->val);
            traversal(cur->right);
            path.pop_back();
        }
        return;
    }
public:
    int sumNumbers(TreeNode* root) {
        if(!root) return 0;
        path.push_back(root->val);
        traversal(root);
        return result;
    }
};
```

## 构造二叉树问题

### 前序与中序遍历构造二叉树

#### 相关链接

+ [105. 从前序与中序遍历序列构造二叉树 ](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

#### 相关题目

给定两个整数数组 `preorder` 和 `inorder` ，其中 `preorder` 是二叉树的**先序遍历**， `inorder` 是同一棵树的**中序遍历**，请构造二叉树并返回其根节点。

**示例 1:**

<img src="https://assets.leetcode.com/uploads/2021/02/19/tree.jpg" alt="示例1" style="zoom:50%;box-shadow:rgba(0,0,0,0) 0 0px 0px 0px;" />

```
输入: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]
输出: [3,9,20,null,null,15,7]
```

#### 解题思路

+ 第一步：如果数组大小为零的话，说明是空节点了。
+ 第二步：如果不为空，那么取前序数组第一个元素作为节点元素。
+ 第三步：找到前序数组第一个元素在中序数组的位置，作为切割点
+ 第四步：切割中序数组，切成中序左数组和中序右数组 （顺序别搞反了，一定是先切中序数组）
+ 第五步：切割前序数组，切成前序左数组和前序右数组
+ 第六步：递归处理左区间和右区间

坚持左闭右开的原则：

```cpp
class Solution {
public:
    TreeNode* traversal(vector<int>& preorder,int lp, int rp, vector<int>& inorder,int li,int ri){
        if(rp - lp == 0) return NULL;

        int rootValue = preorder[lp];
        TreeNode* root = new TreeNode(rootValue);
        if(rp - lp == 1) return root;
        
        int idx;
        for(idx = li; idx < ri; idx++)
            if(inorder[idx] == rootValue)
                break;

        root->left = traversal(preorder, lp + 1, lp + 1 + idx - li, inorder, li, idx);
        root->right = traversal(preorder, lp + 1 + idx - li, rp,inorder, idx + 1, ri);
        return root;
    }
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        if(preorder.size() == 0 || inorder.size() == 0) return NULL;
        return traversal(preorder, 0 ,preorder.size(), inorder, 0, inorder.size());
    }
};
```

### 中序与后序遍历构造二叉树

#### 相关链接

+ [106. 从中序与后序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)

#### 相关题目

给定两个整数数组 `inorder` 和 `postorder` ，其中 `inorder` 是二叉树的中序遍历， `postorder` 是同一棵树的后序遍历，请你构造并返回这颗 *二叉树* 。

**示例 1:**

<img src="https://assets.leetcode.com/uploads/2021/02/19/tree.jpg" alt="示例1" style="zoom:50%;box-shadow:rgba(0,0,0,0) 0 0px 0px 0px;" />

```
输入：inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]
输出：[3,9,20,null,null,15,7]
```

#### 解题思路

+ 第一步：如果数组大小为零的话，说明是空节点了。
+ 第二步：如果不为空，那么取后序数组最后一个元素作为节点元素。
+ 第三步：找到后序数组最后一个元素在中序数组的位置，作为切割点
+ 第四步：切割中序数组，切成中序左数组和中序右数组 （顺序别搞反了，一定是先切中序数组）
+ 第五步：切割后序数组，切成后序左数组和后序右数组
+ 第六步：递归处理左区间和右区间

坚持左闭右开的原则：

<img src="/images/%E6%A0%91-%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/image-20221127195529967.png" alt="切割示意图" style="zoom:80%;box-shadow:rgba(0,0,0,0) 0 0px 0px 0px;"/>



```cpp
class Solution {
public:
    TreeNode* traversal(vector<int>& inorder, int li, int ri, vector<int>& postorder, int lp, int rp){
        if(lp == rp) return NULL;

        int rootValue = postorder[rp - 1];
        TreeNode * root = new TreeNode(rootValue);
        if(rp - lp == 1) return root;//叶子节点直接返回

        int idx;
        for(idx = li; idx < ri; idx++)
            if(inorder[idx] == rootValue) break;
        
        root->left = traversal(inorder, li, idx, postorder, lp, lp + idx - li);
        root->right = traversal(inorder, idx + 1, ri, postorder, lp + idx - li, rp - 1);
        
        return root;
    }
    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {
        if(inorder.size() == 0 || postorder.size() == 0) return NULL;
        return traversal(inorder, 0, inorder.size(), postorder, 0, postorder.size());
    }
};
```

### 最大二叉树

#### 相关链接

+ [654. 最大二叉树 ](https://leetcode.cn/problems/maximum-binary-tree/)

#### 相关题目

给定一个不重复的整数数组 `nums` 。 **最大二叉树** 可以用下面的算法从 `nums` 递归地构建:

1. 创建一个根节点，其值为 `nums` 中的最大值。
2. 递归地在最大值 **左边** 的 **子数组前缀上** 构建左子树。
3. 递归地在最大值 **右边** 的 **子数组后缀上** 构建右子树。

返回 *`nums` 构建的* 最大二叉树 。

**示例 1：**

<img src="https://assets.leetcode.com/uploads/2020/12/24/tree1.jpg" alt="示例1" style="zoom:50%;box-shadow:rgba(0,0,0,0) 0 0px 0px 0px;" />

```
输入：nums = [3,2,1,6,0,5]
输出：[6,3,5,null,2,0,null,null,1]
解释：递归调用如下所示：
- [3,2,1,6,0,5] 中的最大值是 6 ，左边部分是 [3,2,1] ，右边部分是 [0,5] 。
    - [3,2,1] 中的最大值是 3 ，左边部分是 [] ，右边部分是 [2,1] 。
        - 空数组，无子节点。
        - [2,1] 中的最大值是 2 ，左边部分是 [] ，右边部分是 [1] 。
            - 空数组，无子节点。
            - 只有一个元素，所以子节点是一个值为 1 的节点。
    - [0,5] 中的最大值是 5 ，左边部分是 [0] ，右边部分是 [] 。
        - 只有一个元素，所以子节点是一个值为 0 的节点。
        - 空数组，无子节点。
```

#### 解题思路

```cpp
class Solution {
public:
    TreeNode* traversal(vector<int> &nums, int l, int r){
        if(l >= r) return NULL;
        
        int idx = 0, MAX = -1;
        for(int i = l; i < r; i++){
            if(MAX < nums[i]){
                idx = i;
                MAX = nums[i];
            }   
        }

        TreeNode* root = new TreeNode(MAX);
        root->left = traversal(nums, l, idx);
        root->right = traversal(nums, idx + 1, r);
        return root;
    }
    TreeNode* constructMaximumBinaryTree(vector<int>& nums) {
        return traversal(nums, 0, nums.size());
    }
};
```

### 合并二叉树

#### 相关链接

+ [617. 合并二叉树 ](https://leetcode.cn/problems/merge-two-binary-trees/description/)

#### 相关题目

给你两棵二叉树： `root1` 和 `root2` 。

想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，不为 null 的节点将直接作为新二叉树的节点。

返回合并后的二叉树。

**注意:** 合并过程必须从两个树的根节点开始。

**示例 1：**

<img src="https://assets.leetcode.com/uploads/2021/02/05/merge.jpg" alt="示例1" style="zoom:50%;box-shadow:rgba(0,0,0,0) 0 0px 0px 0px;" />

```
输入：root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7]
输出：[3,4,5,5,4,null,7]
```

#### 解题思路

```cpp
class Solution {
public:
    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {
        if(!root1) return root2;
        if(!root2) return root1;
        auto root = new TreeNode(root1->val + root2->val);
        root->left = mergeTrees(root1->left, root2->left);
        root->right = mergeTrees(root1->right, root2->right);
        return root;
    }
};
```

### 翻转二叉树

#### 相关链接

+ [226. 翻转二叉树](https://leetcode.cn/problems/invert-binary-tree/submissions/374169926/)

#### 相关题目

给你一棵二叉树的根节点 `root` ，翻转这棵二叉树，并返回其根节点。

**示例 1：**

<img src="https://assets.leetcode.com/uploads/2021/03/14/invert1-tree.jpg" alt="示例1" style="zoom:50%;box-shadow:rgba(0,0,0,0) 0 0px 0px 0px;" />

```
输入：root = [4,2,7,1,3,6,9]
输出：[4,7,2,9,6,3,1]
```

#### 解题思路

这道题目使用前序遍历和后序遍历都可以，唯独**中序遍历不方便，因为中序遍历会把某些节点的左右孩子翻转了两次**

那么层序遍历依然可以！只要把每一个节点的左右孩子翻转一下的遍历方式都是可以的

**前序遍历-递归形式**

```cpp
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        if(!root) return NULL;
        swap(root->left, root->right);  		// 节点处理逻辑
        invertTree(root->left);
        invertTree(root->right);
        return root;
    }
};
```

**前序遍历-迭代形式**

```cpp
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        if (root == NULL) return root;
        stack<TreeNode*> st;
        st.push(root);
        while(!st.empty()) {
            TreeNode* node = st.top();              // 中
            st.pop();
            swap(node->left, node->right); 			// 节点处理逻辑
            if(node->right) st.push(node->right);   // 右
            if(node->left) st.push(node->left);     // 左
        }
        return root;
    }
};
```

**前序遍历-统一迭代形式**

```cpp
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        stack<TreeNode*> st;
        if (root != NULL) st.push(root);
        while (!st.empty()) {
            TreeNode* node = st.top();
            if (node != NULL) {
                st.pop();
                if (node->right) st.push(node->right);  // 右
                if (node->left) st.push(node->left);    // 左
                st.push(node);                          // 中
                st.push(NULL);
            } else {
                st.pop();
                node = st.top();
                st.pop();
                swap(node->left, node->right);          // 节点处理逻辑
            }
        }
        return root;
    }
};
```

**层次遍历**

```cpp
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        queue<TreeNode*> que;
        if (root != NULL) que.push(root);
        while (!que.empty()) {
            int size = que.size();
            for (int i = 0; i < size; i++) {
                TreeNode* node = que.front();
                que.pop();
                swap(node->left, node->right); // 节点处理
                if (node->left) que.push(node->left);
                if (node->right) que.push(node->right);
            }
        }
        return root;
    }
};
```

**这里演示一下为什么中序遍历会遍历某些结点两次**

<img src="/images/%E6%A0%91-%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/image-20221125101529063.png" alt="中序遍历的顺序" style="zoom:50%;box-shadow:rgba(0,0,0,0) 0 0px 0px 0px;" />

以上图为例，中序遍历遍历左子树后会递归回溯到根结点（4），此时的右子树已经和原来的左子树交换，变为了(2-3-1)，如果此时再递归右子树，相当于重新交换了一遍原来的左子树，如果非要使用递归中序的方式写，也可以使用如下代码就可以避免节点左右孩子翻转两次的情况

**中序遍历-递归形式**

```cpp
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        if (root == NULL) return root;
        invertTree(root->left);         // 左
        swap(root->left, root->right);  // 中
        invertTree(root->left);         // 这里依然要遍历左孩子，因为中间节点已经翻转了
        return root;
    }
};
```

代码虽然可以，但这毕竟不是真正的递归中序遍历了。但使用迭代方式统一写法的中序是可以的。

**中序遍历-统一迭代形式**

```cpp
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        stack<TreeNode*> st;
        if (root != NULL) st.push(root);
        while (!st.empty()) {
            TreeNode* node = st.top();
            if (node != NULL) {
                st.pop();
                if (node->right) st.push(node->right);  // 右
                st.push(node);                          // 中
                st.push(NULL);
                if (node->left) st.push(node->left);    // 左

            } else {
                st.pop();
                node = st.top();
                st.pop();
                swap(node->left, node->right);          // 节点处理逻辑
            }
        }
        return root;
    }
};
```

为什么这个中序就是可以的呢，因为这是用栈来遍历，而不是靠指针来遍历，避免了递归法中翻转了两次的情况

### 二叉树的序列化与反序列化

#### 相关链接

+ [297. 二叉树的序列化与反序列化](https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/)
+ [序列化二叉树_牛客题霸_](https://www.nowcoder.com/practice/cf7e25aa97c04cc1a68c8f040e71fb84?tpId=295&tqId=23455&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26tab%3D%E7%AE%97%E6%B3%95%E7%AF%87%26topicId%3D295%26fromPut%3Dpc_kol_aaaxiu)

#### 相关题目

序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。

请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。

提示: 输入输出格式与 LeetCode 目前使用的方式一致，详情请参阅 LeetCode 序列化二叉树的格式。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。

示例 1：

<img src="/images/%E7%AE%97%E6%B3%95-%E6%A0%91%E4%B8%93%E9%A2%98/image-20230408153017961.png" alt="示例1" style="zoom: 33%;box-shadow:rgba(0,0,0,0) 0 0px 0px 0px;" />

输入：root = [1,2,3,null,null,4,5]
输出：[1,2,3,null,null,4,5]

#### 解题思路

需要注意，[序列化二叉树_牛客题霸_](https://www.nowcoder.com/practice/cf7e25aa97c04cc1a68c8f040e71fb84?tpId=295&tqId=23455&ru=/exam/oj&qru=/ta/format-top101/question-ranking&sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26tab%3D%E7%AE%97%E6%B3%95%E7%AF%87%26topicId%3D295%26fromPut%3Dpc_kol_aaaxiu)牛客这个返回的是char*，力扣是string

```cpp
class Solution {
private:
    string serialize(TreeNode* root){
        if(root == NULL) return "#,";
        string str;
        str = to_string(root->val) + ",";
        str += serialize(root->left);
        str += serialize(root->right);
        return str;
    }
    TreeNode* deserialize(char *&str) {
        if(*str == '#'){
            str++;
            return NULL;
        }
        int num = 0;
        while(*str != ',') {
            num = num * 10 + *str - '0';
            str++;
        }
        TreeNode* node = new TreeNode(num);
        node->left = deserialize(++str);
        node->right = deserialize(++str);
        return node;
    }
public:
    char* Serialize(TreeNode *root) {    
        string str = serialize(root);
        char* res = new char[str.size()];
        for(int i = 0; i < str.size(); i++) res[i] = str[i];
        return res;
    }
    TreeNode* Deserialize(char *str){
        return deserialize(str);
    }
};
```



[297. 二叉树的序列化与反序列化](https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/)力扣的解法

```cpp
class Codec {
private:
    string rserialize(TreeNode* root){
        if(root == NULL) return "#,";
        string str;
        str = to_string(root->val) + ",";
        str += serialize(root->left);
        str += serialize(root->right);
        return str;
    }
    TreeNode* rdeserialize(list<string>& dataArray) {
        if (dataArray.front() == "#") {
            dataArray.erase(dataArray.begin());
            return NULL;
        }
        TreeNode* root = new TreeNode(stoi(dataArray.front()));
        dataArray.erase(dataArray.begin());
        root->left = rdeserialize(dataArray);
        root->right = rdeserialize(dataArray);
        return root;
    }
public:
    // Encodes a tree to a single string.
    string serialize(TreeNode* root) {
        string str = rserialize(root);
        return str;
    }
    TreeNode* deserialize(string data) {
        list<string> dataArray;
        string str;
        for (auto& ch : data) {
            if (ch == ',') {
                dataArray.push_back(str);
                str.clear();
            } else str.push_back(ch);
        }
        if (!str.empty()) {
            dataArray.push_back(str);
            str.clear();
        }
        return rdeserialize(dataArray);
    }
};
```



## 二叉树的比较问题

### 另一树的子树

#### 相关链接

+ [100. 相同的树](https://leetcode.cn/problems/same-tree/description/)

+ [572. 另一棵树的子树](https://leetcode.cn/problems/subtree-of-another-tree/description/)

#### 相关题目

给你两棵二叉树 `root` 和 `subRoot` 。检验 `root` 中是否包含和 `subRoot` 具有相同结构和节点值的子树。如果存在，返回 `true` ；否则，返回 `false` 。

二叉树 `tree` 的一棵子树包括 `tree` 的某个节点和这个节点的所有后代节点。`tree` 也可以看做它自身的一棵子树。

**示例 1：**

<img src="https://assets.leetcode.com/uploads/2021/04/28/subtree1-tree.jpg" alt="示例1" style="zoom:50%;box-shadow:rgba(0,0,0,0) 0 0px 0px 0px;" />

```
输入：root = [3,4,5,1,2], subRoot = [4,1,2]
输出：true
```

#### 解答思路

**递归思路**

1. 确定递归函数的参数和返回值

	```c
bool dfs(TreeNode* root, TreeNode* subRoot)
	```

2. 确定终止条件

	```c
if(!root) return false;
	```

3. 确定单层递归的逻辑

	```c
	return check(root, subRoot) || dfs(root->left, subRoot) || dfs(root->right, subRoot);
	```

完整的代码如下：

```cpp
class Solution {
public:
    bool check(TreeNode* root, TreeNode* subRoot){
        if(!root && subRoot) return false;
        else if(root && !subRoot) return false;
        else if(!root && !subRoot) return true;
        else if(root->val != subRoot->val) return false;
        return check(root->left, subRoot->left) && check(root->right, subRoot->right); 
    }
    bool dfs(TreeNode* root, TreeNode* subRoot){
        if(!root) return false;
        return check(root, subRoot) || dfs(root->left, subRoot) || dfs(root->right, subRoot);
    }
    bool isSubtree(TreeNode* root, TreeNode* subRoot) {
        return dfs(root, subRoot);
    }
};
```

### 对称二叉树

#### 相关链接

+ [101. 对称二叉树 ](https://leetcode.cn/problems/symmetric-tree/description/)

#### 相关题目

给你一个二叉树的根节点 `root` ， 检查它是否轴对称。

**示例 1：**

<img src="https://assets.leetcode.com/uploads/2021/02/19/symtree1.jpg" alt="示例1" style="zoom:50%;box-shadow:rgba(0,0,0,0) 0 0px 0px 0px;" />

```
输入：root = [1,2,2,3,4,4,3]
输出：true
```

#### 解答思路

**本题比较的是两个子树的里侧和外侧的元素是否相等，可不是左右节点！**

1. 确定递归函数的参数和返回值

	```cpp
bool compare(TreeNode* left, TreeNode* right)
	```

2. 确定终止条件

	```cpp
if (left == NULL && right != NULL) return false;
else if (left != NULL && right == NULL) return false;
else if (left == NULL && right == NULL) return true;
else if (left->val != right->val) return false; 
	```

3. 确定单层递归的逻辑

	```cpp
bool outside = compare(left->left, right->right);   
bool inside = compare(left->right, right->left);    
bool isSame = outside && inside;                    
return isSame;
	```

递归全部代码如下：

```cpp
class Solution {
public:
    bool compare(TreeNode* left, TreeNode* right){
        if(!left && !right) return true;
        else if(!left && right) return false;
        else if(left && !right) return false;
        else if(left->val != right->val) return false;
        return compare(left->left, right->right) && compare(left->right, right->left);
    }
    bool isSymmetric(TreeNode* root) {
        if(!root) return true;
        return compare(root->left, root->right);
    }
};
```

### 相同的树

#### 相关链接

+ [100. 相同的树 ](https://leetcode.cn/problems/same-tree/description/)

#### 相关题目

给你两棵二叉树的根节点 `p` 和 `q` ，编写一个函数来检验这两棵树是否相同。

如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。

**示例 1：**

<img src="https://assets.leetcode.com/uploads/2020/12/20/ex1.jpg" alt="示例1" style="zoom:50%;box-shadow:rgba(0,0,0,0) 0 0px 0px 0px;" />

```
输入：p = [1,2,3], q = [1,2,3]
输出：true
```

#### 解题思路

1. 确定递归函数的参数和返回值

   我们要比较的是两个树是否是相互相同的，参数也就是两个树的根节点。

   返回值自然是bool类型。

   代码如下：

```text
bool compare(TreeNode* tree1, TreeNode* tree2)
```

2. 确定终止条件

   **要比较两个节点数值相不相同，首先要把两个节点为空的情况弄清楚！否则后面比较数值的时候就会操作空指针了。**

   节点为空的情况有：

+ tree1为空，tree2不为空，不对称，return false

+ tree1不为空，tree2为空，不对称 return false

+ tree1，tree2都为空，对称，返回true

  此时已经排除掉了节点为空的情况，那么剩下的就是tree1和tree2不为空的时候：

+ tree1、tree2都不为空，比较节点数值，不相同就return false

  此时tree1、tree2节点不为空，且数值也不相同的情况我们也处理了。

  代码如下：

```cpp
if (tree1 == NULL && tree2 != NULL) return false;
else if (tree1 != NULL && tree2 == NULL) return false;
else if (tree1 == NULL && tree2 == NULL) return true;
else if (tree1->val != tree2->val) return false; // 注意这里我没有使用else
```

3. 确定单层递归的逻辑

+ 比较二叉树是否相同 ：传入的是tree1的左孩子，tree2的右孩子。
+ 如果左右都相同就返回true ，有一侧不相同就返回false 。

代码如下：

```cpp
bool left = compare(tree1->left, tree2->left);   // 左子树：左、 右子树：左
bool right = compare(tree1->right, tree2->right);  // 左子树：右、 右子树：右
bool isSame = left && right;                    // 左子树：中、 右子树：中（逻辑处理）
return isSame;
```

最后递归的C++整体代码如下：

```cpp
class Solution {
public:
    bool compare(TreeNode* tree1, TreeNode* tree2) {
        if (tree1 == NULL && tree2 != NULL) return false;
        else if (tree1 != NULL && tree2 == NULL) return false;
        else if (tree1 == NULL && tree2 == NULL) return true;
        else if (tree1->val != tree2->val) return false; 

        bool left = compare(tree1->left, tree2->left);   // 左子树：左、 右子树：左
        bool right = compare(tree1->right, tree2->right);  // 左子树：右、 右子树：右
        bool isSame = left && right;                    // 左子树：中、 右子树：中（逻辑处理）
        return isSame;

    }
    bool isSameTree(TreeNode* p, TreeNode* q) {
        return compare(p, q);
    }
};
```

精简代码如下：

```cpp
class Solution {
public:
    bool isSameTree(TreeNode* p, TreeNode* q) {
        if(!p && !q) return true;
        else if(!p || !q) return false;
        else if(p->val != q->val) return false;
        else  return isSameTree(p->left,q->left) && isSameTree(p->right,q->right);
    }
};
```



## 完全二叉树问题

### 判断完全二叉树

#### 相关链接

+ [判断是不是完全二叉树_牛客题霸](https://www.nowcoder.com/practice/8daa4dff9e36409abba2adbe413d6fae?tpId=295&tqId=1025038&ru=%2Fexam%2Foj&qru=%2Fta%2Fformat-top101%2Fquestion-ranking&sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26tab%3D%E7%AE%97%E6%B3%95%E7%AF%87%26topicId%3D295%26fromPut%3Dpc_kol_aaaxiu)

#### 相关题目

给定一个二叉树，确定他是否是一个完全二叉树。

完全二叉树的定义：

若二叉树的深度为 h，除第 h 层外，其它各层的结点数都达到最大个数，第 h 层所有的叶子结点都连续集中在最左边，这就是完全二叉树。（第 h 层可能包含 [1~2h] 个节点）

#### 解题思路

```cpp
class Solution {
public:
    bool isCompleteTree(TreeNode* root) {
        if(!root) return true;
        queue<TreeNode*> q;
        q.push(root);
        bool flag = false;
        while(!q.empty()) {
            int size = q.size();
            for(int i = 0; i < size; i++) {
                auto cur = q.front();
                q.pop();
                if(cur == NULL) flag = true;
                else {
                    if(flag) return false;
                    q.push(cur->left);
                    q.push(cur->right);
                }
            }
        }
        return true;
    }
};
```



### 完全二叉树的节点个数

#### 相关链接

+ [222. 完全二叉树的节点个数](https://leetcode.cn/problems/count-complete-tree-nodes/description/)

#### 相关题目

给你一棵 **完全二叉树** 的根节点 `root` ，求出该树的节点个数。

完全二叉树的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 `h` 层，则该层包含 `1~ 2h` 个节点。

**示例 1：**

<img src="/images/%E7%AE%97%E6%B3%95-%E6%A0%91%E4%B8%93%E9%A2%98/image-20230408224552357.png" alt="示例1" style="zoom:33%;box-shadow:rgba(0,0,0,0) 0 0px 0px 0px;" />

```
输入：root = [1,2,3,4,5,6]
输出：6
```

#### 解题思路

这道题 普通二叉树的递归，层次遍历的模板，以及利用完全二叉树的性质都可以做

**普通二叉树的递归**

这是极简写法，和二叉树的深度遍历思路是一样的，不过多解释

```cpp
class Solution {
public:
    int countNodes(TreeNode* root) {
        if (root == NULL) return 0;
        return countNodes(root->left) + countNodes(root->right) + 1;
    }
};
```

**完全二叉树的性质**

完全二叉树只有两种情况，情况一：就是满二叉树，情况二：最后一层叶子节点没有满。

对于情况一，可以直接用 2^树深度 - 1 来计算，注意这里根节点深度为1。

对于情况二，分别递归左孩子，和右孩子，递归到某一深度一定会有左孩子或者右孩子为满二叉树，然后依然可以按照情况1来计算。

**！！！在完全二叉树中，如果递归向左遍历的深度等于递归向右遍历的深度，那说明就是满二叉树！！！**

所以可以在普通二叉树递归版本剪枝

```cpp
class Solution {
public:
    int countNodes(TreeNode* root) {
        if (root == NULL) return 0;
        auto left = root->left;
        auto right =  root->right;
        int leftDepth = 0, rightDepth = 0;
        while(left){
            left = left->left;
            leftDepth++;
        }
        while(right){
            right = right->right;
            rightDepth++;
        }
        if(leftDepth == rightDepth) return (2 << leftDepth) - 1;
        return countNodes(root->left) + countNodes(root->right) + 1;
    }
};
```

## 平衡二叉树问题

### 平衡二叉树(求二叉树高度)

#### 相关链接

+ [110. 平衡二叉树](https://leetcode.cn/problems/balanced-binary-tree/description/)

#### 相关题目

给定一个二叉树，判断它是否是高度平衡的二叉树。

本题中，一棵高度平衡二叉树定义为：

> 一个二叉树*每个节点* 的左右两个子树的高度差的绝对值不超过 1 。

**示例 1：**

<img src="https://assets.leetcode.com/uploads/2020/10/06/balance_1.jpg" alt="示例1" style="zoom:50%;box-shadow:rgba(0,0,0,0) 0 0px 0px 0px;" />

```
输入：root = [3,9,20,null,null,15,7]
输出：true
```

#### 解题思路

通过本题可以了解求二叉树深度 和 二叉树高度的差异，求深度适合用前序遍历，而求高度适合用后序遍历。

二叉树中高度和深度是不同的，下面图片和思路 来自 [代码随想录](https://www.programmercarl.com/0110.平衡二叉树.html#题外话)

<img src="/images/%E6%A0%91-%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98/image-20221125194641246.png" alt="深度和高度的不同" style="zoom:80%;box-shadow:rgba(0,0,0,0) 0 0px 0px 0px;" />

求深度可以从上到下去查 所以需要前序遍历（中左右），而高度只能从下到上去查，所以只能后序遍历（左右中）

二叉树的最大深度，也用的是后序遍历，**那是因为代码的逻辑其实是求的根节点的高度，而根节点的高度就是这棵树的最大深度，所以才可以使用后序遍历。**

**写法1-递归法**

1. 明确递归函数的参数和返回值

   那么如何标记左右子树是否差值大于1呢？如果当前传入节点为根节点的二叉树已经不是二叉平衡树了，还返回高度的话就没有意义了。所以如果已经不是二叉平衡树了，可以返回-1 来标记已经不符合平衡树的规则了。代码如下：

```cpp
// -1 表示已经不是平衡二叉树了，否则返回值是以该节点为根节点树的高度
int getHeight(TreeNode* node)
```

2. 明确终止条件

   递归的过程中依然是遇到空节点了为终止，返回0，表示当前节点为根节点的树高度为0，代码如下：

```cpp
if (node == NULL) {
    return 0;
}
```

3. 明确单层递归的逻辑

   如何判断以当前传入节点为根节点的二叉树是否是平衡二叉树呢？当然是其左子树高度和其右子树高度的差值。分别求出其左右子树的高度，然后如果差值小于等于1，则返回当前二叉树的高度，否则则返回-1，表示已经不是二叉平衡树了。代码如下：

```cpp
    int leftHeight = getHeight(node->left); // 左
    if (leftHeight == -1) return -1;
    int rightHeight = getHeight(node->right); // 右
    if (rightHeight == -1) return -1;

    int result;
    if (abs(leftHeight - rightHeight) > 1) {  // 中
        result = -1;
    } else {
        result = max(leftHeight, rightHeight) + 1; // 以当前节点为根节点的树的最大高度
    }

    return result;
```

全部代码如下：

```cpp
class Solution {
public:
    int getHeight(TreeNode* root){
        if(!root) return 0;
        int leftHeight = getHeight(root->left);
        if(leftHeight == -1) return -1;
        int rightHeight = getHeight(root->right);
        if(rightHeight == -1) return -1;
        // 否则返回以当前节点为根节点的树的最大高度
        return abs(leftHeight - rightHeight) > 1 ? -1 : max(leftHeight, rightHeight) + 1;
    }
    bool isBalanced(TreeNode* root) {
        return getHeight(root) == -1 ? false : true;
    }
};
```

**写法2-迭代法**

我们可以使用层序遍历来求深度，但是就不能直接用层序遍历来求高度了，这就体现出求高度和求深度的不同。

本题的迭代方式可以先定义一个函数，专门用来求高度。

这个函数通过栈模拟的后序遍历找每一个节点的高度（其实是通过求传入节点为根节点的最大深度来求的高度）

代码如下：

```cpp
// cur节点的最大深度，就是cur的高度
int getDepth(TreeNode* cur) {
    stack<TreeNode*> st;
    if (cur != NULL) st.push(cur);
    int depth = 0; // 记录深度
    int result = 0;
    while (!st.empty()) {
        TreeNode* node = st.top();
        if (node != NULL) {
            st.pop();
            st.push(node);                          // 中
            st.push(NULL);
            depth++;
            if (node->right) st.push(node->right);  // 右
            if (node->left) st.push(node->left);    // 左

        } else {
            st.pop();
            node = st.top();
            st.pop();
            depth--;
        }
        result = result > depth ? result : depth;
    }
    return result;
}
```

然后再用栈来模拟后序遍历，遍历每一个节点的时候，再去判断左右孩子的高度是否符合，代码如下：

```cpp
bool isBalanced(TreeNode* root) {
    stack<TreeNode*> st;
    if (root == NULL) return true;
    st.push(root);
    while (!st.empty()) {
        TreeNode* node = st.top();                       // 中
        st.pop();
        if (abs(getDepth(node->left) - getDepth(node->right)) > 1) { // 判断左右孩子高度是否符合
            return false;
        }
        if (node->right) st.push(node->right);           // 右（空节点不入栈）
        if (node->left) st.push(node->left);             // 左（空节点不入栈）
    }
    return true;
}
```

整体代码如下：

```cpp
class Solution {
private:
    int getDepth(TreeNode* cur) {
        stack<TreeNode*> st;
        if (cur != NULL) st.push(cur);
        int depth = 0; // 记录深度
        int result = 0;
        while (!st.empty()) {
            TreeNode* node = st.top();
            if (node != NULL) {
                st.pop();
                st.push(node);                          // 中
                st.push(NULL);
                depth++;
                if (node->right) st.push(node->right);  // 右
                if (node->left) st.push(node->left);    // 左

            } else {
                st.pop();
                node = st.top();
                st.pop();
                depth--;
            }
            result = result > depth ? result : depth;
        }
        return result;
    }

public:
    bool isBalanced(TreeNode* root) {
        stack<TreeNode*> st;
        if (root == NULL) return true;
        st.push(root);
        while (!st.empty()) {
            TreeNode* node = st.top();                       // 中
            st.pop();
            if (abs(getDepth(node->left) - getDepth(node->right)) > 1) {
                return false;
            }
            if (node->right) st.push(node->right);           // 右（空节点不入栈）
            if (node->left) st.push(node->left);             // 左（空节点不入栈）
        }
        return true;
    }
};
```

## 二叉搜索树问题

### 二叉搜索树的搜索

#### 相关链接

+ [700. 二叉搜索树中的搜索 ](https://leetcode.cn/problems/search-in-a-binary-search-tree/description/)

#### 相关题目

给定二叉搜索树（BST）的根节点 `root` 和一个整数值 `val`。

你需要在 BST 中找到节点值等于 `val` 的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 `null` 。

**示例 1:**

<img src="https://assets.leetcode.com/uploads/2021/01/12/tree1.jpg" alt="示例1" style="zoom:40%;box-shadow:rgba(0,0,0,0) 0 0px 0px 0px;" />

```
输入：root = [4,2,7,1,3], val = 2
输出：[2,1,3]
```

#### 解题思路

二叉搜索树是一个有序树：

+ 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；
+ 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；
+ 它的左、右子树也分别为二叉搜索树



1. 确定递归函数的参数和返回值

   递归函数的参数传入的就是根节点和要搜索的数值，返回的就是以这个搜索数值所在的节点。
   代码如下：
	```cpp
	TreeNode* searchBST(TreeNode* root, int val)
	```

2. 确定终止条件

   如果root为空，或者找到这个数值了，就返回root节点。
	```cpp
	if (root == NULL || root->val == val) return root;
	```

3. 确定单层递归的逻辑

   看看二叉搜索树的单层递归逻辑有何不同。因为二叉搜索树的节点是有序的，所以可以有方向的去搜索。如果root->val > val，搜索左子树，如果root->val < val，就搜索右子树，最后如果都没有搜索到，就返回NULL。

   代码如下：

	```cpp
TreeNode* result = NULL;
if (root->val > val) result = searchBST(root->left, val);
if (root->val < val) result = searchBST(root->right, val);
return result;
	```

写递归函数的时候 习惯直接写 `searchBST(root->left, val)`，却忘了 递归函数还有返回值。递归函数的返回值是什么? 是左子树如果搜索到了val，要将该节点返回。 如果不用一个变量将其接住，那么返回值不就没了。所以要 `result = searchBST(root->left, val)`。

整体代码如下：

```cpp
class Solution {
public:
    TreeNode* searchBST(TreeNode* root, int val) {
        if (root == NULL || root->val == val) return root;
        TreeNode* result = NULL;
        if (root->val > val) result = searchBST(root->left, val);
        if (root->val < val) result = searchBST(root->right, val);
        return result;
    }
};
```

迭代法代码如下：

```cpp
class Solution {
public:
    TreeNode* searchBST(TreeNode* root, int val) {
        while (root != NULL) {
            if (root->val > val) root = root->left;
            else if (root->val < val) root = root->right;
            else return root;
        }
        return NULL;
    }
};
```

### 二叉搜索树的验证

#### 相关链接

+ [98. 验证二叉搜索树 ](https://leetcode.cn/problems/validate-binary-search-tree/)

#### 相关题目

给你一个二叉树的根节点 `root` ，判断其是否是一个有效的二叉搜索树。

**有效** 二叉搜索树定义如下：

+ 节点的左子树只包含 **小于** 当前节点的数。
+ 节点的右子树只包含 **大于** 当前节点的数。
+ 所有左子树和右子树自身必须也是二叉搜索树。

**示例 1：**

<img src="https://assets.leetcode.com/uploads/2020/12/01/tree1.jpg" alt="示例1" style="zoom:50%;box-shadow:rgba(0,0,0,0) 0 0px 0px 0px;" />

```
输入：root = [2,1,3]
输出：true
```

#### 解题思路

假设一个二叉搜索树具有如下特征：

+ 节点的左子树只包含小于当前节点的数。
+ 节点的右子树只包含大于当前节点的数。
+ 所有左子树和右子树自身必须也是二叉搜索树。

**写法1-中序数组验证**

可以递归中序遍历将二叉搜索树转变成一个数组，然后只要比较一下，这个数组是否是有序的，**注意二叉搜索树中不能有重复元素**，代码如下：

```cpp
class Solution {
public:
    vector<int> vc;
    void traversal(TreeNode* root){
        if(!root) return;
        traversal(root->left);
        vc.push_back(root->val);
        traversal(root->right);
    }
    bool isValidBST(TreeNode* root) {
        traversal(root);
        for(int i = 0; i < vc.size() - 1; i++){
            if(vc[i] >= vc[i + 1]) return false;
        }
        return true;
    }
};
```

**写法2-直接递归验证**

```cpp
class Solution {
public:
    long long maxVal = LONG_MIN; // 因为后台测试数据中有int最小值
    bool isValidBST(TreeNode* root) {
        if (root == NULL) return true;

        bool left = isValidBST(root->left);
        
        // 中序遍历，验证遍历的元素是不是从小到大
        if (maxVal < root->val) maxVal = root->val;
        else return false;
        
        bool right = isValidBST(root->right);

        return left && right;
    }
};
```

### 二叉搜索树的插入

#### 相关链接

+ [701. 二叉搜索树中的插入操作](https://leetcode.cn/problems/insert-into-a-binary-search-tree/)

#### 相关题目

给定二叉搜索树（BST）的根节点 `root` 和要插入树中的值 `value` ，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 **保证** ，新值和原始二叉搜索树中的任意节点值都不同。

**注意**，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 **任意有效的结果** 。

**示例 1：**

<img src="https://assets.leetcode.com/uploads/2020/10/05/insertbst.jpg" alt="示例1" style="zoom:50%;box-shadow:rgba(0,0,0,0) 0 0px 0px 0px;" />

```
输入：root = [4,2,7,1,3], val = 5
输出：[4,2,7,1,3,5]
解释：另一个满足题目要求可以通过的树是：
```

#### 解题思路

1. 确定递归函数参数以及返回值，**有返回值的话，可以利用返回值完成新加入的节点与其父节点的赋值操作**。

代码如下：

```cpp
TreeNode* insertIntoBST(TreeNode* root, int val)
```

2. 确定终止条件

终止条件就是找到遍历的节点为null的时候，就是要插入节点的位置了，并把插入的节点返回。

代码如下：

```cpp
if (root == NULL) {
    TreeNode* node = new TreeNode(val);
    return node;
}
```

这里把添加的节点返回给上一层，就完成了父子节点的赋值操作了，详细再往下看。

3. 确定单层递归的逻辑

此时要明确，搜索树是有方向了，可以根据插入元素的数值，决定递归方向。代码如下：

```cpp
if (root->val > val) root->left = insertIntoBST(root->left, val);
if (root->val < val) root->right = insertIntoBST(root->right, val);
return root;
```

**到这里，大家应该能感受到，如何通过递归函数返回值完成了新加入节点的父子关系赋值操作了，下一层将加入节点返回，本层用root->left或者root->right将其接住**。参数就是根节点指针，以及要插入元素

完整代码如下:

```cpp
class Solution {
public:
    TreeNode* insertIntoBST(TreeNode* root, int val) {
        if(root == NULL){
            TreeNode* node = new TreeNode(val);
            return node;
        }
        if(root->val > val) root->left = insertIntoBST(root->left, val);
        if(root->val < val) root->right = insertIntoBST(root->right, val);
        return root;
    }
};
```

### 二叉搜索树的删除

#### 相关链接

+ [450. 删除二叉搜索树中的节点 ](https://leetcode.cn/problems/delete-node-in-a-bst/)

#### 相关题目

给定一个二叉搜索树的根节点 **root** 和一个值 **key**，删除二叉搜索树中的 **key** 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。

一般来说，删除节点可分为两个步骤：

1. 首先找到需要删除的节点；
2. 如果找到了，删除它。

**示例 1:**

<img src="https://assets.leetcode.com/uploads/2020/09/04/del_node_1.jpg" alt="示例1" style="zoom:30%;box-shadow:rgba(0,0,0,0) 0 0px 0px 0px;" />

```
输入：root = [5,3,6,2,4,null,7], key = 3
输出：[5,4,6,2,null,null,7]
解释：给定需要删除的节点值是 3，所以我们首先找到 3 这个节点，然后删除它。
一个正确的答案是 [5,4,6,2,null,null,7], 如下图所示。
另一个正确答案是 [5,2,6,null,4,null,7]。
```

#### 解题思路

有以下五种情况：

+ 第一种情况：没找到删除的节点，遍历到空节点直接返回了
+ 找到删除的节点
  + 第二种情况：左右孩子都为空（叶子节点），直接删除节点， 返回NULL为根节点
  + 第三种情况：删除节点的左孩子为空，右孩子不为空，删除节点，右孩子补位，返回右孩子为根节点
  + 第四种情况：删除节点的右孩子为空，左孩子不为空，删除节点，左孩子补位，返回左孩子为根节点
  + 第五种情况：左右孩子节点都不为空，则将删除节点的左子树头结点（左孩子）放到删除节点的右子树的最左面节点的左孩子上，返回删除节点右孩子为新的根节点。

```cpp
class Solution {
public:
    TreeNode* deleteNode(TreeNode* root, int key) {
        if (root == nullptr) return root; // 第一种情况：没找到删除的节点，遍历到空节点直接返回了
        if (root->val == key) {
            // 第二种情况：左右孩子都为空（叶子节点），直接删除节点， 返回NULL为根节点
            if (root->left == nullptr && root->right == nullptr) {
                delete root;
                return nullptr;
            }
            // 第三种情况：其左孩子为空，右孩子不为空，删除节点，右孩子补位 ，返回右孩子为根节点
            else if (root->left == nullptr) {
                auto retNode = root->right;
                ///! 内存释放
                delete root;
                return retNode;
            }
            // 第四种情况：其右孩子为空，左孩子不为空，删除节点，左孩子补位，返回左孩子为根节点
            else if (root->right == nullptr) {
                auto retNode = root->left;
                delete root;
                return retNode;
            }
            // 第五种情况：左右孩子节点都不为空，则将删除节点的左子树放到删除节点的右子树的最左面节点的左孩子的位置
            // 并返回删除节点右孩子为新的根节点。
            else {
                TreeNode* cur = root->right; // 找右子树最左面的节点
                while(cur->left != nullptr) {
                    cur = cur->left;
                }
                cur->left = root->left; // 把要删除的节点（root）左子树放在cur的左孩子的位置
                TreeNode* tmp = root;   // 把root节点保存一下，下面来删除
                root = root->right;     // 返回旧root的右孩子作为新root
                delete tmp;             // 释放节点内存（这里不写也可以，但C++最好手动释放一下吧）
                return root;
            }
        }
        if (root->val > key) root->left = deleteNode(root->left, key);
        if (root->val < key) root->right = deleteNode(root->right, key);
        return root;
    }
};
```

### 二叉搜索树的修剪

#### 相关链接

+ [669. 修剪二叉搜索树 ](https://leetcode.cn/problems/trim-a-binary-search-tree/)

#### 相关题目

给你二叉搜索树的根节点 `root` ，同时给定最小边界`low` 和最大边界 `high`。通过修剪二叉搜索树，使得所有节点的值在`[low, high]`中。修剪树 **不应该** 改变保留在树中的元素的相对结构 (即，如果没有被移除，原有的父代子代关系都应当保留)。 可以证明，存在 **唯一的答案** 。

所以结果应当返回修剪好的二叉搜索树的新的根节点。注意，根节点可能会根据给定的边界发生改变。

**示例 1：**

<img src="https://assets.leetcode.com/uploads/2020/09/09/trim1.jpg" alt="示例1" style="zoom:50%;box-shadow:rgba(0,0,0,0) 0 0px 0px 0px;" />

```
输入：root = [1,0,2], low = 1, high = 2
输出：[1,null,2]
```

#### 解题思路

1. 确定递归函数的参数以及返回值

   ```cpp
   TreeNode* trimBST(TreeNode* root, int low, int high)
   ```

2. 确定终止条件

   ```cpp
   if (root == NULL) return NULL;
   ```

3. 确定单层递归的逻辑

   ```cpp
   if (root->val < low) {
       TreeNode* right = trimBST(root->right, low, high); // 寻找符合区间[low, high]的节点
       return right;
   }
   if (root->val > high) {
       TreeNode* left = trimBST(root->left, low, high); // 寻找符合区间[low, high]的节点
       return left;
   }
   root->left = trimBST(root->left, low, high); // root->left接入符合条件的左孩子
   root->right = trimBST(root->right, low, high); // root->right接入符合条件的右孩子
   ```

完整代码如下：

```cpp
class Solution {
public:
    TreeNode* trimBST(TreeNode* root, int low, int high) {
        if (root == NULL) return NULL;
        if (root->val < low) return trimBST(root->right, low, high);
        if (root->val > high) return trimBST(root->left, low, high);
        root->left = trimBST(root->left, low, high);
        root->right = trimBST(root->right, low, high);
        return root;
    }
};
```

### 二叉搜索树的众数

#### 相关链接

+ [501. 二叉搜索树中的众数 ](https://leetcode.cn/problems/find-mode-in-binary-search-tree/)

#### 相关题目

给你一个含重复值的二叉搜索树（BST）的根节点 `root` ，找出并返回 BST 中的所有 众数（即，出现频率最高的元素）。

如果树中有不止一个众数，可以按 **任意顺序** 返回。

假定 BST 满足如下定义：

+ 结点左子树中所含节点的值 **小于等于** 当前节点的值
+ 结点右子树中所含节点的值 **大于等于** 当前节点的值
+ 左子树和右子树都是二叉搜索树

**示例 1：**

<img src="https://assets.leetcode.com/uploads/2021/03/11/mode-tree.jpg" alt="示例1" style="zoom:50%;box-shadow:rgba(0,0,0,0) 0 0px 0px 0px;" />

```
输入：root = [1,null,2,2]
输出：[2]
```

#### 解题思路

如果不是二叉搜索树，最直观的方法一定是把这个树都遍历了，用map统计频率，把频率排个序，最后取前面高频的元素的集合。

由于map不能根据value排序，所以要把map转化数组即vector，再进行排序，当然vector里面放的也是`pair<int, int>`类型的数据，第一个int为元素，第二个int为出现频率。此时数组vector中已经是存放着按照频率排好序的pair，那么把前面高频的元素取出来就可以了。

```cpp
class Solution {
private:
    void searchBST(TreeNode* cur, unordered_map<int, int>& map) { // 前序遍历
        if(cur == NULL) return ;
        map[cur->val]++; 					// 统计元素频率
        searchBST(cur->left, map);
        searchBST(cur->right, map);
        return ;
    }
    bool static cmp (const pair<int, int>& a, const pair<int, int>& b) {
        return a.second > b.second;
    }
public:
    vector<int> findMode(TreeNode* root) {
        unordered_map<int, int> map; 		// key:元素，value:出现频率
        vector<int> result;
        if(root == NULL) return result;
        searchBST(root, map);
        vector<pair<int, int>> vec(map.begin(), map.end());
        sort(vec.begin(), vec.end(), cmp); // 给频率排个序
        result.push_back(vec[0].first);
        for(int i = 1; i < vec.size(); i++) {
            // 取最高的放到result数组中
            if (vec[i].second == vec[0].second) result.push_back(vec[i].first);
            else break;
        }
        return result;
    }
};
```

### 二叉搜索树的最小绝对差

#### 相关链接

+ [530. 二叉搜索树的最小绝对差 ](https://leetcode.cn/problems/minimum-absolute-difference-in-bst/)

#### 相关题目

给你一个二叉搜索树的根节点 `root` ，返回 **树中任意两不同节点值之间的最小差值** 。

差值是一个正数，其数值等于两值之差的绝对值。

**示例 1：**

<img src="https://assets.leetcode.com/uploads/2021/02/05/bst1.jpg" alt="示例1" style="zoom:50%;box-shadow:rgba(0,0,0,0) 0 0px 0px 0px;" />

```
输入：root = [4,2,6,1,3]
输出：1
```

####  解题思路

**写法1-中序数组计算**

二叉搜索树采用中序遍历，其实就是一个有序数组。**在一个有序数组上求两个数最小差值。**最直观的想法，就是把二叉搜索树转换成有序数组，然后遍历一遍数组，就统计出来最小差值了。

```cpp
class Solution {
private:
    vector<int> vec;
    void traversal(TreeNode* root) {
        if (root == NULL) return;
        traversal(root->left);
        vec.push_back(root->val); 
        traversal(root->right);
    }
public:
    int getMinimumDifference(TreeNode* root) {
        traversal(root);
        if (vec.size() < 2) return 0;
        int result = INT_MAX;
        for (int i = 1; i < vec.size(); i++) { 
            result = min(result, vec[i] - vec[i-1]);
        }
        return result;
    }
};
```

**写法2-直接计算**

```cpp
class Solution {
private:
    int result = INT_MAX;
    TreeNode* pre = NULL;
    void traversal(TreeNode* cur) {
        if (cur == NULL) return;
        traversal(cur->left);   
        if (pre != NULL){       
            result = min(result, cur->val - pre->val);
        }
        pre = cur; // 记录前一个
        traversal(cur->right);  
    }
public:
    int getMinimumDifference(TreeNode* root) {
        traversal(root);
        return result;
    }
};
```

**利用二叉排序树是有序的性质**

```cpp
class Solution {
public:
    int maxCount = 0; 						// 最大频率
    int count = 0; 							// 统计频率
    TreeNode* pre = NULL;
    vector<int> result;
    void searchBST(TreeNode* cur) {
        if(cur == NULL) return ;
        searchBST(cur->left);    

        if(pre == NULL) count = 1; 		// 第一个节点
        else if (pre->val == cur->val) count++; // 与前一个节点数值相同
        else count = 1; 					// 与前一个节点数值不同
        pre = cur; 							// 更新上一个节点
        if (count == maxCount)  result.push_back(cur->val); // 如果和最大值相同，放进result中
        if (count > maxCount) { 			// 如果计数大于最大值频率
            maxCount = count;   			// 更新最大频率
            result.clear();     			// 很关键的一步，不要忘记清空result，之前result里的元素都失效了
            result.push_back(cur->val);
        }

        searchBST(cur->right);    
        return ;
    }
    vector<int> findMode(TreeNode* root) {
        searchBST(root);
        return result;
    }
};
```

### 二叉搜索树的最近公共祖先

#### 相关链接

+ [235. 二叉搜索树的最近公共祖先 ](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/)

#### 相关题目

给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（**一个节点也可以是它自己的祖先**）。”

例如，给定如下二叉搜索树: root = [6,2,8,0,4,7,9,null,null,3,5]

<img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/binarysearchtree_improved.png" alt="示例1" style="zoom:80%;box-shadow:rgba(0,0,0,0) 0 0px 0px 0px;" />

**示例 1:**

```
输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8
输出: 6 
解释: 节点 2 和节点 8 的最近公共祖先是 6。
```

#### 解题思路

1. 确定递归函数返回值以及参数

参数就是当前节点，以及两个结点 p、q。返回值是要返回最近公共祖先，所以是TreeNode * 。代码如下：

```cpp
TreeNode* traversal(TreeNode* cur, TreeNode* p, TreeNode* q)
```

2. 确定终止条件

遇到空返回就可以了，代码如下：

```cpp
if (cur == NULL) return cur;
```

其实都不需要这个终止条件，因为题目中说了p、q 为不同节点且均存在于给定的二叉搜索树中。也就是说一定会找到公共祖先的，所以并不存在遇到空的情况。

3. 确定单层递归的逻辑

在遍历二叉搜索树的时候就是寻找区间[p->val, q->val]（注意这里是左闭又闭）那么如果 cur->val 大于 p->val，同时 cur->val 大于q->val，那么就应该向左遍历（说明目标区间在左子树上）。**需要注意的是此时不知道p和q谁大，所以两个都要判断**

代码如下：

```cpp
if (cur->val > p->val && cur->val > q->val) {
    TreeNode* left = traversal(cur->left, p, q);
    if (left != NULL) {
        return left;
    }
}
```

完整代码：

```cpp
class Solution {
private:
    TreeNode* traversal(TreeNode* cur, TreeNode* p, TreeNode* q) {
        if(cur == NULL) return cur;
        if(cur->val > p->val && cur->val > q->val) {   // 左
            TreeNode* left = traversal(cur->left, p, q);
            if (left != NULL) {
                return left;
            }
        }
        if(cur->val < p->val && cur->val < q->val) {   // 右
            TreeNode* right = traversal(cur->right, p, q);
            if (right != NULL) {
                return right;
            }
        }
        return cur;
    }
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        return traversal(root, p, q);
    }
};
```

精简后代码如下：

```cpp
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if(root->val > p->val && root->val > q->val) {
            return lowestCommonAncestor(root->left, p, q);
        } else if(root->val < p->val && root->val < q->val) {
            return lowestCommonAncestor(root->right, p, q);
        } else return root;
    }
};
```

### 二叉搜索树转换为累加树

#### 相关链接

+ [538. 把二叉搜索树转换为累加树 ](https://leetcode.cn/problems/convert-bst-to-greater-tree/)
+ [1038. 从二叉搜索树到更大和树 ](https://leetcode.cn/problems/binary-search-tree-to-greater-sum-tree/)

#### 相关题目

给出二叉 **搜索** 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 `node` 的新值等于原树中大于或等于 `node.val` 的值之和。

提醒一下，二叉搜索树满足下列约束条件：

+ 节点的左子树仅包含键 **小于** 节点键的节点。
+ 节点的右子树仅包含键 **大于** 节点键的节点。
+ 左右子树也必须是二叉搜索树。

**示例 1：**

<img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/05/03/tree.png" alt="示例1" style="zoom:50%;box-shadow:rgba(0,0,0,0) 0 0px 0px 0px;" />

```
输入：[4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]
输出：[30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]
```

#### 解题思路

**换一个角度来看，这就是一个有序数组[2, 5, 13]，求从后到前的累加数组，也就是[20, 18, 13]，**

**从树中可以看出累加的顺序是右中左，所以我们需要反中序遍历这个二叉树，然后顺序累加就可以了**。

1. 递归函数参数以及返回值

   这里很明确了，不需要递归函数的返回值做什么操作了，要遍历整棵树。同时需要定义一个全局变量pre，用来保存cur节点的前一个节点的数值，定义为int型就可以了。代码如下：

   ```cpp
   int pre = 0; 
   void traversal(TreeNode* cur)
   ```

2. 确定终止条件

   ```cpp
   if (cur == NULL) return;
   ```

3. 确定单层递归的逻辑

   注意**要右中左来遍历二叉树**， 中节点的处理逻辑就是让cur的数值加上前一个节点的数值。

   ```cpp
   traversal(cur->right);  // 右
   cur->val += pre;        // 中
   pre = cur->val;
   traversal(cur->left);   // 左
   ```

递归法整体代码如下：

```cpp
class Solution {
private:
    int pre = 0; 
    void traversal(TreeNode* cur) { 
        if(cur == NULL) return;
        traversal(cur->right);
        cur->val += pre;
        pre = cur->val;
        traversal(cur->left);
    }
public:
    TreeNode* convertBST(TreeNode* root) {
        traversal(root);
        return root;
    }
};
```

### 二叉搜索树转换为双向链表

#### 相关链接

+ [二叉搜索树与双向链表_牛客题霸_](https://www.nowcoder.com/practice/947f6eb80d944a84850b0538bf0ec3a5?tpId=295&tqId=23454&ru=%2Fexam%2Foj&qru=%2Fta%2Fformat-top101%2Fquestion-ranking&sourceUrl=%2Fexam%2Foj%3Fpage%3D1%26tab%3D%E7%AE%97%E6%B3%95%E7%AF%87%26topicId%3D295%26fromPut%3Dpc_kol_aaaxiu)

#### 相关题目

输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。如下图所示

<img src="/images/%E7%AE%97%E6%B3%95-%E6%A0%91%E4%B8%93%E9%A2%98/image-20230406163203334.png" alt="示例1" style="zoom: 50%;box-shadow:rgba(0,0,0,0) 0 0px 0px 0px;" />

注意:

1. 要求不能创建任何新的结点，只能调整树中结点指针的指向。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继

2. 返回链表中的第一个节点的指针

3. 函数返回的TreeNode，有左右指针，其实可以看成一个双向链表的数据结构

4. 你不用输出双向链表，程序会根据你的返回值自动打印输出

示例输入：

```
{10,6,14,4,8,12,16}
返回值：
From left to right are:4,6,8,10,12,14,16;From right to left are:16,14,12,10,8,6,4;
```

#### 解题思路

```c++
class Solution {
public:
    TreeNode* head = NULL;
    TreeNode* pre = NULL;
    TreeNode* Convert(TreeNode* pRootOfTree) {
        if (!pRootOfTree) return NULL;
        Convert(pRootOfTree->left);
        if (pre == NULL) { //找到最左点的节点
            head = pRootOfTree;
            pre = pRootOfTree;
        } else {
            pre->right = pRootOfTree;
            pRootOfTree->left = pre;
            pre = pRootOfTree;
        }
        Convert(pRootOfTree->right);
        return head;
    }
};
```

### 有序数组转换为二叉搜索树

#### 相关链接

+ [108. 将有序数组转换为二叉搜索树 ](https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/)

#### 相关题目

给你一个整数数组 `nums` ，其中元素已经按 **升序** 排列，请你将其转换为一棵 **高度平衡** 二叉搜索树。

**高度平衡** 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。

**示例1：**

<img src="https://assets.leetcode.com/uploads/2021/02/18/btree1.jpg" alt="示例1" style="zoom:67%;box-shadow:rgba(0,0,0,0) 0 0px 0px 0px;" />

```
输入：nums = [-10,-3,0,5,9]
输出：[0,-3,9,-10,null,5]
解释：[0,-10,5,null,-3,null,9] 也将被视为正确答案：
```

#### 解题思路

1. 确定递归函数返回值及其参数

   ```cpp
   TreeNode* traversal(vector<int>& nums, int left, int right)
   ```

2. 确定递归终止条件

   ```cpp
   if(left > right) return NULL;
   ```

3. 确定单层递归的逻辑

   ```cpp
   int mid = left + ((right - left) / 2);
   TreeNode* root = new TreeNode(nums[mid]);
   root->left = traversal(nums, left, mid - 1);
   root->right = traversal(nums, mid + 1, right);
   return root;
   ```

整体代码如下

```cpp
class Solution {
public:
    TreeNode* traversal(vector<int>& nums, int l, int r){
        if(l > r) return NULL;
        int mid = l + ((r - l) / 2);
        TreeNode* root = new TreeNode(nums[mid]);
        root->left = traversal(nums, l, mid - 1);
        root->right = traversal(nums, mid + 1, r);
        return root;
    }
    TreeNode* sortedArrayToBST(vector<int>& nums) {
        TreeNode* root = traversal(nums, 0, nums.size() - 1);
        return root;
    }
};
```

### 二叉搜索树变平衡

#### 相关链接

+ [1382. 将二叉搜索树变平衡](https://leetcode.cn/problems/balance-a-binary-search-tree/description/)

#### 相关题目

给你一棵二叉搜索树，请你返回一棵 **平衡后** 的二叉搜索树，新生成的树应该与原来的树有着相同的节点值。如果有多种构造方法，请你返回任意一种。

如果一棵二叉搜索树中，每个节点的两棵子树高度差不超过 `1` ，我们就称这棵二叉搜索树是 **平衡的** 。

**示例 1：**

<img src="https://assets.leetcode.com/uploads/2021/08/10/balance1-tree.jpg" alt="示例1" style="zoom: 50%; box-shadow: rgba(0, 0, 0, 0) 0px 0px 0px 0px;" />

```
输入：root = [1,null,2,null,3,null,4,null,null]
输出：[2,1,3,null,null,null,4]
解释：这不是唯一的正确答案，[3,1,4,null,2,null,null] 也是一个可行的构造方案。
```

#### 解题思路

这道题目，可以中序遍历把二叉树转变为有序数组，然后再根据有序数组构造平衡二叉搜索树。

实际上是[98. 验证二叉搜索树 ](https://leetcode.cn/problems/validate-binary-search-tree/) 和 [108. 将有序数组转换为二叉搜索树 ](https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/)的结合

```cpp
class Solution {
private:
    vector<int> vc;
    void traversal(TreeNode* root){
        if(!root) return;
        traversal(root->left);
        vc.push_back(root->val);
        traversal(root->right);
    }
    TreeNode* getTree(vector<int>& nums, int l, int r){
        if(l > r) return NULL;
        int mid = l + ((r - l) / 2);
        TreeNode* root = new TreeNode(nums[mid]);
        root->left = getTree(nums, l, mid - 1);
        root->right = getTree(nums, mid + 1, r);
        return root;
    }
public:
    TreeNode* balanceBST(TreeNode* root) {
        traversal(root);
        return getTree(vc, 0, vc.size() - 1);
    }
};
```

二叉树

满二叉树

完全二叉树

线索树

二叉排序树     BST

平衡二叉排序树 AVL

红黑树 

多路平衡查找树 B树

分块-多路平衡查找树 B+树